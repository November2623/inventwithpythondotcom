<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=UTF-8">
<meta name=Generator content="Microsoft Word 14 (filtered)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Courier;
	panose-1:2 7 4 9 2 2 5 2 4 4;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
	{font-family:"Franklin Gothic Demi";
	panose-1:2 11 7 3 2 1 2 2 2 4;}
@font-face
	{font-family:"Lucida Sans Typewriter";
	panose-1:2 11 5 9 3 5 4 3 2 4;}
@font-face
	{font-family:"Lucida Console";
	panose-1:2 11 6 9 4 5 4 2 2 4;}
@font-face
	{font-family:"Another Typewriter";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Consolas;
	panose-1:2 11 6 9 2 2 4 3 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
h1
	{mso-style-link:"Heading 1 Char";
	margin-top:24.0pt;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:36.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	font-weight:normal;}
h2
	{mso-style-link:"Heading 2 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:"Calibri","sans-serif";}
h3
	{mso-style-link:"Heading 3 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoToc1, li.MsoToc1, div.MsoToc1
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";}
p.MsoToc2, li.MsoToc2, div.MsoToc2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:11.0pt;
	line-height:115%;
	font-size:9.0pt;
	font-family:"Times New Roman","serif";}
p.MsoToc3, li.MsoToc3, div.MsoToc3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:22.0pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.MsoToc4, li.MsoToc4, div.MsoToc4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:33.0pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoToc5, li.MsoToc5, div.MsoToc5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:44.0pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoToc6, li.MsoToc6, div.MsoToc6
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:55.0pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoToc7, li.MsoToc7, div.MsoToc7
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:66.0pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoToc8, li.MsoToc8, div.MsoToc8
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:77.0pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoToc9, li.MsoToc9, div.MsoToc9
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:88.0pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{mso-style-link:"Header Char";
	margin:0in;
	margin-bottom:.0001pt;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{mso-style-link:"Footer Char";
	margin:0in;
	margin-bottom:.0001pt;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.MsoCaption, li.MsoCaption, div.MsoCaption
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	font-size:9.0pt;
	font-family:"Times New Roman","serif";
	color:#4F81BD;
	font-weight:bold;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{mso-style-link:"Title Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:48.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	letter-spacing:.25pt;}
p.MsoTitleCxSpFirst, li.MsoTitleCxSpFirst, div.MsoTitleCxSpFirst
	{mso-style-link:"Title Char";
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:48.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	letter-spacing:.25pt;}
p.MsoTitleCxSpMiddle, li.MsoTitleCxSpMiddle, div.MsoTitleCxSpMiddle
	{mso-style-link:"Title Char";
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:48.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	letter-spacing:.25pt;}
p.MsoTitleCxSpLast, li.MsoTitleCxSpLast, div.MsoTitleCxSpLast
	{mso-style-link:"Title Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:48.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	letter-spacing:.25pt;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{mso-style-link:"Balloon Text Char";
	margin:0in;
	margin-bottom:.0001pt;
	font-size:8.0pt;
	font-family:"Tahoma","sans-serif";}
p.MsoNoSpacing, li.MsoNoSpacing, div.MsoNoSpacing
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:.5in;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:.5in;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.MsoTocHeading, li.MsoTocHeading, div.MsoTocHeading
	{margin-top:24.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Cambria","serif";
	color:#365F91;
	font-weight:bold;}
span.Heading1Char
	{mso-style-name:"Heading 1 Char";
	mso-style-link:"Heading 1";
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;}
span.Heading2Char
	{mso-style-name:"Heading 2 Char";
	mso-style-link:"Heading 2";
	font-family:"Times New Roman","serif";
	font-weight:bold;}
span.Heading3Char
	{mso-style-name:"Heading 3 Char";
	mso-style-link:"Heading 3";
	font-family:"Times New Roman","serif";
	font-weight:bold;}
span.TitleChar
	{mso-style-name:"Title Char";
	mso-style-link:Title;
	font-family:"Franklin Gothic Demi","sans-serif";
	letter-spacing:.25pt;}
span.Definition
	{mso-style-name:Definition;
	font-family:"Calibri","sans-serif";
	font-weight:bold;}
span.HeaderChar
	{mso-style-name:"Header Char";
	mso-style-link:Header;
	font-family:"Times New Roman","serif";}
span.FooterChar
	{mso-style-name:"Footer Char";
	mso-style-link:Footer;
	font-family:"Times New Roman","serif";}
span.BalloonTextChar
	{mso-style-name:"Balloon Text Char";
	mso-style-link:"Balloon Text";
	font-family:"Tahoma","sans-serif";}
p.TableListing, li.TableListing, div.TableListing
	{mso-style-name:"Table Listing";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.TableHeader, li.TableHeader, div.TableHeader
	{mso-style-name:"Table Header";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";
	font-weight:bold;}
p.ChapterTitle, li.ChapterTitle, div.ChapterTitle
	{mso-style-name:"Chapter Title";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:48.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	letter-spacing:.25pt;}
p.ChapterTitleCxSpFirst, li.ChapterTitleCxSpFirst, div.ChapterTitleCxSpFirst
	{mso-style-name:"Chapter TitleCxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:48.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	letter-spacing:.25pt;}
p.ChapterTitleCxSpMiddle, li.ChapterTitleCxSpMiddle, div.ChapterTitleCxSpMiddle
	{mso-style-name:"Chapter TitleCxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:48.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	letter-spacing:.25pt;}
p.ChapterTitleCxSpLast, li.ChapterTitleCxSpLast, div.ChapterTitleCxSpLast
	{mso-style-name:"Chapter TitleCxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:48.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	letter-spacing:.25pt;}
span.URL
	{mso-style-name:URL;
	color:windowtext;
	text-decoration:underline;}
p.SourceCodeExcerpt, li.SourceCodeExcerpt, div.SourceCodeExcerpt
	{mso-style-name:"Source Code Excerpt";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";}
p.SourceCodeExcerptCxSpFirst, li.SourceCodeExcerptCxSpFirst, div.SourceCodeExcerptCxSpFirst
	{mso-style-name:"Source Code ExcerptCxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";}
p.SourceCodeExcerptCxSpMiddle, li.SourceCodeExcerptCxSpMiddle, div.SourceCodeExcerptCxSpMiddle
	{mso-style-name:"Source Code ExcerptCxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";}
p.SourceCodeExcerptCxSpLast, li.SourceCodeExcerptCxSpLast, div.SourceCodeExcerptCxSpLast
	{mso-style-name:"Source Code ExcerptCxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";}
p.SourceCodeFeatured, li.SourceCodeFeatured, div.SourceCodeFeatured
	{mso-style-name:"Source Code \(Featured\)";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.SourceCodeFeaturedCxSpFirst, li.SourceCodeFeaturedCxSpFirst, div.SourceCodeFeaturedCxSpFirst
	{mso-style-name:"Source Code \(Featured\)CxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.SourceCodeFeaturedCxSpMiddle, li.SourceCodeFeaturedCxSpMiddle, div.SourceCodeFeaturedCxSpMiddle
	{mso-style-name:"Source Code \(Featured\)CxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.SourceCodeFeaturedCxSpLast, li.SourceCodeFeaturedCxSpLast, div.SourceCodeFeaturedCxSpLast
	{mso-style-name:"Source Code \(Featured\)CxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
span.SourceCode
	{mso-style-name:"Source Code";
	font-family:"Lucida Console";}
p.SampleRun, li.SampleRun, div.SampleRun
	{mso-style-name:"Sample Run";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";}
p.SampleRunCxSpFirst, li.SampleRunCxSpFirst, div.SampleRunCxSpFirst
	{mso-style-name:"Sample RunCxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";}
p.SampleRunCxSpMiddle, li.SampleRunCxSpMiddle, div.SampleRunCxSpMiddle
	{mso-style-name:"Sample RunCxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";}
p.SampleRunCxSpLast, li.SampleRunCxSpLast, div.SampleRunCxSpLast
	{mso-style-name:"Sample RunCxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";}
span.SampleRunResponse
	{mso-style-name:"Sample Run Response";
	color:black;}
span.SourceLineNumber
	{mso-style-name:"Source Line Number";
	color:gray;}
p.MessageText, li.MessageText, div.MessageText
	{mso-style-name:"Message Text";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:11.0pt;
	font-family:"Lucida Sans Typewriter";}
p.TopicsCoveredbox, li.TopicsCoveredbox, div.TopicsCoveredbox
	{mso-style-name:"Topics Covered box";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	background:#DBE5F1;
	border:none;
	padding:0in;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.TopicsCoveredboxCxSpFirst, li.TopicsCoveredboxCxSpFirst, div.TopicsCoveredboxCxSpFirst
	{mso-style-name:"Topics Covered boxCxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	background:#DBE5F1;
	border:none;
	padding:0in;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.TopicsCoveredboxCxSpMiddle, li.TopicsCoveredboxCxSpMiddle, div.TopicsCoveredboxCxSpMiddle
	{mso-style-name:"Topics Covered boxCxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	background:#DBE5F1;
	border:none;
	padding:0in;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.TopicsCoveredboxCxSpLast, li.TopicsCoveredboxCxSpLast, div.TopicsCoveredboxCxSpLast
	{mso-style-name:"Topics Covered boxCxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	background:#DBE5F1;
	border:none;
	padding:0in;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
span.Literal
	{mso-style-name:Literal;
	font-family:Courier;}
span.SourceCodeComment
	{mso-style-name:"Source Code Comment";
	color:#7F7F7F;}
p.FigureCaption, li.FigureCaption, div.FigureCaption
	{mso-style-name:"Figure Caption";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:0in;
	text-align:center;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.FigureCaptionCxSpFirst, li.FigureCaptionCxSpFirst, div.FigureCaptionCxSpFirst
	{mso-style-name:"Figure CaptionCxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.FigureCaptionCxSpMiddle, li.FigureCaptionCxSpMiddle, div.FigureCaptionCxSpMiddle
	{mso-style-name:"Figure CaptionCxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
p.FigureCaptionCxSpLast, li.FigureCaptionCxSpLast, div.FigureCaptionCxSpLast
	{mso-style-name:"Figure CaptionCxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:8.0pt;
	margin-left:0in;
	text-align:center;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
span.SourceCodeFilename
	{mso-style-name:"Source Code Filename";
	font-family:"Lucida Sans Typewriter";}
p.TableCaption, li.TableCaption, div.TableCaption
	{mso-style-name:"Table Caption";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:2.0pt;
	margin-left:0in;
	text-align:center;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";}
span.Filename
	{mso-style-name:Filename;
	font-style:italic;}
p.CipherInfoBox, li.CipherInfoBox, div.CipherInfoBox
	{mso-style-name:"Cipher Info Box";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	background:#FFFF99;
	border:none;
	padding:0in;
	font-size:14.0pt;
	font-family:"Another Typewriter";
	letter-spacing:1.4pt;}
p.ChapterQuotes, li.ChapterQuotes, div.ChapterQuotes
	{mso-style-name:"Chapter Quotes";
	margin-top:30.0pt;
	margin-right:1.0in;
	margin-bottom:30.0pt;
	margin-left:1.0in;
	text-align:justify;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Times New Roman","serif";}
p.ChapterQuotesCxSpFirst, li.ChapterQuotesCxSpFirst, div.ChapterQuotesCxSpFirst
	{mso-style-name:"Chapter QuotesCxSpFirst";
	margin-top:30.0pt;
	margin-right:1.0in;
	margin-bottom:0in;
	margin-left:1.0in;
	margin-bottom:.0001pt;
	text-align:justify;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Times New Roman","serif";}
p.ChapterQuotesCxSpMiddle, li.ChapterQuotesCxSpMiddle, div.ChapterQuotesCxSpMiddle
	{mso-style-name:"Chapter QuotesCxSpMiddle";
	margin-top:0in;
	margin-right:1.0in;
	margin-bottom:0in;
	margin-left:1.0in;
	margin-bottom:.0001pt;
	text-align:justify;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Times New Roman","serif";}
p.ChapterQuotesCxSpLast, li.ChapterQuotesCxSpLast, div.ChapterQuotesCxSpLast
	{mso-style-name:"Chapter QuotesCxSpLast";
	margin-top:0in;
	margin-right:1.0in;
	margin-bottom:30.0pt;
	margin-left:1.0in;
	text-align:justify;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Times New Roman","serif";}
p.CodeExample, li.CodeExample, div.CodeExample
	{mso-style-name:"Code Example";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:"Courier New";}
p.CodeExampleCxSpFirst, li.CodeExampleCxSpFirst, div.CodeExampleCxSpFirst
	{mso-style-name:"Code ExampleCxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:"Courier New";}
p.CodeExampleCxSpMiddle, li.CodeExampleCxSpMiddle, div.CodeExampleCxSpMiddle
	{mso-style-name:"Code ExampleCxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:"Courier New";}
p.CodeExampleCxSpLast, li.CodeExampleCxSpLast, div.CodeExampleCxSpLast
	{mso-style-name:"Code ExampleCxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:10.0pt;
	font-family:"Courier New";}
p.SmallerText, li.SmallerText, div.SmallerText
	{mso-style-name:"Smaller Text";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:9.0pt;
	font-family:"Times New Roman","serif";}
p.SourceCodeHeadline, li.SourceCodeHeadline, div.SourceCodeHeadline
	{mso-style-name:"Source Code \(Headline\)";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:7.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.SourceCodeHeadlineCxSpFirst, li.SourceCodeHeadlineCxSpFirst, div.SourceCodeHeadlineCxSpFirst
	{mso-style-name:"Source Code \(Headline\)CxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:7.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.SourceCodeHeadlineCxSpMiddle, li.SourceCodeHeadlineCxSpMiddle, div.SourceCodeHeadlineCxSpMiddle
	{mso-style-name:"Source Code \(Headline\)CxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:7.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.SourceCodeHeadlineCxSpLast, li.SourceCodeHeadlineCxSpLast, div.SourceCodeHeadlineCxSpLast
	{mso-style-name:"Source Code \(Headline\)CxSpLast";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:7.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.Style1, li.Style1, div.Style1
	{mso-style-name:Style1;
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:7.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.Style1CxSpFirst, li.Style1CxSpFirst, div.Style1CxSpFirst
	{mso-style-name:Style1CxSpFirst;
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:7.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.Style1CxSpMiddle, li.Style1CxSpMiddle, div.Style1CxSpMiddle
	{mso-style-name:Style1CxSpMiddle;
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:7.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.Style1CxSpLast, li.Style1CxSpLast, div.Style1CxSpLast
	{mso-style-name:Style1CxSpLast;
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:7.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
.MsoChpDefault
	{font-family:"Calibri","sans-serif";}
.MsoPapDefault
	{margin-bottom:10.0pt;
	line-height:115%;}
@page WordSection1
	{size:8.5in 11.0in;
	margin:1.0in 1.0in 1.0in 1.0in;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>

</head>

<body lang=EN-US link=blue vlink=purple>
<div style='float: right; height: 310px; font-family: sans-serif;'>Ad: Programming books by Al Sweigart<br />
    <a href='http://www.nostarch.com/automatestuff' onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src='/images/cover_automate_thumb.png' style="height: 200px; border: solid black 1px;" /></a>
    <a href='http://www.amazon.com/gp/product/0982106017?ie=UTF8&tag=playwithpyth-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0982106017' onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src='/images/cover_inventwithpython_thumb.jpg' style="height: 200px; border: solid black 1px;" /></a>
    <a href='http://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&tag=playwithpyth-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0982106017' onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src='/images/cover_makinggames_thumb.png' style="height: 200px; border: solid black 1px;" /></a>
    <a href='https://www.amazon.com/gp/product/1593278225/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593278225&linkCode=as2&tag=playwithpyth-20&linkId=bf3b22819f0886d277e88b8a653b81ad' onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src='/images/cover_crackingcodes_thumb.png' style="height: 200px; border: solid black 1px;" /></a>
</div>

<div class=WordSection1><p><strong>Note: The second edition of this book is available under the title <em><a href="https://inventwithpython.com/cracking">Cracking Codes with Python</a></em></strong></p>

<p class=MsoNormal align=center style='text-align:center'><img width=327
height=180 id="Picture 39" src="chapter18_files/image001.jpg">  </p>

<div style='border:none;border-bottom:solid #4F81BD 1.0pt;padding:0in 0in 1.0pt 0in'>

<h1><a name="_Toc353630851"><span style='font-variant:normal !important;
text-transform:uppercase'>Hacking the Simple Substitution Cipher</span></a></h1>

</div>

<div style='border:solid windowtext 1.0pt;padding:4.0pt 4.0pt 4.0pt 4.0pt;
background:#DBE5F1'>

<p class=TopicsCoveredboxCxSpFirst style='background:#DBE5F1;border:none;
padding:0in'>Topics Covered In This Chapter:</p>

<p class=TopicsCoveredboxCxSpMiddle style='margin-left:.25in;text-indent:-.25in;
background:#DBE5F1;border:none;padding:0in'><span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Word patterns, candidates, potential decryption letters, and
cipherletter mappings.</p>

<p class=TopicsCoveredboxCxSpMiddle style='margin-left:.25in;text-indent:-.25in;
background:#DBE5F1;border:none;padding:0in'><span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The <span class=Literal>pprint.pprint()</span> and <span
class=Literal>pprint.pformat()</span> functions</p>

<p class=TopicsCoveredboxCxSpMiddle style='margin-left:.25in;text-indent:-.25in;
background:#DBE5F1;border:none;padding:0in'><span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Building strings using the list-append-join process</p>

<p class=TopicsCoveredboxCxSpMiddle style='margin-left:.25in;text-indent:-.25in;
background:#DBE5F1;border:none;padding:0in'><span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Regular expressions</p>

<p class=TopicsCoveredboxCxSpLast style='margin-left:.25in;text-indent:-.25in;
background:#DBE5F1;border:none;padding:0in'><span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The <span class=Literal>sub()</span> regex method</p>

</div>

<p class=ChapterQuotesCxSpFirst style='margin-left:63.0pt'>“Cypherpunks deplore
regulations on cryptography, for encryption is fundamentally a private act. The
act of encryption, in fact, removes information from the public realm. Even
laws against cryptography reach only so far as a nation’s border and the arm of
its violence.”</p>

<p class=ChapterQuotesCxSpMiddle>&nbsp;</p>

<p class=ChapterQuotesCxSpMiddle align=right style='text-align:right'><span
style='font-size:11.0pt;line-height:115%'>Eric Hughes, “A Cypherpunk’s
Manifesto”, 1993</span></p>

<p class=ChapterQuotesCxSpLast align=right style='text-align:right'><span
class=URL><u><span style='font-size:11.0pt;line-height:115%'>http://invpy.com/cypherpunk</span></u></span></p>

<h2><a name="_Toc353630852">Computing Word Patterns</a></h2>

<p class=MsoNormal>There are too many possible keys to brute-force a simple
substitution cipher-encrypted message. We need to employ a more intelligent
attack if we want to crack a substitution ciphertext. Let’s examine one possible
word from an example ciphertext: </p>

<div style='border:solid windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
margin-left:2.5in;margin-right:2.5in'>

<p class=MessageText align=center style='text-align:center;border:none;
padding:0in'>HGHHU</p>

</div>

<p class=MsoNormal>Think about what we can learn from this one word of
ciphertext (which we will call a <span class=Definition><span style='font-size:
12.0pt;line-height:115%'>cipherword</span></span> in this book). We can tell
that whatever the original plaintext word is, it must:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-.25in'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Be
five letters long.</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Have
the first, third, and fourth letters be the same.</p>

<p class=MsoListParagraphCxSpLast style='text-indent:-.25in'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Have
exactly three different letters in the word, where the first, second, and fifth
letters in the word are all different from each other.</p>

<p class=MsoNormal>What words in the English language fit this pattern? “Puppy”
is one word that fits this pattern. It is five letters long (P, U, P, P, Y) using
three different letters (P, U, Y) in that same pattern (P for the first, third,
and fourth letter and U for the second letter and Y for the fifth letter).
“Mommy”, “Bobby”, “lulls”, “nanny”, and “lilly” fit the pattern too. (“Lilly”
is a name, not to be confused with “Lily” the flower. But since “Lilly” can
appear in an Engish message it is a possible word that fits the pattern.) If we
had a lot of time on our hands, we could go through an entire dictionary and
find all the words that fit this pattern. Even better, we could have a computer
go through a dictionary file for us. </p>

<p class=MsoNormal>In this book a <span class=Definition><span
style='font-size:12.0pt;line-height:115%'>word pattern</span></span> will be a
set of numbers with periods in between the numbers that tells us the pattern of
letters for a word, in either ciphertext or plaintext.</p>

<p class=MsoNormal>Creating word patterns for cipherwords is easy: the first
letter gets the number 0 and the first occurrence of each different letter
after that gets the next number. For example:</p>

<p class=MsoListParagraphCxSpFirst style='margin-left:.25in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The word pattern for “cat” is 0.1.2.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.25in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The word pattern for “catty” is 0.1.2.2.3.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.25in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The word pattern for “roofer” is 0.1.1.2.3.0.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.25in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The word pattern for “blimp” is 0.1.2.3.4.</p>

<p class=MsoListParagraphCxSpLast style='margin-left:.25in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The word pattern for “classification” is 0.1.2.3.3.4.5.4.0.2.6.4.7.8.</p>

<p class=MsoNormal><strong>A plaintext word and its cipherword will always have
the same word pattern, no matter which simple substitution key was used to do
the encryption.</strong></p>

<h2><a name="_Toc353630853">Getting a List of Candidates for a Cipherword</a></h2>

<p class=MsoNormal>To take a guess at what HGHHU could decrypt to, we can go
through the dictionary file and find all of the words that also have a word
pattern of 0.1.0.0.2. In this book, we will call these plaintext words (that
have the same word pattern as the cipherword) the <span class=Definition><span
style='font-size:12.0pt;line-height:115%'>candidates</span></span> for that
cipherword:</p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:77.4pt;border-collapse:collapse'>
 <tr style='height:16.5pt'>
  <td width=192 valign=top style='width:2.0in;border-top:double windowtext 1.5pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt;height:16.5pt'>
  <p class=TableListing align=right style='text-align:right'>Ciphertext word:</p>
  </td>
  <td width=120 valign=top style='width:1.25in;border-top:double windowtext 1.5pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt;height:16.5pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>H G
  H H U</span></p>
  </td>
 </tr>
 <tr>
  <td width=192 valign=top style='width:2.0in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing align=right style='text-align:right'>Word pattern:</p>
  </td>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>0.1.0.0.2</span></p>
  </td>
 </tr>
 <tr>
  <td width=192 valign=top style='width:2.0in;border:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing align=right style='text-align:right'>Candidates:</p>
  </td>
  <td width=120 valign=top style='width:1.25in;border:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>p u
  p p y</span></p>
  </td>
 </tr>
 <tr>
  <td width=192 valign=top style='width:2.0in;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing>&nbsp;</p>
  </td>
  <td width=120 valign=top style='width:1.25in;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>m o
  m m y</span></p>
  </td>
 </tr>
 <tr>
  <td width=192 valign=top style='width:2.0in;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing>&nbsp;</p>
  </td>
  <td width=120 valign=top style='width:1.25in;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>b o
  b b y</span></p>
  </td>
 </tr>
 <tr>
  <td width=192 valign=top style='width:2.0in;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing>&nbsp;</p>
  </td>
  <td width=120 valign=top style='width:1.25in;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>l u
  l l s</span></p>
  </td>
 </tr>
 <tr>
  <td width=192 valign=top style='width:2.0in;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing>&nbsp;</p>
  </td>
  <td width=120 valign=top style='width:1.25in;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>n a n
  n y</span></p>
  </td>
 </tr>
 <tr>
  <td width=192 valign=top style='width:2.0in;border:none;border-bottom:double windowtext 1.5pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing>&nbsp;</p>
  </td>
  <td width=120 valign=top style='width:1.25in;border:none;border-bottom:double windowtext 1.5pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>l i
  l l y</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>So if we look at the letters in the cipherword (which will
be called <span class=Definition><span style='font-size:12.0pt;line-height:
115%'>cipherletters</span></span> in this book), we can guess which letters
they may decrypt to (we will call these letters the cipherletter’s <span
class=Definition><span style='font-size:12.0pt;line-height:115%'>potential
decryption letters</span></span> in this book):</p>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:77.4pt;border-collapse:collapse'>
 <tr>
  <td width=192 valign=top style='width:2.0in;border-top:double windowtext 1.5pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing align=right style='text-align:right'>Cipherletters:</p>
  </td>
  <td width=24 valign=top style='width:.25in;border-top:double windowtext 1.5pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>H</span></p>
  </td>
  <td width=30 valign=top style='width:22.5pt;border-top:double windowtext 1.5pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>G</span></p>
  </td>
  <td width=66 valign=top style='width:49.5pt;border-top:double windowtext 1.5pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>U</span></p>
  </td>
 </tr>
 <tr>
  <td width=192 valign=top style='width:2.0in;border:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing align=right style='text-align:right'>Potential
  decryption letters:</p>
  </td>
  <td width=24 valign=top style='width:.25in;border:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>p</span></p>
  </td>
  <td width=30 valign=top style='width:22.5pt;border:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>u</span></p>
  </td>
  <td width=66 valign=top style='width:49.5pt;border:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>y</span></p>
  </td>
 </tr>
 <tr>
  <td width=192 valign=top style='width:2.0in;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing>&nbsp;</p>
  </td>
  <td width=24 valign=top style='width:.25in;border:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>m</span></p>
  </td>
  <td width=30 valign=top style='width:22.5pt;border:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>o</span></p>
  </td>
  <td width=66 valign=top style='width:49.5pt;border:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>y</span></p>
  </td>
 </tr>
 <tr>
  <td width=192 valign=top style='width:2.0in;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing>&nbsp;</p>
  </td>
  <td width=24 valign=top style='width:.25in;border:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>b</span></p>
  </td>
  <td width=30 valign=top style='width:22.5pt;border:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>o</span></p>
  </td>
  <td width=66 valign=top style='width:49.5pt;border:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>y</span></p>
  </td>
 </tr>
 <tr>
  <td width=192 valign=top style='width:2.0in;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing>&nbsp;</p>
  </td>
  <td width=24 valign=top style='width:.25in;border:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>l</span></p>
  </td>
  <td width=30 valign=top style='width:22.5pt;border:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>u</span></p>
  </td>
  <td width=66 valign=top style='width:49.5pt;border:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>s</span></p>
  </td>
 </tr>
 <tr>
  <td width=192 valign=top style='width:2.0in;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing>&nbsp;</p>
  </td>
  <td width=24 valign=top style='width:.25in;border:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>n</span></p>
  </td>
  <td width=30 valign=top style='width:22.5pt;border:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>a</span></p>
  </td>
  <td width=66 valign=top style='width:49.5pt;border:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>y</span></p>
  </td>
 </tr>
 <tr>
  <td width=192 valign=top style='width:2.0in;border:none;border-bottom:double windowtext 1.5pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing>&nbsp;</p>
  </td>
  <td width=24 valign=top style='width:.25in;border-top:none;border-left:none;
  border-bottom:double windowtext 1.5pt;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>l</span></p>
  </td>
  <td width=30 valign=top style='width:22.5pt;border-top:none;border-left:none;
  border-bottom:double windowtext 1.5pt;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>i</span></p>
  </td>
  <td width=66 valign=top style='width:49.5pt;border:none;border-bottom:double windowtext 1.5pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=TableListing><span style='font-family:"Lucida Sans Typewriter"'>y</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>From this table we can create a <span class=Definition><span
style='font-size:12.0pt;line-height:115%'>cipherletter mapping</span></span>:</p>

<p class=MsoListParagraphCxSpFirst style='margin-left:.25in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The cipher letter H has the potential decryption letters P, M, B,
L, and N</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.25in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The cipher letter G has the potential decryption letters U, O, A,
and I</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.25in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The cipher letter U has the potential decryption letters Y and S</p>

<p class=MsoListParagraphCxSpLast style='margin-left:.25in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>All of the other cipher letters besides H, G, and U will have no
potential decryption letters.</p>

<p class=MsoNormal>When we represent a cipherletter mapping in Python code, we
will use a dictionary value:</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerpt style='border:none;padding:0in'>{'A': [], 'B': [],
'C': [], 'D': [], 'E': [], 'F': [], 'G': ['U', 'O', 'A', 'I'], 'H': ['P', 'B',
'L', 'N'], 'I': [], 'J': [], 'K': [], 'L': [], 'M': [], 'N': [], 'O': [], 'P':
[], 'Q': [], 'R': [], 'S': [], 'T': [], 'U': ['Y', 'S'], 'V': [], 'W': [], 'X':
[], 'Y': [], 'Z': []}</p>

</div>

<p class=MsoNormal>In our program, a cipherletter mapping dictionary will have
26 keys, one for each letter. The mapping above has potential decryption
letters for <span class=Literal>'H'</span>, <span class=Literal>'G'</span>, and
<span class=Literal>'U'</span> above. The other keys have no potential decryption
letters, which is why they have empty lists for values.</p>

<p class=MsoNormal>If we reduce the number of potential decryption letters for
a cipherletter to just one letter, then we have solved what that cipherletter
decrypts to. Even if we do not solve all 26 cipherletters, we might be able to
hack most of the ciphertext’s cipherletters.</p>

<p class=MsoNormal>But first we must find the pattern for every word in the
dictionary file and sort them in a list so it will be easy to get a list of all
the candidates for a given cipherword’s word pattern. We can use the same
dictionary file from Chapter 12, which you can download from <span class=URL><u>http://invpy.com/dictionary.txt</u></span>.</p>

<p class=MsoNormal>(Note that the terms “word pattern”, “candidate”, and
“cipherletter mapping” are terms I came up with to describe things in this
particular hacking program. These are not general cryptography terms.)</p>

<h2><a name="_Toc353630854">Practice Exercises, Chapter 18, Set A</a></h2>

<p class=MsoNormal>Practice exercises can be found at <span class=URL><u>http://invpy.com/hackingpractice18A</u></span>.</p>

<h2><a name="_Toc353630855">Source Code of the Word Pattern Module</a></h2>

<p class=MsoNormal>Since the word patterns for words never change, we can just
calculate the word pattern for every word in a dictionary file once and store them
in another file. Our <span class=Filename>makeWordPatterns.py</span> program creates
a file named <span class=Filename>wordPatterns.py</span> that will contain a
dictionary value with the word pattern for every word in the dictionary file.
Our hacking program can then just import <span class=Literal>wordPatterns</span>
to look up the candidates for a certain word pattern.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst align=right style='text-align:right'><span
class=SourceCodeFilename><span style='font-size:13.0pt;line-height:115%'>Source
code for makeWordPatterns.py</span></span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 1.</span> <span
class=SourceCodeComment># Makes the wordPatterns.py File</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 2.</span> <span
class=SourceCodeComment># http://inventwithpython.com/hacking (BSD Licensed)</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 3. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 4.</span> <span
class=SourceCodeComment># Creates wordPatterns.py based on the words in our
dictionary</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 5.</span> <span
class=SourceCodeComment># text file, dictionary.txt. (Download this file from</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 6.</span> <span
class=SourceCodeComment># http://invpy.com/dictionary.txt)</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 7. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 8.</span>
import pprint</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 9. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>10. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>11.</span>
def getWordPattern(word):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>12.</span>    
<span class=SourceCodeComment># Returns a string of the pattern form of the
given word.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>13.</span>    
<span class=SourceCodeComment># e.g. '0.1.2.3.4.1.2.3.5.6' for 'DUSTBUSTER'</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>14.</span>    
word = word.upper()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>15.</span>    
nextNum = 0</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>16.</span>    
letterNums = {}</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>17.</span>    
wordPattern = []</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>18. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>19.</span>    
for letter in word:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>20.</span>        
if letter not in letterNums:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>21.</span>            
letterNums[letter] = str(nextNum)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>22.</span>            
nextNum += 1</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>23.</span>        
wordPattern.append(letterNums[letter])</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>24.</span>    
return '.'.join(wordPattern)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>25. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>26. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>27.</span>
def main():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>28.</span>    
allPatterns = {}</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>29. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>30.</span>    
fo = open('dictionary.txt')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>31.</span>    
wordList = fo.read().split('\n')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>32.</span>    
fo.close()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>33. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>34.</span>    
for word in wordList:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>35.</span>        
<span class=SourceCodeComment># Get the pattern for each string in wordList.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>36.</span>        
pattern = getWordPattern(word)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>37. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>38.</span>        
if pattern not in allPatterns:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>39.</span>            
allPatterns[pattern] = [word]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>40.</span>        
else:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>41.</span>            
allPatterns[pattern].append(word)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>42. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>43.</span>    
<span class=SourceCodeComment># This is code that writes code. The
wordPatterns.py file contains</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>44.</span>    
<span class=SourceCodeComment># one very, very large assignment statement.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>45.</span>    
fo = open('wordPatterns.py', 'w')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>46.</span>    
fo.write('allPatterns = ')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>47.</span>    
fo.write(pprint.pformat(allPatterns))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>48.</span>    
fo.close()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>49. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>50. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>51.</span>
if __name__ == '__main__':</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>52.</span>    
main()</p>

</div>

<h2><a name="_Toc353630856">Sample Run of the Word Pattern Module</a></h2>

<p class=MsoNormal>Running this program doesn’t print anything out to the
screen. Instead it silently creates a file named <span class=Filename>wordPatterns.py</span>
in the same folder as <span class=Filename>makeWordPatterns.py</span>. Open
this file in IDLE’s file editor, and you will see it looks like this:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>allPatterns
= {'0.0.1': ['EEL'],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> '0.0.1.2':
['EELS', 'OOZE'],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> '0.0.1.2.0':
['EERIE'],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> '0.0.1.2.3':
['AARON', 'LLOYD', 'OOZED'],</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'><em><span
style='font-family:"Lucida Sans Typewriter"'>...the rest has been cut for
brevity...</span></em></p>

</div>

<p class=MsoNormal>The <span class=Filename>makeWordPatterns.py</span> program
creates <span class=Filename>wordPatterns.py</span>. Our Python program creates
a Python program! The entire <span class=Filename>wordPatterns.py</span> program
is just one (very big) assignment statement for a variable named <span
class=Literal>allPatterns</span>. Even though this assignment statement
stretches over many lines in the file, it is considered one “line of code”
because Python knows that if a line ends with a comma but it is currently in
the middle of a dictionary value, it ignores the indentation of the next line
and just considers it part of the previous line. (This is a rare exception for
Python’s significant indentation rules.)</p>

<p class=MsoNormal>The <span class=Literal>allPatterns</span> variable contains
a dictionary value where the keys are all the word patterns made from the
English words in the dictionary file. The keys’ values are lists of strings of
English words with that pattern. When <span class=Filename>wordPatterns.py</span>
is imported as a module, our program will be able to look up all the English
words for any given word pattern.</p>

<p class=MsoNormal>After running the <span class=Filename>makeWordPatterns.py</span>
program to create the <span class=Filename>wordPatterns.py</span> file, try
typing the following into the interactive shell:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
import wordPatterns</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
wordPatterns.allPatterns['0.1.2.1.1.3.4']</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>['BAZAARS',
'BESEECH', 'REDEEMS', 'STUTTER']</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
wordPatterns.allPatterns['0.1.2.2.3.2.4.1.5.5']</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>['CANNONBALL']</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
wordPatterns.allPatterns['0.1.0.1.0.1']</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>Traceback
(most recent call last):</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>  File
&quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>KeyError:
'0.1.0.1.0.1'</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
'0.1.0.1.0.1' in wordPatterns.allPatterns</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>False</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>The pattern <span class=Literal>'0.1.0.1.0.1'</span> does
not exist in the dictionary. This is why the expression <span class=Literal>wordPatterns.allPatterns['0.1.0.1.0.1']</span>
causes an error (because there is no <span class=Literal>'0.1.0.1.0.1'</span>
key in <span class=Literal>allPatterns</span>) and why <span class=Literal>'0.1.0.1.0.1'</span>
in <span class=Literal>wordPatterns.allPatterns</span> evaluates to <span
class=Literal>False</span>.</p>

<h2><a name="_Toc353630857">How the Program Works</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>makeWordPatterns.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 1.</span> <span
class=SourceCodeComment># Makes the wordPatterns.py File</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 2.</span> <span
class=SourceCodeComment># http://inventwithpython.com/hacking (BSD Licensed)</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 3. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 4.</span> <span
class=SourceCodeComment># Creates wordPatterns.py based on the words in our
dictionary</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 5.</span> <span
class=SourceCodeComment># text file, dictionary.txt. (Download this file from</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 6.</span> <span
class=SourceCodeComment># http://invpy.com/dictionary.txt)</span></p>

</div>

<p class=MsoNormal>The top part of this file has the usual comments describing
what the program is.</p>

<h2><a name="_Toc353630858">The </a><span class=Literal>pprint.pprint()</span>
and <span class=Literal>pprint.pformat()</span> Functions</h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>makeWordPatterns.py </p>

<p class=SourceCodeFeatured><span class=SourceLineNumber> 8.</span> import
pprint</p>

</div>

<p class=MsoNormal>The <span class=Literal>pprint</span> module has functions
for <span class=Definition><span style='font-size:12.0pt;line-height:115%'>pretty
printing</span></span> values, which is useful for printing dictionary and list
values on the screen. The <span class=Literal>print()</span> function simply
prints these values going left to right:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
print(someListOfListsVar))</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>[['ant'], ['baboon',
'badger', 'bat', 'bear', 'beaver'], ['camel', 'cat', 'clam', 'cobra', 'cougar',
'coyote', 'crow'], ['deer', 'dog', 'donkey', 'duck'], ['eagle'], ['ferret',
'fox', 'frog'], ['goat']]</p>

</div>

<p class=MsoNormal>The <span class=Literal>pprint</span> module has a function
named <span class=Literal>pprint()</span>. The value passed to <span
class=Literal>pprint.pprint()</span> will be “pretty printed” to the screen so
that it is easier to read:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
import pprint</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
pprint.pprint(someListOfListsVar))</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>[['ant'],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> ['baboon',
'badger', 'bat', 'bear', 'beaver'],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> ['camel',
'cat', 'clam', 'cobra', 'cougar', 'coyote', 'crow'],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> ['deer',
'dog', 'donkey', 'duck'],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> ['eagle'],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> ['ferret',
'fox', 'frog'],</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'> ['goat']]</p>

</div>

<p class=MsoNormal>However, if you want to have this “prettified” text as a
string value <strong>instead</strong> of displaying it on the screen, you can
use the <span class=Literal>pprint.pformat()</span> function, which returns the
prettified string:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
import pprint</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
prettifiedString = pprint.pformat(someListOfListsVar)</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
print(prettifiedString)</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>[['ant'],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> ['baboon',
'badger', 'bat', 'bear', 'beaver'],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> ['camel',
'cat', 'clam', 'cobra', 'cougar', 'coyote', 'crow'],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> ['deer',
'dog', 'donkey', 'duck'],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> ['eagle'],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> ['ferret',
'fox', 'frog'],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> ['goat']]</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>When we write the value of <span class=Literal>allPatterns</span>
to the <span class=Filename>wordPatterns.py</span> file, we will use the <span
class=Literal>pprint</span> module to prevent it from being printed crammed
together all on one line.</p>

<h2><a name="_Toc353630859">Building Strings in Python with Lists</a></h2>

<p class=MsoNormal>Almost all of our programs have done some form of “building
a string” code. That is, a variable will start as a blank string and then new
characters are added with string concatenation. (We’ve done this in many
previous cipher programs with the <span class=Literal>translated</span>
variable.) This is usually done with the <span class=Literal>+</span> operator
to do string concatenation, as in the following short program:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'><span
class=SourceCodeComment># The slow way to build a string using string
concatenation.</span></p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>building =
''</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>for c in
'Hello world!':</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>   
building += c</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>print(building)</p>

</div>

<p class=MsoNormal>The above program loops through each character in the string
<span class=Literal>'Hello world!'</span> and concatenates it to the end of the
string stored in <span class=Literal>building</span>. At the end of the loop, <span
class=Literal>building</span> holds the complete string.</p>

<p class=MsoNormal>This seems like a straightforward way to do this. However,
it is very inefficient for Python to concatenate strings. The reasons are
technical and beyond the scope of this book, but <strong>it is much faster to
start with a blank list instead of a blank string, and then use the </strong><span
class=Literal>append()</span><strong> list method instead of string
concatenation</strong>. After you are done building the list of strings, you
can convert the list of strings to a single string value with the <span
class=Literal>join()</span> method. The following short program does exactly the
same thing as the previous example, but faster:</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'><span
class=SourceCodeComment># The fast way to build a string using a list,
append(), and join().</span></p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>building =
[]</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>for c in
'Hello world!':</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>   
building.append(c)</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>building =
''.join(building)</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>print(building)</p>

</div>

<p class=MsoNormal>Using this approach for building up strings in your code
will result in much faster programs. We will be using this list-append-join
process to build strings in the remaining programs of this book.</p>

<h2><a name="_Toc353630860">Calculating the Word Pattern</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>makeWordPatterns.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>11.</span>
def getWordPattern(word):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>12.</span>    
<span class=SourceCodeComment># Returns a string of the pattern form of the
given word.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>13.</span>    
<span class=SourceCodeComment># e.g. '0.1.2.3.4.1.2.3.5.6' for 'DUSTBUSTER'</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>14.</span>    
word = word.upper()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>15.</span>    
nextNum = 0</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>16.</span>    
letterNums = {}</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>17.</span>    
wordPattern = []</p>

</div>

<p class=MsoNormal>The <span class=Literal>getWordPattern()</span> function
takes one string argument and returns a string of that word’s pattern. For
example, if <span class=Literal>getWordPattern()</span> were passed the string <span
class=Literal>'Buffoon'</span> as an argument then <span class=Literal>getWordPattern()</span>
would return the string <span class=Literal>'0.1.2.2.3.3.4'</span>.</p>

<p class=MsoNormal>First, in order to make sure all the letters have the same
case, line 14 changes the <span class=Literal>word</span> parameter to an
uppercase version of itself. We then need three variables:</p>

<p class=MsoListParagraphCxSpFirst style='margin-left:.25in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span class=Literal>nextNum</span> stores the next number used when
a new letter is found.</p>

<p class=MsoListParagraphCxSpMiddle style='margin-left:.25in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span class=Literal>letterNums</span> stores a dictionary with
keys of single-letter strings of single letters, and values of the integer number
for that letter. As we find new letters in the word, the letter and its number
are stored in <span class=Literal>letterNums</span>.</p>

<p class=MsoListParagraphCxSpLast style='margin-left:.25in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span class=Literal>wordPattern</span> will be the string that is
returned from this function. But we will be building this string one character
at a time, so we will use the list-append-join process to do this. This is why <span
class=Literal>wordPattern</span> starts as a blank list instead of a blank
string.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline style='margin-left:.25in;text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>makeWordPatterns.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>19.</span>    
for letter in word:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>20.</span>    
    if letter not in letterNums:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>21.</span>            
letterNums[letter] = str(nextNum)</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>22.</span>            
nextNum += 1</p>

</div>

<p class=MsoNormal>Line 19’s <span class=Literal>for</span> loop will loop through
each character in the <span class=Literal>word</span> parameter, assigning each
character to a variable named <span class=Literal>letter</span>.</p>

<p class=MsoNormal>Line 20 checks if <span class=Literal>letter</span> has not
been seen before by checking that <span class=Literal>letter</span> does not exist
as a key in the <span class=Literal>letterNums</span> dictionary. (On the first
iteration of the loop, the condition on line 20 will always be <span
class=Literal>True</span> because <span class=Literal>letterNums</span> will be
a blank dictionary that doesn’t have anything in it.)</p>

<p class=MsoNormal>If we have not seen this letter before, line 21 adds this
letter as the key and the string form of <span class=Literal>nextNum</span> as
the key’s value to the <span class=Literal>letterNums</span> dictionary. For
the next new letter we find we want to use the next integer after the one
currently in <span class=Literal>nextNum</span> anymore, so line 22 increments
the integer in <span class=Literal>nextNum</span> by <span class=Literal>1</span>.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>makeWordPatterns.py </p>

<p class=SourceCodeFeatured><span class=SourceLineNumber>23.</span>         wordPattern.append(letterNums[letter])</p>

</div>

<p class=MsoNormal>On line 23, <span class=Literal>letterNums[letter]</span> evaluates
to the integer used for the letter in the <span class=Literal>letter</span>
variable, so this is appended to the end of <span class=Literal>wordPattern</span>.
The <span class=Literal>letterNums</span> dictionary is guaranteed to have <span
class=Literal>letter</span> for a key, because if it hadn’t, then lines 20 to
22 would have handled adding it to <span class=Literal>letterNums</span> before
line 23.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>makeWordPatterns.py </p>

<p class=SourceCodeFeatured><span class=SourceLineNumber>24.</span>     return
'.'.join(wordPattern)</p>

</div>

<p class=MsoNormal>After the <span class=Literal>for</span> loop on line 19 is
finished looping, the <span class=Literal>wordPattern</span> list will contain
all the strings of the complete word pattern. Our word patterns have periods
separating the integers, so that we could tell the difference between “1.12”
and “11.2”. To put these periods in between each of the strings in the <span
class=Literal>wordPattern</span> list, line 24 calls the <span class=Literal>join()</span>
method on the string <span class=Literal>'.'</span>. This will evaluate to a
string such as <span class=Literal>'0.1.2.2.3.3.4'</span>. The completely-built
string that <span class=Literal>join()</span> returns will be the return value
of <span class=Literal>getWordPattern()</span>.</p>

<h2><a name="_Toc353630861">The Word Pattern Program’s </a><span class=Literal>main()</span>
Function</h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>makeWordPatterns.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>27.</span>
def main():</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>28.</span>    
allPatterns = {}</p>

</div>

<p class=MsoNormal>The value stored in <span class=Literal>allPatterns</span>
is what we will write to the <span class=Filename>wordPatterns.py</span> file.
It is a dictionary whose keys are strings of word patterns (such as <span
class=Literal>'0.1.2.3.0.4.5'</span> or <span class=Literal>'0.1.1.2'</span>)
and the keys’ values are a list of strings of English words that match that
pattern. For example, here’s one of the key-value pairs that will end up in <span
class=Literal>allPatterns</span>:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerpt style='border:none;padding:0in'>'0.1.0.2.3.1.4':
['DEDUCER', 'DEDUCES', 'GIGABIT', 'RARITAN']</p>

</div>

<p class=MsoNormal>But at the beginning of the <span class=Literal>main()</span>
function on line 28, the <span class=Literal>allPatterns</span> variable will
start off as a blank dictionary value.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>makeWordPatterns.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>30.</span>    
fo = open('dictionary.txt')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>31.</span>    
wordList = fo.read().split('\n')</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>32.</span>    
fo.close()</p>

</div>

<p class=MsoNormal>Lines 30 to 32 read in the contents of the dictionary file into
<span class=Literal>wordList</span>. Chapter 11 covered these file-related
functions in more detail. Line 30 opens the <span class=Filename>dictionary.txt</span>
file in “reading” mode and returns a file object. Line 31 calls the file
object’s <span class=Literal>read()</span> method which returns a string of all
text from this file. The rest of line 31 splits it up whenever there is a <span
class=Literal>\n</span> newline character, and returns a list of strings: one
string per line in the file. This list value returned from <span class=Literal>split()</span>
is stored in the <span class=Literal>wordList</span> variable. At this point we
are done reading the file, so line 34 calls the file object’s <span
class=Literal>close()</span> method.</p>

<p class=MsoNormal>The <span class=Literal>wordList</span> variable will contain
a list of tens of thousands of strings. Since the <span class=Filename>dictionary.txt</span>
file has one English word per line of text, each string in the <span
class=Literal>wordList</span> variable will be one English word.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>makeWordPatterns.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>34.</span>    
for word in wordList:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>35.</span>        
<span class=SourceCodeComment># Get the pattern for each string in wordList.</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>36.</span>        
pattern = getWordPattern(word)</p>

</div>

<p class=MsoNormal>The <span class=Literal>for</span> loop on line 34 will
iterate over each string in the <span class=Literal>wordList</span> list and
store it in the <span class=Literal>word</span> variable. The <span
class=Literal>word</span> variable is passed to the <span class=Literal>getWordPattern()</span>
function, which  returns a word pattern string for the string in <span
class=Literal>word</span>. The word pattern string is stored in a variable
named <span class=Literal>pattern</span>.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>makeWordPatterns.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>38.</span>        
if pattern not in allPatterns:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>39.</span>            
allPatterns[pattern] = [word]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>40.</span>        
else:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>41.</span>            
allPatterns[pattern].append(word)</p>

</div>

<p class=MsoNormal>There must be a value for the <span class=Literal>pattern</span>
key first before we can append <span class=Literal>word</span> to <span
class=Literal>allPatterns[pattern]</span>, otherwise this would cause an error.
So, first line 38 will check if the pattern is not already in <span
class=Literal>allPatterns</span>. If <span class=Literal>pattern</span> is not a
key in <span class=Literal>allPatterns</span> yet, line 39 creates a list with <span
class=Literal>word</span> in it to store in <span class=Literal>allPatterns[pattern]</span>.</p>

<p class=MsoNormal>If the pattern already is in <span class=Literal>allPatterns</span>,
we do not have to create the list. Line 41 will just append the word to the
list value that is already there.</p>

<p class=MsoNormal>By the time the <span class=Literal>for</span> loop that
started on line 34 finishes, the <span class=Literal>allPatterns</span>
dictionary will contain the word pattern of each English word that was in <span
class=Literal>wordList</span> as its keys. Each of these keys has a value that
is a list of the words that produce the word pattern. With our data organized
this way, given a word pattern we can easily look up all the English words that
produce that particular pattern.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>makeWordPatterns.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>43.</span>    
<span class=SourceCodeComment># This is code that writes code. The
wordPatterns.py file contains</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>44.</span>    
<span class=SourceCodeComment># one very, very large assignment statement.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>45.</span>    
fo = open('wordPatterns.py', 'w')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>46.</span>    
fo.write('allPatterns = ')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>47.</span>    
fo.write(pprint.pformat(allPatterns))</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>48.</span>    
fo.close()</p>

</div>

<p class=MsoNormal>Now that we have this very large dictionary in <span
class=Literal>allPatterns</span>, we want to save it to a file on the hard
drive. The last part of the <span class=Literal>main()</span> function will
create a file called <span class=Filename>wordPatterns.py</span> which will
just have one huge assignment statement in it.</p>

<p class=MsoNormal>Line 45 creates a new file by passing the <span
class=Literal>'wordPatterns.py'</span> string for the filename and <span
class=Literal>'w'</span> to indicate that this file will be opened in “write”
mode. If there is already a file with the name <span class=Literal>'wordPatterns.py'</span>,
opening it in write mode will cause the file to be deleted to make way for the
new file we are creating.</p>

<p class=MsoNormal>Line 46 starts the file off with <span class=Literal>'allPatterns
= '</span>, which is the first part of the assignment statement. Line 47
finishes it by writing a prettified version of <span class=Literal>allPatterns</span>
to the file. Line 48 closes the file since we are done writing to it.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>makeWordPatterns.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>51.</span> if
__name__ == '__main__':</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>52.</span>    
main()</p>

</div>

<p class=MsoNormal>Lines 51 and 52 call the <span class=Literal>main()</span>
function if this program was run by itself (to create the <span class=Filename>wordPattern.py</span>
file) rather than imported by another program that wants to use its <span
class=Literal>getWordPattern()</span> function.</p>

<h2><a name="_Toc353630862">Hacking the Simple Substitution Cipher</a></h2>

<p class=MsoNormal>The hacking program uses the abstract concepts of “word
patterns” and “cipherletter mappings”. But don’t worry, in our Python program
“word patterns” are represented by string values and “cipherletter mappings”
are represented with dictionary values. The previous sections explained what
word patterns are and how to generate them from a string. Cipherletter mappings
are used in the hacking program to keep track of the possible letters that each
of the 26 cipherletters could decrypt to. Go ahead and type in the source code
for the <span class=Filename>simpleSubHacker.py</span> program.</p>

<h2><a name="_Toc353630863">Source Code of the Simple Substitution Hacking
Program</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst align=right style='text-align:right'><span
class=SourceCodeFilename><span style='font-size:13.0pt;line-height:115%'>Source
code for simpleSubHacker.py </span></span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  1.</span> <span
class=SourceCodeComment># Simple Substitution Cipher Hacker</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  2.</span> <span
class=SourceCodeComment># http://inventwithpython.com/hacking (BSD Licensed)</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  3. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  4.</span>
import os, re, copy, pprint, pyperclip, simpleSubCipher, makeWordPatterns</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  5. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  6.</span>
if not os.path.exists('wordPatterns.py'):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  7.</span>    
makeWordPatterns.main() <span class=SourceCodeComment># create the
wordPatterns.py file</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  8.</span>
import wordPatterns</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  9. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 10.</span>
LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 11.</span>
nonLettersOrSpacePattern = re.compile('[^A-Z\s]')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 12. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 13.</span>
def main():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 14.</span>    
message = 'Sy l nlx sr pyyacao l ylwj eiswi upar lulsxrj isr sxrjsxwjr, ia esmm
rwctjsxsza sj wmpramh, lxo txmarr jia aqsoaxwa sr pqaceiamnsxu, ia esmm caytra
jp famsaqa sj. Sy, px jia pjiac ilxo, ia sr pyyacao rpnajisxu eiswi lyypcor l
calrpx ypc lwjsxu sx lwwpcolxwa jp isr sxrjsxwjr, ia esmm lwwabj sj aqax px jia
rmsuijarj aqsoaxwa. Jia pcsusx py nhjir sr agbmlsxao sx jisr elh. -Facjclxo
Ctrramm'</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 15. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 16.</span>    
<span class=SourceCodeComment># Determine the possible valid ciphertext
translations.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 17.</span>    
print('Hacking...')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 18.</span>    
letterMapping = hackSimpleSub(message)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 19. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 20.</span>    
<span class=SourceCodeComment># Display the results to the user.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 21.</span>    
print('Mapping:')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 22.</span>    
pprint.pprint(letterMapping)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 23.</span>    
print()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 24.</span>    
print('Original ciphertext:')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 25.</span>    
print(message)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 26.</span>    
print()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 27.</span>    
print('Copying hacked message to clipboard:')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 28.</span>    
hackedMessage = decryptWithCipherletterMapping(message, letterMapping)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 29.</span>    
pyperclip.copy(hackedMessage)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 30.</span>    
print(hackedMessage)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 31. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 32. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 33.</span>
def getBlankCipherletterMapping():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 34.</span>    
<span class=SourceCodeComment># Returns a dictionary value that is a blank
cipherletter mapping.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 35.</span>    
return {'A': [], 'B': [], 'C': [], 'D': [], 'E': [], 'F': [], 'G': [], 'H': [],
'I': [], 'J': [], 'K': [], 'L': [], 'M': [], 'N': [], 'O': [], 'P': [], 'Q':
[], 'R': [], 'S': [], 'T': [], 'U': [], 'V': [], 'W': [], 'X': [], 'Y': [],
'Z': []}</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 36. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 37. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 38.</span>
def addLettersToMapping(letterMapping, cipherword, candidate):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 39.</span>    
<span class=SourceCodeComment># The letterMapping parameter is a &quot;cipherletter
mapping&quot; dictionary</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 40.</span>    
<span class=SourceCodeComment># value that the return value of this function starts
as a copy of.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 41.</span>    
<span class=SourceCodeComment># The cipherword parameter is a string value of
the ciphertext word.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 42.</span>    
<span class=SourceCodeComment># The candidate parameter is a possible English
word that the</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 43.</span>    
<span class=SourceCodeComment># cipherword could decrypt to.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 44. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 45.</span>    
<span class=SourceCodeComment># This function adds the letters of the candidate
as potential</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 46.</span>    
<span class=SourceCodeComment># decryption letters for the cipherletters in the
cipherletter</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 47.</span>    
<span class=SourceCodeComment># mapping.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 48. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 49.</span>    
letterMapping = copy.deepcopy(letterMapping)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 50.</span>    
for i in range(len(cipherword)):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 51.</span>        
if candidate[i] not in letterMapping[cipherword[i]]:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 52.</span>            
letterMapping[cipherword[i]].append(candidate[i])</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 53.</span>    
return letterMapping</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 54. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 55. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 56.</span>
def intersectMappings(mapA, mapB):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 57.</span>    
<span class=SourceCodeComment># To intersect two maps, create a blank map, and
then add only the</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 58.</span>    
<span class=SourceCodeComment># potential decryption letters if they exist in
BOTH maps.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 59.</span>    
intersectedMapping = getBlankCipherletterMapping()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 60.</span>    
for letter in LETTERS:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 61. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 62.</span>        
<span class=SourceCodeComment># An empty list means &quot;any letter is
possible&quot;. In this case just</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 63.</span>        
<span class=SourceCodeComment># copy the other map entirely.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 64.</span>        
if mapA[letter] == []:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 65.</span>            
intersectedMapping[letter] = copy.deepcopy(mapB[letter])</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 66.</span>        
elif mapB[letter] == []:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 67.</span>            
intersectedMapping[letter] = copy.deepcopy(mapA[letter])</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 68.</span>        
else:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 69.</span>            
<span class=SourceCodeComment># If a letter in mapA[letter] exists in
mapB[letter], add</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 70.</span>            
<span class=SourceCodeComment># that letter to intersectedMapping[letter].</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 71.</span>            
for mappedLetter in mapA[letter]:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 72.</span>                
if mappedLetter in mapB[letter]:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 73.</span>                    
intersectedMapping[letter].append(mappedLetter)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 74. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 75.</span>    
return intersectedMapping</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 76. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 77. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 78.</span>
def removeSolvedLettersFromMapping(letterMapping):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 79.</span>    
<span class=SourceCodeComment># Cipher letters in the mapping that map to only
one letter are</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 80.</span>    
<span class=SourceCodeComment># &quot;solved&quot; and can be removed from the
other letters.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 81.</span>    
<span class=SourceCodeComment># For example, if 'A' maps to potential letters
['M', 'N'], and 'B'</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 82.</span>    
<span class=SourceCodeComment># maps to ['N'], then we know that 'B' must map
to 'N', so we can</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 83.</span>    
<span class=SourceCodeComment># remove 'N' from the list of what 'A' could map
to. So 'A' then maps</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 84.</span>    
<span class=SourceCodeComment># to ['M']. Note that now that 'A' maps to only
one letter, we can</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 85.</span>    
<span class=SourceCodeComment># remove 'M' from the list of letters for every
other</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 86.</span>    
<span class=SourceCodeComment># letter. (This is why there is a loop that keeps
reducing the map.)</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 87.</span>    
letterMapping = copy.deepcopy(letterMapping)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 88.</span>    
loopAgain = True</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 89.</span>    
while loopAgain:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 90.</span>        
<span class=SourceCodeComment># First assume that we will not loop again:</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 91.</span>        
loopAgain = False</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 92. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 93.</span>        
<span class=SourceCodeComment># solvedLetters will be a list of uppercase
letters that have one</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 94.</span>        
<span class=SourceCodeComment># and only one possible mapping in letterMapping</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 95.</span>        
solvedLetters = []</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 96.</span>        
for cipherletter in LETTERS:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 97.</span>            
if len(letterMapping[cipherletter]) == 1:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 98.</span>                
solvedLetters.append(letterMapping[cipherletter][0])</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 99. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>100.</span>        
<span class=SourceCodeComment># If a letter is solved, than it cannot possibly
be a potential</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>101.</span>        
<span class=SourceCodeComment># decryption letter for a different ciphertext
letter, so we</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>102.</span>        
<span class=SourceCodeComment># should remove it from those other lists.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>103.</span>        
for cipherletter in LETTERS:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>104.</span>            
for s in solvedLetters:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>105.</span>                
if len(letterMapping[cipherletter]) != 1 and s in letterMapping[cipherletter]:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>106.</span>                    
letterMapping[cipherletter].remove(s)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>107.</span>                    
if len(letterMapping[cipherletter]) == 1:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>108.</span>                        
<span class=SourceCodeComment># A new letter is now solved, so loop again.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>109.</span>                        
loopAgain = True</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>110.</span>    
return letterMapping</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>111. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>112. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>113.</span>
def hackSimpleSub(message):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>114.</span>    
intersectedMap = getBlankCipherletterMapping()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>115.</span>    
cipherwordList = nonLettersOrSpacePattern.sub('', message.upper()).split()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>116.</span>    
for cipherword in cipherwordList:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>117.</span>        
<span class=SourceCodeComment># Get a new cipherletter mapping for each
ciphertext word.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>118.</span>        
newMap = getBlankCipherletterMapping()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>119. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>120.</span>        
wordPattern = makeWordPatterns.getWordPattern(cipherword)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>121.</span>        
if wordPattern not in wordPatterns.allPatterns:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>122.</span>            
continue <span class=SourceCodeComment># This word was not in our dictionary,
so continue.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>123. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>124.</span>        
<span class=SourceCodeComment># Add the letters of each candidate to the
mapping.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>125.</span>        
for candidate in wordPatterns.allPatterns[wordPattern]:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>126.</span>            
newMap = addLettersToMapping(newMap, cipherword, candidate)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>127. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>128.</span>        
<span class=SourceCodeComment># Intersect the new mapping with the existing
intersected mapping.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>129.</span>        
intersectedMap = intersectMappings(intersectedMap, newMap)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>130. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>131.</span>    
<span class=SourceCodeComment># Remove any solved letters from the other lists.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>132.</span>    
return removeSolvedLettersFromMapping(intersectedMap)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>133. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>134. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>135.</span>
def decryptWithCipherletterMapping(ciphertext, letterMapping):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>136.</span>    
<span class=SourceCodeComment># Return a string of the ciphertext decrypted
with the letter mapping,</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>137.</span>    
<span class=SourceCodeComment># with any ambiguous decrypted letters replaced
with an _ underscore.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>138. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>139.</span>    
<span class=SourceCodeComment># First create a simple sub key from the
letterMapping mapping.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>140.</span>    
key = ['x'] * len(LETTERS)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>141.</span>    
for cipherletter in LETTERS:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>142.</span>        
if len(letterMapping[cipherletter]) == 1:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>143.</span>            
<span class=SourceCodeComment># If there's only one letter, add it to the key.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>144.</span>            
keyIndex = LETTERS.find(letterMapping[cipherletter][0])</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>145.</span>            
key[keyIndex] = cipherletter</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>146.</span>        
else:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>147.</span>            
ciphertext = ciphertext.replace(cipherletter.lower(), '_')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>148.</span>            
ciphertext = ciphertext.replace(cipherletter.upper(), '_')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>149.</span>    
key = ''.join(key)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>150. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>151.</span>    
<span class=SourceCodeComment># With the key we've created, decrypt the ciphertext.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>152.</span>    
return simpleSubCipher.decryptMessage(key, ciphertext)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>153. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>154. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>155.</span>
if __name__ == '__main__':</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>156.</span>    
main()</p>

</div>

<h2><a name="_Toc353630864">Hacking the Simple Substitution Cipher (in Theory)</a></h2>

<p class=MsoNormal>Hacking the simple substitution cipher is pretty easy. The
five steps are:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-.25in'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Find
the word pattern for each cipherword in the ciphertext.</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Find
the list of English word candidates that each cipherword could decrypt to.</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Create
one cipherletter mapping for each cipherword using the cipherword’s list of
candidates. (A cipherletter mapping is just a dictionary value.)</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'>4.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Intersect
each of the cipherletter mappings into a single intersected cipherletter
mapping.</p>

<p class=MsoListParagraphCxSpLast style='text-indent:-.25in'>5.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Remove
any solved letters from the intersected cipherletter mapping.</p>

<p class=MsoNormal>The more cipher words that are in the ciphertext, the more
cipherletter mappings we have that can be intersected. The more cipherletter
mappings we intersect together, the fewer the number of potential decryption
letters there will be for each cipher letter. This means that <strong>the
longer the ciphertext message, the more likely we are to hack and decrypt it</strong>.</p>

<h2><a name="_Toc353630865">Explore the Hacking Functions with the Interactive
Shell</a></h2>

<p class=MsoNormal>We’ve already described the steps used to hack a simple
substitution encrypted message by using word patterns. Before we learn how the
code in these functions works, let’s use the interactive shell to call them and
see what values they return depending on what arguments we pass them.</p>

<p class=MsoNormal>Here is the example we will hack: OLQIHXIRCKGNZ  PLQRZKBZB  MPBKSSIPLC</p>

<p class=MsoNormal>The <span class=Literal>getBlankCipherletterMapping()</span>
function returns a cipherletter mapping. <strong>A cipherletter mapping is just
a dictionary with 26 keys of uppercase single-letter strings and values of
lists of single-letter uppercase strings like 'A' or 'Q'.</strong> We will
store this blank cipherletter mapping in a variable named <span class=Literal>letterMapping1</span>.
Try typing the following into the interactive shell:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
letterMapping1 = simpleSubHacker.getBlankCipherletterMapping()</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
letterMapping1</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>{'A': [],
'C': [], 'B': [], 'E': [], 'D': [], 'G': [], 'F': [], 'I': [], 'H': [], 'K':
[], 'J': [], 'M': [], 'L': [], 'O': [], 'N': [], 'Q': [], 'P': [], 'S': [],
'R': [], 'U': [], 'T': [], 'W': [], 'V': [], 'Y': [], 'X': [], 'Z': []}</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>Let’s start hacking the first cipherword, OLQIHXIRCKGNZ.
First we will need to get the word pattern for this cipherword by calling the <span
class=Literal>makeWordPattern</span> module’s <span class=Literal>getWordPattern()</span>
function. Try typing the following into the interactive shell:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
import makeWordPatterns</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
wordPat = makeWordPatterns.getWordPattern('OLQIHXIRCKGNZ')</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
wordPat</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>0.1.2.3.4.5.3.6.7.8.9.10.11</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>To figure out which English words in the dictionary have the
word pattern 0.1.2.3.4.5.3.6.7.8.9.10.11 (that is, to figure out the candidates
for the cipherword OLQIHXIRCKGNZ) we will import the <span class=Literal>wordPatterns</span>
module and look up this pattern. Try typing the following into the interactive
shell:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
import wordPatterns</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
candidates = wordPatterns.allPatterns['0.1.2.3.4.5.3.6.7.8.9.10.11']</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
candidates</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>['UNCOMFORTABLE',
'UNCOMFORTABLY']</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>There are two English words that OLQIHXIRCKGNZ could decrypt
to (that is, only two English words that have the same word pattern that
OLQIHXIRCKGNZ does): UNCOMFORTABLE and UNCOMFORTABLY. (It’s also possible that
the cipherword decrypts to a word that does not exist in our dictionary, but we
will just have to assume that’s not the case.) We need to create a cipherletter
mapping that has the cipherletters in OLQIHXIRCKGNZ map to letters in
UNCOMFORTABLE and UNCOMFORTABLY as potential decryption letters. That is, O
maps to U, L maps to N, Q maps to C, and so on. Z will map to two different
letters: E and Y.</p>

<p class=MsoNormal>We can do this with the <span class=Literal>addLettersToMapping()</span>
function. We will need to pass it our (currently blank) cipherletter mapping in
<span class=Literal>letterMapping1</span>, the string <span class=Literal>'OLQIHXIRCKGNZ'</span>,
and the string <span class=Literal>'UNCOMFORTABLE'</span> (which is the first
string in the <span class=Literal>candidates</span> list). Try typing the
following into the interactive shell:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
letterMapping1 = simpleSubHacker.addLettersToMapping(letterMapping1,
'OLQIHXIRCKGNZ', candidates[0])</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
letterMapping1</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>{'A': [],
'C': ['T'], 'B': [], 'E': [], 'D': [], 'G': ['B'], 'F': [], 'I': ['O'], 'H':
['M'], 'K': ['A'], 'J': [], 'M': [], 'L': ['N'], 'O': ['U'], 'N': ['L'], 'Q':
['C'], 'P': [], 'S': [], 'R': ['R'], 'U': [], 'T': [], 'W': [], 'V': [], 'Y':
[], 'X': ['F'], 'Z': ['E']}</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>From the <span class=Literal>letterMapping1</span> value,
you can see that the letters in OLQIHXIRCKGNZ map to the letters in
UNCOMFORTABLE: <span class=Literal>'O'</span> maps to <span class=Literal>['U']</span>,
<span class=Literal>'L'</span> maps to <span class=Literal>['N']</span>, <span
class=Literal>'Q'</span> maps to <span class=Literal>['C']</span>, and so on.</p>

<p class=MsoNormal>But since the letters in OLQIHXIRCKGNZ could also possibly
decrypt to UNCOMFORTABLY, we also need to add UNCOMFORTABLY to the cipherletter
mapping. Try typing the following into the interactive shell:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
letterMapping1 = simpleSubHacker.addLettersToMapping(letterMapping1,
'OLQIHXIRCKGNZ', candidates[1])</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
letterMapping1</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>{'A': [],
'C': ['T'], 'B': [], 'E': [], 'D': [], 'G': ['B'], 'F': [], 'I': ['O'], 'H':
['M'], 'K': ['A'], 'J': [], 'M': [], 'L': ['N'], 'O': ['U'], 'N': ['L'], 'Q':
['C'], 'P': [], 'S': [], 'R': ['R'], 'U': [], 'T': [], 'W': [], 'V': [], 'Y':
[], 'X': ['F'], 'Z': ['E', 'Y']}</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>You’ll notice that not much has changed in <span
class=Literal>letterMapping1</span>. The cipherletter mapping in <span
class=Literal>letterMapping1</span> now has <span class=Literal>'Z'</span> map
to both <span class=Literal>'E'</span> and <span class=Literal>'Y'</span>. That’s
because the candidates for OLQIHXIRCKGNZ (that is, UNCOMFORTABLE and
UNCOMFORTABLY) are very similar to each other and <span class=Literal>addLettersToMapping()</span>
only adds the letter to the list if the letter is not already there. This is
why <span class=Literal>'O'</span> maps to <span class=Literal>['U']</span>
instead of <span class=Literal>['U',</span> <span class=Literal>'U']</span>.</p>

<p class=MsoNormal>We now have a cipherletter mapping for the first of the
three cipherwords. We need to get a new mapping for the second cipherword, PLQRZKBZB.
Call <span class=Literal>getBlankCipherletterMapping()</span> and store the
returned dictionary value in a variable named <span class=Literal>letterMapping2</span>.
Get the word pattern for PLQRZKBZB and use it to look up all the candidates in <span
class=Literal>wordPatterns.allPatterns</span>. This is done by typing the
following into the interactive shell:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
letterMapping2 = simpleSubHacker.getBlankCipherletterMapping()</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
wordPat = makeWordPatterns.getWordPattern('PLQRZKBZB')</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
candidates = wordPatterns.allPatterns[wordPat]</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
candidates</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>['CONVERSES',
'INCREASES', 'PORTENDED', 'UNIVERSES']</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>Instead of typing out four calls to <span class=Literal>addLettersToMapping()</span>
for each of these four candidate words, we can write a <span class=Literal>for</span>
loop that will go through the list in <span class=Literal>candidates</span> and
call <span class=Literal>addLettersToMapping()</span> each time.</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
for candidate in candidates:</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>...  
letterMapping2 = simpleSubHacker.addLettersToMapping(letterMapping2,
'PLQRZKBZB', candidate)</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>...</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
letterMapping2</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>{'A': [],
'C': [], 'B': ['S', 'D'], 'E': [], 'D': [], 'G': [], 'F': [], 'I': [], 'H': [],
'K': ['R', 'A', 'N'], 'J': [], 'M': [], 'L': ['O', 'N'], 'O': [], 'N': [], 'Q':
['N', 'C', 'R', 'I'], 'P': ['C', 'I', 'P', 'U'], 'S': [], 'R': ['V', 'R', 'T'],
'U': [], 'T': [], 'W': [], 'V': [], 'Y': [], 'X': [], 'Z': ['E']}</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>This finishes the cipherletter mapping for our second
cipherword. Now we need to get the intersection of the cipherletter mappings in
<span class=Literal>letterMapping1</span> and <span class=Literal>letterMapping2</span>
by passing them to <span class=Literal>intersectMappings()</span>. Try typing
the following into the interactive shell:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
intersectedMapping = simpleSubHacker.intersectMappings(letterMapping1,
letterMapping2)</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
intersectedMapping</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>{'A': [],
'C': ['T'], 'B': ['S', 'D'], 'E': [], 'D': [], 'G': ['B'], 'F': [], 'I': ['O'],
'H': ['M'], 'K': ['A'], 'J': [], 'M': [], 'L': ['N'], 'O': ['U'], 'N': ['L'],
'Q': ['C'], 'P': ['C', 'I', 'P', 'U'], 'S': [], 'R': ['R'], 'U': [], 'T': [],
'W': [], 'V': [], 'Y': [], 'X': ['F'], 'Z': ['E']}</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>The intersected mapping is just a cipherletter mapping. The
list of potential decryption letters for any cipherletter in the intersected
mapping will only be the potential decryption letters that were in the
cipherletter’s list in <strong>both</strong> <span class=Literal>letterMapping1</span>
and <span class=Literal>letterMapping2</span>.</p>

<p class=MsoNormal>For example, this is why <span class=Literal>intersectedMapping</span>’s
list for the <span class=Literal>'Z'</span> key is just <span class=Literal>['E']</span>:
because <span class=Literal>letterMapping1</span> had <span class=Literal>['E',</span>
<span class=Literal>'Y']</span> but <span class=Literal>letterMapping2</span>
had <span class=Literal>['E']</span>. The intersection of <span class=Literal>['E',</span>
<span class=Literal>'Y']</span> and <span class=Literal>['E']</span> is just
the potential decryption letters that exist in <strong>both</strong> mappings: <span
class=Literal>['E']</span></p>

<p class=MsoNormal>There is an exception. If one of the mapping’s lists was <em>blank</em>,
then <em>all</em> of the potential decryption letters in the <em>other</em>
mapping are put into the intersected mapping. This is because in our program a
blank map represents any possible letter can be used since nothing is known
about the mapping.</p>

<p class=MsoNormal>Then we do all these steps for the third cipherword, MPBKSSIPLC.
Try typing the following into the interactive shell:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
letterMapping3 = simpleSubHacker.getBlankCipherletterMapping()</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
wordPat = makeWordPatterns.getWordPattern('MPBKSSIPLC')</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
candidates = wordPatterns.allPatterns[wordPat]</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
candidates</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>['ADMITTEDLY',
'DISAPPOINT']</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
for i in range(len(candidates)):</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>...  
letterMapping3 = simpleSubHacker.addLettersToMapping(letterMapping3,
'MPBKSSIPLC', candidates[i])</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>...</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
letterMapping3</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>{'A': [],
'C': ['Y', 'T'], 'B': ['M', 'S'], 'E': [], 'D': [], 'G': [], 'F': [], 'I':
['E', 'O'], 'H': [], 'K': ['I', 'A'], 'J': [], 'M': ['A', 'D'], 'L': ['L',
'N'], 'O': [], 'N': [], 'Q': [], 'P': ['D', 'I'], 'S': ['T', 'P'], 'R': [],
'U': [], 'T': [], 'W': [], 'V': [], 'Y': [], 'X': [], 'Z': []}</p>

</div>

<p class=MsoNormal>We intersect <span class=Literal>letterMapping3</span> with <span
class=Literal>intersectedMapping</span>. This also ends up indirectly
intersecting <span class=Literal>letterMapping3</span> with <span
class=Literal>letterMapping1</span> and <span class=Literal>letterMapping2</span>,
since <span class=Literal>intersectedMapping</span> is currently the
intersection of <span class=Literal>letterMapping1</span> and <span
class=Literal>letterMapping2</span>. Try typing the following into the
interactive shell:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
intersectedMapping = simpleSubHacker.intersectMappings(intersectedMapping,
letterMapping3)</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
intersectedMapping</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>{'A': [],
'C': ['T'], 'B': ['S'], 'E': [], 'D': [], 'G': ['B'], 'F': [], 'I': ['O'], 'H':
['M'], 'K': ['A'], 'J': [], 'M': ['A', 'D'], 'L': ['N'], 'O': ['U'], 'N':
['L'], 'Q': ['C'], 'P': ['I'], 'S': ['T', 'P'], 'R': ['R'], 'U': [], 'T': [],
'W': [], 'V': [], 'Y': [], 'X': ['F'], 'Z': ['E']}</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>We can now pass the intersected cipherletter mapping to <span
class=Literal>decryptWithCipherletterMapping()</span> to decrypt the
ciphertext. Try typing the following into the interactive shell: </p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
simpleSubHacker.decryptWithCipherletterMapping('OLQIHXIRCKGNZ PLQRZKBZB
MPBKSSIPLC', intersectedMapping)</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>UNCOMFORTABLE
INCREASES _ISA__OINT</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>The intersected mapping is not yet complete. Notice how the
intersected mapping has a solution for the cipherletter K, because the key <span
class=Literal>'K'</span>’s value to a list with just one string in it: <span
class=Literal>['A']</span>. Because we know that the K cipherletters will
decrypt to A, no other cipherletter can possibly decrypt to A.</p>

<p class=MsoNormal>In the intersected mapping, the cipherletter M maps to <span
class=Literal>['A',</span> <span class=Literal>'D']</span>. This means that
judging from the candidates for the cipherwords in our encrypted message, the
cipherletter M could decrypt to A or D. </p>

<p class=MsoNormal>But since we know K decrypts to A, we can remove A from the
list of potential decryption letters for cipherletter M. This shortens the list
down to just <span class=Literal>['D']</span>. Because this new list only has
one string in it, we’ve also solved the cipherletter M!</p>

<p class=MsoNormal>The <span class=Literal>removeSolvedLettersFromMapping()</span>
function takes a cipherletter mapping and removes these solved potential
decryption letters from the other cipherletters’ lists. Try typing the
following into the interactive shell:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
letterMapping = simpleSubHacker.removeSolvedLettersFromMapping(letterMapping)</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
intersectedMapping</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>{'A': [],
'C': ['T'], 'B': ['S'], 'E': [], 'D': [], 'G': ['B'], 'F': [], 'I': ['O'], 'H':
['M'], 'K': ['A'], 'J': [], 'M</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>': ['D'],
'L': ['N'], 'O': ['U'], 'N': ['L'], 'Q': ['C'], 'P': ['I'], 'S': ['P'], 'R':
['R'], 'U': [], 'T': [], 'W': [],</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'> 'V': [],
'Y': [], 'X': ['F'], 'Z': ['E']}</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>Now when we pass the intersected mapping to <span
class=Literal>decryptWithCipherletterMapping()</span>, it gives us the full
solution. Try typing the following into the interactive shell:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
simpleSubHacker.decryptWithCipherletterMapping('OLQIHXIRCKGNZ PLQRZKBZB
MPBKSSIPLC', intersectedMapping)</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>UNCOMFORTABLE
INCREASES DISAPPOINT</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>The ciphertext OLQIHXIRCKGNZ PLQRZKBZB MPBKSSIPLC decrypts
to the message, “Uncomfortable increases disappoint”.</p>

<p class=MsoNormal>This is a rather short ciphertext to hack. Normally the
encrypted messages we hack will be much longer. (Messages as short as our
example usually cannot be hacked with our word pattern method.) We’ll have to
create a cipherletter mapping for each cipherword in these longer messages and
then intersect them all together, which is exactly what the <span
class=Literal>hackSimpleSub()</span> function does.</p>

<p class=MsoNormal>Now that we know the basic steps and what each function
does, let’s learn how the code in these functions work.</p>

<h2><a name="_Toc353630866">How the Program Works</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>  1.</span> <span
class=SourceCodeComment># Simple Substitution Cipher Hacker</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>  2.</span> <span
class=SourceCodeComment># http://inventwithpython.com/hacking (BSD Licensed)</span></p>

</div>

<p class=MsoNormal>The comments at the top of the source code explain what the
program is.</p>

<h2><a name="_Toc353630867">Import All the Things</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeatured><span class=SourceLineNumber>  4.</span> import os,
re, copy, pprint, pyperclip, simpleSubCipher, makeWordPatterns</p>

</div>

<p class=MsoNormal>Our simple substitution hacking program imports eight
different modules, more than any other program so far. By reusing the code in
these modules, our hacking program becomes much shorter and easier to write.</p>

<p class=MsoNormal>The <span class=Literal>re</span> module is a module we
haven’t seen before. This is the regular expression module which lets our code
do sophisticated string manipulation. Regular expressions are explained in the
next section.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>  6.</span>
if not os.path.exists('wordPatterns.py'):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  7.</span>    
makeWordPatterns.main() <span class=SourceCodeComment># create the
wordPatterns.py file</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>  8.</span>
import wordPatterns</p>

</div>

<p class=MsoNormal>The simple substitution cipher also needs the <span
class=Literal>wordPatterns</span> module. The .py file for this module is
created when the <span class=Literal>makeWordPatterns.py</span> program is run.
But <span class=Filename>makeWordPatterns.py</span> might not have been run
before our hacking program has. In this case, our hacking program checks if
this file exists on line 6 and if it doesn’t, the <span class=Literal>makeWordPatterns.main()</span>
function is called.</p>

<p class=MsoNormal>Remember, the <span class=Literal>main()</span> function is
the function that is run in our programs when they are run as programs (rather
than just imported with an <span class=Literal>import</span> statement.) When
we imported the <span class=Literal>makeWordPatterns</span> module on line 4,
the <span class=Literal>main()</span> function in <span class=Filename>makeWordPatterns.py</span>
was not run. Since <span class=Literal>main()</span> is the function that
creates the <span class=Filename>wordPatterns.py</span> file, we will call <span
class=Literal>makeWordPatterns.main()</span> if <span class=Filename>wordPatterns.py</span>
does not yet exist.</p>

<p class=MsoNormal>Either way, by the time the program execution reaches line
8, the <span class=Literal>wordPatterns</span> module will exist and can be
imported.</p>

<h2><a name="_Toc353630868">A Brief Intro to Regular Expressions and the sub()
Regex Method</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 10.</span>
LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 11.</span>
nonLettersOrSpacePattern = re.compile('[^A-Z\s]')</p>

</div>

<p class=MsoNormal>The simple substitution hacking program will have a <span
class=Literal>LETTERS</span> global variable like many of our previous cipher
programs.</p>

<p class=MsoNormal>The <span class=Literal>re.compile()</span> function is new.
This function compiles (that is, creates) a new regular expression pattern
object, or “regex object” or “pattern object” for short. Regular expressions are
strings that define a specific pattern that matches certain strings. Regular
expressions can do many special things with strings that are beyond the scope
of this book, but you can learn about them at <span class=URL><u>http://invpy.com/regex</u></span>.</p>

<p class=MsoNormal>The string <span class=Literal>'[^A-Za-z\s]'</span> is a
regular expression that matches any character that is not a letter from A to Z or
a “whitespace” character (e.g. a space, tab, or newline character). The pattern
object has a <span class=Literal>sub()</span> method (short for “substitute”) that
works very similar to the <span class=Literal>replace()</span> string method.
The first argument to <span class=Literal>sub()</span> is the string that
replaces any instances of the pattern in the second string argument. Try typing
the following into the interactive shell:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
pat = re.compile('[^A-Z\s]')</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
pat.sub('abc', 'ALL! NON!LETTERS? AND123 NONSPACES. REPLACED')</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>'ALLabc
NONabcLETTERSabc ANDabcabcabc NONSPACESabc REPLACED'</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
pat.sub('', 'ALL! NON!LETTERS? AND123 NONSPACES. REPLACED')</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>'ALL NONLETTERS
AND NONSPACES REPLACED' </p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>&gt;&gt;&gt;&nbsp;</p>

</div>

<p class=MsoNormal>There are many sophisticated string manipulations you can
perform if you learn more about regular expressions, but we will only use them
in this book to remove characters from a string that are not uppercase letters
or spaces.</p>

<h2><a name="_Toc353630869">The Hacking Program’s </a><span class=Literal>main()</span>
Function</h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 13.</span>
def main():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 14.</span>    
message = 'Sy l nlx sr pyyacao l ylwj eiswi upar lulsxrj isr sxrjsxwjr, ia esmm
rwctjsxsza sj wmpramh, lxo txmarr jia aqsoaxwa sr pqaceiamnsxu, ia esmm caytra
jp famsaqa sj. Sy, px jia pjiac ilxo, ia sr pyyacao rpnajisxu eiswi lyypcor l
calrpx ypc lwjsxu sx lwwpcolxwa jp isr sxrjsxwjr, ia esmm lwwabj sj aqax px jia
rmsuijarj aqsoaxwa. Jia pcsusx py nhjir sr agbmlsxao sx jisr elh. -Facjclxo
Ctrramm'</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 15. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 16.</span>    
<span class=SourceCodeComment># Determine the possible valid ciphertext
translations.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 17.</span>    
print('Hacking...')</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 18.</span>    
letterMapping = hackSimpleSub(message)</p>

</div>

<p class=MsoNormal>Like all our previous hacking programs, the <span
class=Literal>main()</span> function will store the ciphertext to be hacked in
a variable named <span class=Literal>message</span>. We will pass this variable
to the <span class=Literal>hackSimpleSub()</span> function. However, unlike our
previous hacking programs, the hacking function will not return a string of the
decrypted message (or <span class=Literal>None</span> if it was unable to
decrypt it).</p>

<p class=MsoNormal>Instead, <span class=Literal>hackSimpleSub()</span> will
return a cipherletter mapping (specifically, an intersected cipherletter
mapping that had the solved letters removed, like the kind we made in our
interactive shell exercise). This returned cipherletter mapping will be passed
to <span class=Literal>decryptWithCipherletterMapping()</span> to decrypt the
ciphertext in <span class=Literal>message</span>.</p>

<h2><a name="_Toc353630870">Partially Hacking the Cipher</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 20.</span>    
<span class=SourceCodeComment># Display the results to the user.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 21.</span>    
print('Mapping:')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 22.</span>    
pprint.pprint(letterMapping)</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 23.</span>    
print()</p>

</div>

<p class=MsoNormal>Since the cipherletter mapping stored in <span
class=Literal>letterMapping</span> is a dictionary, we can use the <span
class=Literal>pprint.pprint()</span> “pretty print” function to display it on
the screen. It will look something like this:</p>

<div style='border:solid windowtext 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SampleRunCxSpFirst>{'A': ['E'],</p>

<p class=SampleRunCxSpMiddle> 'B': ['B', 'W', 'P'],</p>

<p class=SampleRunCxSpMiddle> 'C': ['R'],</p>

<p class=SampleRunCxSpMiddle> 'D': [],</p>

<p class=SampleRunCxSpMiddle> 'E': ['K', 'W'],</p>

<p class=SampleRunCxSpMiddle> 'F': ['B', 'P'],</p>

<p class=SampleRunCxSpMiddle> 'G': ['B', 'Q', 'X', 'Y', 'P', 'W'],</p>

<p class=SampleRunCxSpMiddle> 'H': ['B', 'K', 'P', 'W', 'X', 'Y'],</p>

<p class=SampleRunCxSpMiddle> 'I': ['H'],</p>

<p class=SampleRunCxSpMiddle> 'J': ['T'],</p>

<p class=SampleRunCxSpMiddle> 'K': [],</p>

<p class=SampleRunCxSpMiddle> 'L': ['A'],</p>

<p class=SampleRunCxSpMiddle> 'M': ['L'],</p>

<p class=SampleRunCxSpMiddle> 'N': ['M'],</p>

<p class=SampleRunCxSpMiddle> 'O': ['D'],</p>

<p class=SampleRunCxSpMiddle> 'P': ['O'],</p>

<p class=SampleRunCxSpMiddle> 'Q': ['V'],</p>

<p class=SampleRunCxSpMiddle> 'R': ['S'],</p>

<p class=SampleRunCxSpMiddle> 'S': ['I'],</p>

<p class=SampleRunCxSpMiddle> 'T': ['U'],</p>

<p class=SampleRunCxSpMiddle> 'U': ['G'],</p>

<p class=SampleRunCxSpMiddle> 'V': [],</p>

<p class=SampleRunCxSpMiddle> 'W': ['C'],</p>

<p class=SampleRunCxSpMiddle> 'X': ['N'],</p>

<p class=SampleRunCxSpMiddle> 'Y': ['F'],</p>

<p class=SampleRunCxSpLast> 'Z': ['Z']}</p>

</div>

<p class=MsoNormal>In the above example, the cipherletters A, C, I, J, L, M, N,
O, P, Q, R, S, T, U, X, Y, and Z all have one and only one potential decryption
letter. These cipher letters have been solved. The <span class=Literal>decryptWithCipherletterMapping()</span>
function, explained later, will print underscores for any cipherletters that
have not been solved (that is, B, D, E, F, G, H, K, and V.)</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 24.</span>    
print('Original ciphertext:')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 25.</span>    
print(message)</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 26.</span>    
print()</p>

</div>

<p class=MsoNormal>First the original encrypted message is displayed on the
screen so the programmer can compare it to the decryption.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 27.</span>    
print('Copying hacked message to clipboard:')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 28.</span>    
hackedMessage = decryptWithCipherletterMapping(message, letterMapping)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 29.</span>    
pyperclip.copy(hackedMessage)</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 30.</span>    
print(hackedMessage)</p>

</div>

<p class=MsoNormal>Next the decrypted message is returned from the <span
class=Literal>decryptWithCipherletterMapping()</span> function on line 28. This
hacked message is copied to the clipboard on line 29 and printed to the screen
on line 30.</p>

<p class=MsoNormal>Next, let’s look at all the functions that are called by <span
class=Literal>main()</span>.</p>

<h2><a name="_Toc353630871">Blank Cipherletter Mappings</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 33.</span>
def getBlankCipherletterMapping():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 34.</span>    
<span class=SourceCodeComment># Returns a dictionary value that is a blank
cipherletter mapping.</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 35.</span>    
return {'A': [], 'B': [], 'C': [], 'D': [], 'E': [], 'F': [], 'G': [], 'H': [],
'I': [], 'J': [], 'K': [], 'L': [], 'M': [], 'N': [], 'O': [], 'P': [], 'Q':
[], 'R': [], 'S': [], 'T': [], 'U': [], 'V': [], 'W': [], 'X': [], 'Y': [],
'Z': []}</p>

</div>

<p class=MsoNormal>Our program will need a cipherletter mapping for each
cipherword in the ciphertext, so we will create the <span class=Literal>getBlankCipherletterMapping()</span>
function which can return a new, blank mapping when called.</p>

<h2><a name="_Toc353630872">Adding Letters to a Cipherletter Mapping</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeatured><span class=SourceLineNumber> 38.</span> def
addLettersToMapping(letterMapping, cipherword, candidate):</p>

</div>

<p class=MsoNormal>The <span class=Literal>addLettersToMapping()</span>
function attempts to make sure that every letter in the candidate can be mapped
to a letter in the cipherword. It checks over each letter in <span
class=Literal>candidate</span> and adds its corresponding letter in <span
class=Literal>cipherword</span> to <span class=Literal>letterMapping</span> if
it wasn't already there. </p>

<p class=MsoNormal>For example, if <span class=Literal>'PUPPY'</span> is our
candidate word for the <span class=Literal>'HGHHU'</span> cipherword, the <span
class=Literal>addLettersToMapping()</span> function will change <span
class=Literal>letterMapping</span> so that the key <span class=Literal>'H'</span>
has <span class=Literal>'P'</span> added to its list of potential decryption
letters. Then the function will change the key <span class=Literal>'G'</span>
so that its list has <span class=Literal>'U'</span> appended to it.</p>

<p class=MsoNormal>If the letter is already in the list of potential decryption
letters, the <span class=Literal>addLettersToMapping()</span> will not add a
letter to the list. We can skip adding <span class=Literal>'P'</span> to the <span
class=Literal>'H'</span> key the next two times since it’s already been done. Finally,
the function will change the key <span class=Literal>'U'</span> so that it has <span
class=Literal>'Y'</span> in its list of potential decryption letters.</p>

<p class=MsoNormal>The code in this function assumes that <span class=Literal>len(cipherword)</span>
is the same as <span class=Literal>len(candidate)</span>.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeatured><span class=SourceLineNumber> 49.</span>    
letterMapping = copy.deepcopy(letterMapping)</p>

</div>

<p class=MsoNormal>To avoid changing the original dictionary value passed for
the <span class=Literal>letterMapping</span> parameter, line 49 will copy the
dictionary in <span class=Literal>letterMapping</span> and make this copy the
new value in <span class=Literal>letterMapping</span>. (We have to do this
because <span class=Literal>letterMapping</span> was passed a copy of a
dictionary reference value, instead of a copy of the dictionary value. See the
“List Reference” section in Chapter 10 for an explanation of references.)</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeatured><span class=SourceLineNumber> 50.</span>     for i
in range(len(cipherword)):</p>

</div>

<p class=MsoNormal>Line 50 will iterate over each index in the string in <span
class=Literal>cipherword</span>. We need the index (which is stored in the
variable <span class=Literal>i</span>) because the potential decryption letter
to be added will be <span class=Literal>candidate[i]</span> for the
cipherletter <span class=Literal>cipherword[i]</span>.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 51.</span>        
if candidate[i] not in letterMapping[cipherword[i]]:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 52.</span>            
letterMapping[cipherword[i]].append(candidate[i])</p>

</div>

<p class=MsoNormal>The <span class=Literal>if</span> statement on line 51
checks that the potential decryption letter is not already in the list of
potential decryption letters for the cipherletter. This prevents the list of
potential decryption letters in the cipherletter mapping from having duplicate
letters in it. For example, we never want the list to be a value like <span
class=Literal>['U', 'U']</span>.</p>

<p class=MsoNormal>Line 52 adds the new potential decryption letter (that is, <span
class=Literal>candidate[i]</span>) to the list of potential decryption letters
in the cipherletter mapping (that is, <span class=Literal>letterMapping[cipherword[i]]</span>).</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeatured><span class=SourceLineNumber> 53.</span>     return
letterMapping</p>

</div>

<p class=MsoNormal>After looping through all the indexes in <span
class=Literal>cipherword</span>, the additions to the cipherletter mapping are
complete and the dictionary in <span class=Literal>letterMapping</span> is
returned.</p>

<h2><a name="_Toc353630873">Intersecting Two Letter Mappings</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 56.</span>
def intersectMappings(mapA, mapB):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 57.</span>    
<span class=SourceCodeComment># To intersect two maps, create a blank map, and
then add only the</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 58.</span>    
<span class=SourceCodeComment># potential decryption letters if they exist in
BOTH maps.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 59.</span>    
intersectedMapping = getBlankCipherletterMapping()</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 60.</span>    
for letter in LETTERS:</p>

</div>

<p class=MsoNormal>The <span class=Literal>intersectMappings()</span> function
will return a new cipherletter mapping that is an intersection of the two
cipherletter mappings passed for the <span class=Literal>mapA</span> and <span
class=Literal>mapB</span> parameters. Line 59 creates a new cipherletter
mapping by calling <span class=Literal>getBlankCipherletterMapping()</span> and
storing the returned value in the <span class=Literal>intersectedMapping</span>
variable.</p>

<p class=MsoNormal>The <span class=Literal>for</span> loop will loop through
each of the uppercase letters in the <span class=Literal>LETTERS</span>
constant variable, and the <span class=Literal>letter</span> variable can be
used for the keys of the <span class=Literal>mapA</span> and <span
class=Literal>mapB</span> dictionaries.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 62.</span>        
<span class=SourceCodeComment># An empty list means &quot;any letter is
possible&quot;. In this case just</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 63.</span>        
<span class=SourceCodeComment># copy the other map entirely.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 64.</span>        
if mapA[letter] == []:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 65.</span>            
intersectedMapping[letter] = copy.deepcopy(mapB[letter])</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 66.</span>        
elif mapB[letter] == []:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 67.</span>            
intersectedMapping[letter] = copy.deepcopy(mapA[letter])</p>

</div>

<p class=MsoNormal>If the list of potential decryption letters for a
cipherletter in a cipherletter mapping is blank, this means that this
cipherletter could potentially decrypt to <em>any</em> letter. In this case,
the intersected cipherletter mapping will just be a copy of the <em>other</em>
mapping’s list of potential decryption letters.</p>

<p class=MsoNormal>That is, if <span class=Literal>mapA</span>’s list of
potential decryption letters is blank, then set the intersected mapping’s list
to be a copy of <span class=Literal>mapB</span>’s list. Or if <span
class=Literal>mapB</span>’s list is blank, then set the intersected mapping’s
list to be a copy of <span class=Literal>mapA</span>’s list.</p>

<p class=MsoNormal>(If both mappings’ lists were blank, then line 65 will
simply copy <span class=Literal>mapB</span>’s blank list to the intersected
mapping. This is the behavior we want: if both lists are blank then the
intersected mapping will have a blank list.)</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 68.</span>        
else:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 69.</span>            
<span class=SourceCodeComment># If a letter in mapA[letter] exists in
mapB[letter], add</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 70.</span>            
<span class=SourceCodeComment># that letter to intersectedMapping[letter].</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 71.</span>            
for mappedLetter in mapA[letter]:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 72.</span>                
if mappedLetter in mapB[letter]:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 73.</span>                    
intersectedMapping[letter].append(mappedLetter)</p>

</div>

<p class=MsoNormal>The <span class=Literal>else</span> block handles the case
where neither <span class=Literal>mapA</span> nor <span class=Literal>mapB</span>
are blank. In this case, line 71 loops through the uppercase letter strings in
the list at <span class=Literal>mapA[letter]</span>. Line 72 checks if this
uppercase letter in <span class=Literal>mapA[letter]</span> also exists in the
list of uppercase letter strings in <span class=Literal>mapB[letter]</span>. If
it does, then line 73 will add this common letter to the list of potential
decryption letters at <span class=Literal>intersectedMapping[letter]</span>.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeatured><span class=SourceLineNumber> 75.</span>     return
intersectedMapping</p>

</div>

<p class=MsoNormal>Once the <span class=Literal>for</span> loop that started on
line 60 has finished, the cipherletter mapping in <span class=Literal>intersectedMapping</span>
will only have the potential decryption letters that exist in the lists of
potential decryption letters of both <span class=Literal>mapA</span> and <span
class=Literal>mapB</span>. This completely intersected cipherletter mapping is
returned on line 75.</p>

<h2><a name="_Toc353630874">Removing Solved Letters from the Letter Mapping</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 78.</span>
def removeSolvedLettersFromMapping(letterMapping):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 79.</span>    
<span class=SourceCodeComment># Cipher letters in the mapping that map to only
one letter are</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 80.</span>    
<span class=SourceCodeComment># &quot;solved&quot; and can be removed from the
other letters.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 81.</span>    
<span class=SourceCodeComment># For example, if 'A' maps to potential letters ['M',
'N'], and 'B'</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 82.</span>    
<span class=SourceCodeComment># maps to ['N'], then we know that 'B' must map
to 'N', so we can</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 83.</span>    
<span class=SourceCodeComment># remove 'N' from the list of what 'A' could map
to. So 'A' then maps</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 84.</span>    
<span class=SourceCodeComment># to ['M']. Note that now that 'A' maps to only
one letter, we can</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 85.</span>    
<span class=SourceCodeComment># remove 'M' from the list of potential letters for
every other</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 86.</span>    
<span class=SourceCodeComment># key. (This is why there is a loop that keeps
reducing the map.)</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 87.</span>    
letterMapping = copy.deepcopy(letterMapping)</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 88.</span>    
loopAgain = True</p>

</div>

<p class=MsoNormal>The <span class=Literal>removeSolvedLettersFromMapping()</span>
function searches for any cipherletters in the <span class=Literal>letterMapping</span>
parameter which have one and only one potential decryption letter. These
cipherletters are considered solved: the cipherletter must decrypt to that one
potential decryption letter. This means that any other cipherletters that have this
solved letter can have that letter removed from their lists of potential
decryption letters.</p>

<p class=MsoNormal>This could cause a chain reaction, because when the one potential
decryption letter is removed from other lists of potential decryption letters,
it could result in a new solved cipherletter. In that case, the program will
loop and perform the solved letter removal over the whole cipherletter mapping
again.</p>

<p class=MsoNormal>The cipherletter mapping in letterMapping is copied on line 87
so that changes made to it in the function do not affect the dictionary value
outside the function. Line 88 creates <span class=Literal>loopAgain</span>,
which is a variable that holds a Boolean value that tells us if the code found
a new solved letter and needs to loop again. In that case the <span
class=Literal>loopAgain</span> variable is set to <span class=Literal>True</span>
on line 88 so that the program execution will enter the <span class=Literal>while</span>
loop on line 89.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 89.</span>    
while loopAgain:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 90.</span>        
<span class=SourceCodeComment># First assume that we will not loop again:</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 91.</span>        
loopAgain = False</p>

</div>

<p class=MsoNormal>At the very beginning of the loop, line 91 will set <span
class=Literal>loopAgain</span> to <span class=Literal>False</span>. The code
assumes that this will be the last iteration through line 89’s <span
class=Literal>while</span> loop. The <span class=Literal>loopAgain</span>
variable is only set to <span class=Literal>True</span> if we find a new solved
cipherletter during this iteration.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 93.</span>        
<span class=SourceCodeComment># solvedLetters will be a list of uppercase
letters that have one</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 94.</span>        
<span class=SourceCodeComment># and only one possible mapping in letterMapping</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 95.</span>        
solvedLetters = []</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 96.</span>        
for cipherletter in LETTERS:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 97.</span>            
if len(letterMapping[cipherletter]) == 1:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 98.</span>                
solvedLetters.append(letterMapping[cipherletter][0])</p>

</div>

<p class=MsoNormal>The next part of the code creates a list of cipherletters
that have exactly one potential decryption letter. We will put these
cipherletter strings in a list that is in <span class=Literal>solvedLetters</span>.
The <span class=Literal>solvedLetters</span> variable starts off as a blank
list on line 95.</p>

<p class=MsoNormal>The <span class=Literal>for</span> loop on line 96 goes
through all 26 possible cipherletters and looks at the cipherletter mapping’s
list of potential decryption letters for that cipherletter. (That is, the list
is at <span class=Literal>letterMapping[cipherletter]</span>.)</p>

<p class=MsoNormal>If the length of this list is <span class=Literal>1</span>
(which is checked on line 97), then we know that there is only one letter that
the cipherletter could decrypt to and the cipherletter is solved. We will add
the letter (the potential decryption letter, not the cipherletter) to the <span
class=Literal>solvedLetters</span> list on line 98. The solved letter will
always be at <span class=Literal>letterMapping[cipherletter][0]</span> because <span
class=Literal>letterMapping[cipherletter]</span> is a list of potential
decryption letters that only has one string value in it at index <span
class=Literal>0</span> of the list.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>100.</span>        
<span class=SourceCodeComment># If a letter is solved, than it cannot possibly
be a potential</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>101.</span>        
<span class=SourceCodeComment># decryption letter for a different ciphertext
letter, so we</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>102.</span>        
<span class=SourceCodeComment># should remove it from those other lists.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>103.</span>        
for cipherletter in LETTERS:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>104.</span>            
for s in solvedLetters:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>105.</span>                
if len(letterMapping[cipherletter]) != 1 and s in letterMapping[cipherletter]:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>106.</span>                    
letterMapping[cipherletter].remove(s)</p>

</div>

<p class=MsoNormal>After the previous <span class=Literal>for</span> loop that
started on line 96 has finished, the <span class=Literal>solvedLetters</span>
variable will be a list of all the letters that are solved decryptions of a cipherletter.
The <span class=Literal>for</span> loop on line 103 loops through all 26
possible cipherletters and looks at the cipherletter mapping’s list of
potential decryption letters.</p>

<p class=MsoNormal>For each cipherletter that is examined, the letters in <span
class=Literal>solvedLetters</span> are looped through on line 104 to check if each
of them exist in the list of potential decryption letters for <span
class=Literal>letterMapping[cipherletter]</span>. Line 105 checks if a list of
potential decryption letters is not solved (that is, if <span class=Literal>len(letterMapping[cipherletter])
!= 1</span>) <strong>and</strong> the solved letter exists in the list of
potential decryption letters. If this condition is <span class=Literal>True</span>,
then the solved letter in <span class=Literal>s</span> is removed from the list
of potential decryption letters on line 106.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>107.</span>                    
if len(letterMapping[cipherletter]) == 1:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>108.</span>                        
<span class=SourceCodeComment># A new letter is now solved, so loop again.</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>109.</span>                        
loopAgain = True</p>

</div>

<p class=MsoNormal>If by chance this removal caused the list of potential
decryption letters to now only have one letter in it, then the <span
class=Literal>loopAgain</span> variable is set to <span class=Literal>True</span>
on line 109 so that the code will check for this new solved letter in the
cipherletter mapping on the next iteration.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeatured><span class=SourceLineNumber>110.</span>     return
letterMapping</p>

</div>

<p class=MsoNormal>After the code in line 89’s <span class=Literal>while</span>
loop has gone through a full iteration without <span class=Literal>loopAgain</span>
being set to <span class=Literal>True</span>, the program execution goes past
the loop and returns the cipherletter mapping stored in <span class=Literal>letterMapping</span>.</p>

<h2><a name="_Toc353630875">Hacking the Simple Substitution Cipher</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>113.</span>
def hackSimpleSub(message):</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>114.</span>    
intersectedMap = getBlankCipherletterMapping()</p>

</div>

<p class=MsoNormal>Now that we’ve created the <span class=Literal>getBlankCipherletterMapping()</span>,
<span class=Literal>addLettersToMapping()</span>, <span class=Literal>intersectMappings()</span>,
and <span class=Literal>removeSolvedLettersFromMapping()</span> functions that
can manipulate the cipherletter mappings we pass them, we can use them all
together to hack a simple substitution message.</p>

<p class=MsoNormal>Remember the steps from our interactive shell exercise for
hacking a simple substitution cipher message: for each cipherword, get all the
candidates based on the cipherword’s word pattern, then add these candidates to
a cipherletter mapping. Then take the cipherletter mapping for each cipherword
and intersect them together.</p>

<p class=MsoNormal>The <span class=Literal>intersectedMap</span> variable will
hold the intersected cipherletter mapping of each cipherword’s cipherletter
mapping. At the beginning of the <span class=Literal>hackSimpleSub()</span>
function, it will start as a blank cipherletter mapping.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeatured><span class=SourceLineNumber>115.</span>     cipherwordList
= nonLettersOrSpacePattern.sub('', message.upper()).split()</p>

</div>

<p class=MsoNormal>The <span class=Literal>sub()</span> regex method will
substitute (that is, replace) any occurrences of the string pattern in the
second argument (<span class=Literal>message.upper()</span>) with the first
argument (a blank string). Regular expressions and the <span class=Literal>sub()</span>
method were explained earlier in this chapter.</p>

<p class=MsoNormal>On line 115, the regex object in <span class=Literal>nonLettersOrSpacePattern</span>
matches any string that is not a letter or whitespace character. The <span
class=Literal>sub()</span> method will return a string that is the <span
class=Literal>message</span> variable with all non-letter and non-space
characters replaced by a blank string. This effectively returns a string that
has all punctuation and number characters removed from <span class=Literal>message</span>.</p>

<p class=MsoNormal>This string then has the <span class=Literal>upper()</span>
method called on it to return an uppercase version of the string, and that
string has the <span class=Literal>split()</span> method called on it to return
the individual words in the string in a list. To see what each part of line 115
does, type the following into the interactive shell:</p>

<div style='border:solid #404040 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeExcerptCxSpFirst style='border:none;padding:0in'>&gt;&gt;&gt;
import re</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
nonLettersOrSpacePattern = re.compile('[^A-Z\s]')</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
message = 'Hello, this is my 1st test message.'</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
message = nonLettersOrSpacePattern.sub('', message.upper())</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
message</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>'HELLO
THIS IS MY ST TEST MESSAGE'</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
cipherwordList = message.split()</p>

<p class=SourceCodeExcerptCxSpMiddle style='border:none;padding:0in'>&gt;&gt;&gt;
cipherwordList</p>

<p class=SourceCodeExcerptCxSpLast style='border:none;padding:0in'>['HELLO',
'THIS', 'IS', 'MY', 'ST', 'TEST', 'MESSAGE']</p>

</div>

<p class=MsoNormal>After line 115 executes, the <span class=Literal>cipherwordList</span>
variable will contain a list of uppercase strings of the individual words that
were previously in <span class=Literal>message</span>.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>116.</span>    
for cipherword in cipherwordList:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>117.</span>        
<span class=SourceCodeComment># Get a new cipherletter mapping for each
ciphertext word.</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>118.</span>        
newMap = getBlankCipherletterMapping()</p>

</div>

<p class=MsoNormal>The <span class=Literal>for</span> loop on line 116 will
assign each string in the <span class=Literal>message</span> list to the <span
class=Literal>cipherword</span> variable. Inside this loop we will get the
cipherword’s candidates, add the candidates to a cipherletter mapping, and then
intersect this mapping with <span class=Literal>intersectedMap</span>.</p>

<p class=MsoNormal>First, line 118 will get a new, blank cipherletter mapping
from <span class=Literal>getBlankCipherletterMapping()</span> and store it in
the <span class=Literal>newMap</span> variable.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>120.</span>        
wordPattern = makeWordPatterns.getWordPattern(cipherword)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>121.</span>        
if wordPattern not in wordPatterns.allPatterns:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>122.</span>            
continue <span class=SourceCodeComment># This word was not in our dictionary,
so continue.</span></p>

</div>

<p class=MsoNormal>To find the candidates for the current cipherword, we call <span
class=Literal>getWordPattern()</span> in the <span class=Literal>makeWordPatterns</span>
module on line 120. If the word pattern of the cipherword does not exist in the
keys of the <span class=Literal>wordPatterns.allPatterns</span> dictionary, then
whatever the cipherword decrypts to does not exist in our dictionary file. In
that case the <span class=Literal>continue</span> statement on line 122 will
skip back to line 116, to the next cipherword in the list.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>124.</span>        
<span class=SourceCodeComment># Add the letters of each candidate to the
mapping.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>125.</span>        
for candidate in wordPatterns.allPatterns[wordPattern]:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>126.</span>            
newMap = addLettersToMapping(newMap, cipherword, candidate)</p>

</div>

<p class=MsoNormal>On line 125, we know the word pattern exists in <span
class=Literal>wordPatterns.allPatterns</span>. The values in the <span
class=Literal>allPatterns</span> dictionary are lists of strings of the English
words with the pattern in <span class=Literal>wordPattern</span>. Since it is a
list, we can use a <span class=Literal>for</span> loop to iterate over this
list. The variable <span class=Literal>candidate</span> will be set to each of
these English word strings on each iteration of the loop.</p>

<p class=MsoNormal>The only line inside line 125’s <span class=Literal>for</span>
loop is the call to <span class=Literal>addLettersToMapping()</span> on line 126.
We will use this to update the cipherletter mapping in <span class=Literal>newMap</span>
with the letters in each of the candidates.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>128.</span>        
<span class=SourceCodeComment># Intersect the new mapping with the existing
intersected mapping.</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>129.</span>        
intersectedMap = intersectMappings(intersectedMap, newMap)</p>

</div>

<p class=MsoNormal>Once all of the letters in the candidates are added to the
cipherletter mapping in <span class=Literal>newMap</span>, line 129 will
intersect <span class=Literal>newMap</span> with <span class=Literal>intersectedMap</span>,
and make the return value the new value of <span class=Literal>intersectedMap</span>.</p>

<p class=MsoNormal>At this point the program execution jumps back to the
beginning of the <span class=Literal>for</span> loop on line 116 to run the
code on the next cipherword in the <span class=Literal>cipherwordList</span>
list.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>131.</span>    
<span class=SourceCodeComment># Remove any solved letters from the other lists.</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>132.</span>    
return removeSolvedLettersFromMapping(intersectedMap)</p>

</div>

<p class=MsoNormal>Once we have the final intersected cipherletter mapping, we
can remove any solved letters from it by passing it to <span class=Literal>removeSolvedLettersFromMapping()</span>.
The cipherletter mapping that is returned from the function will be the return
value for <span class=Literal>hackSimpleSubstitution()</span>.</p>

<h2><a name="_Toc353630876">Creating a Key from a Letter Mapping</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>135.</span>
def decryptWithCipherletterMapping(ciphertext, letterMapping):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>136.</span>    
<span class=SourceCodeComment># Return a string of the ciphertext decrypted
with the letter mapping,</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>137.</span>    
<span class=SourceCodeComment># with any ambiguous decrypted letters replaced
with an _ underscore.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>138. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>139.</span>    
<span class=SourceCodeComment># First create a simple sub key from the
letterMapping mapping.</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>140.</span>    
key = ['x'] * len(LETTERS)</p>

</div>

<p class=MsoNormal>Since the <span class=Literal>simpleSubstitutionCipher.decryptMessage()</span>
function only decrypts with keys instead of letter mappings, we need the <span
class=Literal>decryptWithCipherletterMapping()</span> function to convert a
letter mapping into a string key.</p>

<p class=MsoNormal>The simple substitution keys are strings of 26 characters.
The character at index <span class=Literal>0</span> in the key string is the
substitution for A, the character at index <span class=Literal>1</span> is the
substitution for B, and so on.</p>

<p class=MsoNormal>Since the letter mapping might only have solutions for some
of the letters, we will start out with a key of <span class=Literal>['x', 'x',
'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x',
'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x']</span>. This list is created on line 140
by using list replication to replicate the list <span class=Literal>['x']</span>
26 times. Since <span class=Literal>LETTERS</span> is a string of the letters
of the alphabet, <span class=Literal>len(LETTERS)</span> evaluates to <span
class=Literal>26</span>. When the multiplication operator is used on a list and
integer, it does list replication.</p>

<p class=MsoNormal>We don’t have to use <span class=Literal>'x'</span>, we can
use any lowercase letter. The reason we need to use a lowercase letter is
because it acts as a “placeholder” for the simple substitution key. The way <span
class=Filename>simpleSubCipher.py</span> works, since <span class=Literal>LETTERS</span>
only contains uppercase letters, any lowercase letters in the key will not be
used to decrypt a message.</p>

<p class=MsoNormal>The 26-item list in <span class=Literal>key</span> will be
joined together into a 26-character string at the end of the <span
class=Literal>decryptWithCipherletterMapping()</span> function.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>141.</span>    
for cipherletter in LETTERS:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>142.</span>        
if len(letterMapping[cipherletter]) == 1:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>143.</span>            
<span class=SourceCodeComment># If there's only one letter, add it to the key.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>144.</span>            
keyIndex = LETTERS.find(letterMapping[cipherletter][0])</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>145.</span>            
key[keyIndex] = cipherletter</p>

</div>

<p class=MsoNormal>The <span class=Literal>for</span> loop on line 141 will let
us go through each of the letters in <span class=Literal>LETTERS</span> for the
<span class=Literal>cipherletter</span> variable, and if the cipherletter is
solved (that is, <span class=Literal>letterMapping[cipherletter]</span> has
only one letter in it) then we can replace an <span class=Literal>'x'</span> in
the key with the letter.</p>

<p class=MsoNormal>So on line 144 <span class=Literal>letterMapping[cipherletter][0]</span>
is the decryption letter, and <span class=Literal>keyIndex</span> is the index
of the decryption letter in <span class=Literal>LETTERS</span> (which is
returned from the <span class=Literal>find()</span> call). This index in the
key list is set to the decryption letter on line 145.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>146.</span>        
else:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>147.</span>            
ciphertext = ciphertext.replace(cipherletter.lower(), '_')</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>148.</span>            
ciphertext = ciphertext.replace(cipherletter.upper(), '_')</p>

</div>

<p class=MsoNormal>Or else, if the cipherletter does not have a solution, then
we want to replace everywhere that cipherletter appears in the ciphertext with
an underscore so the user can tell which characters were unsolved. Line 147
handles replacing the lowercase form of <span class=Literal>cipherletter</span>
with an underscore and line 148 handles replacing the uppercase form of <span
class=Literal>cipherletter</span> with an underscore.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>149.</span>    
key = ''.join(key)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>150. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>151.</span>    
<span class=SourceCodeComment># With the key we've created, decrypt the ciphertext.</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>152.</span>    
return simpleSubCipher.decryptMessage(key, ciphertext)</p>

</div>

<p class=MsoNormal>When we have finally replaced all the parts in the list in <span
class=Literal>key</span> with the solved letters, we convert the list of
strings into a single string with the <span class=Literal>join()</span> method to
create a simple substitution key. This string is passed to the <span
class=Literal>decryptMessage()</span> function in our <span class=Filename>simpleSubCipher.py</span>
program.</p>

<p class=MsoNormal>The decrypted message string returned from <span
class=Literal>decryptMessage()</span> is then returned from <span
class=Literal>decryptWithCipherletterMapping()</span> on line 152.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>simpleSubHacker.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>155.</span>
if __name__ == '__main__':</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>156.</span>    
main()</p>

</div>

<p class=MsoNormal>That completes all the functions our hacking program needs.
Lines 155 and 156 just call the <span class=Literal>main()</span> function to
run the program if <span class=Filename>simpleSubHacker.py</span> is being run
directly, instead of being imported as a module by another Python program.</p>

<h2><a name="_Toc353630877">Couldn’t We Just Encrypt the Spaces Too?</a></h2>

<p class=MsoNormal>Yes. Our hacking approach only works if the spaces were not
encrypted. You can modify the simple substitution cipher from the previous
chapter to encrypt spaces, numbers, and punctuation characters as well as
letters, and it would make your encrypted messages harder (but not impossible)
to hack. However, since the spaces will probably be the most common symbol in
the ciphertext, you can write a program to replace it back to spaces, and then
hack the ciphertext as normal. So encrypting the space characters would not offer
much more protection.</p>

<h2><a name="_Toc353630878">Summary</a></h2>

<p class=MsoNormal>Whew! This hacking program was fairly complicated. The
cipherletter mapping is the main tool for modeling the possible letters that
each ciphertext letter can decrypt to. By adding letters (based on the candidates
for each cipherword) to the mapping, and then intersecting mappings and
removing solved letters from other lists of potential decryption letters, we
can narrow down the number of possible keys. Instead of trying all 403,291,461,126,605,635,584,000,000
possible keys we can use some sophisticated Python code to figure out exactly
what most (if not all) of the original simple substitution key was.</p>

<p class=MsoNormal>The main strength of the simple substitution cipher is the
large number of possible keys. But the downfall is that it is easy enough to
compare the cipherwords to words in a dictionary file to slowly figure out
which cipherletters decrypt to which letters. The next chapter’s cipher is much
more powerful. For several hundred years, it was considered impossible to
break. It is a “polyalphabetic” substitution cipher called the Vigenère cipher.</p>

</div>

</body>

</html>
