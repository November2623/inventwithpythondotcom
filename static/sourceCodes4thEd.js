var sourceCodes = {"AISim1":"# Reversegam: a clone of Othello\/Reversi\r\nimport random\r\nimport sys\r\nWIDTH = 8  # Board is 8 spaces wide\r\nHEIGHT = 8 # Board is 8 spaces tall\r\ndef drawBoard(board):\r\n    # This function prints the board that it was passed. Returns None.\r\n    print(\'  12345678\')\r\n    print(\' +--------+\')\r\n    for y in range(HEIGHT):\r\n        print(\'%s|\' % (y+1), end=\'\')\r\n        for x in range(WIDTH):\r\n            print(board[x][y], end=\'\')\r\n        print(\'|%s\' % (y+1))\r\n    print(\' +--------+\')\r\n    print(\'  12345678\')\r\n\r\ndef getNewBoard():\r\n    # Creates a brand-new, blank board data structure.\r\n    board = []\r\n    for i in range(WIDTH):\r\n        board.append([\' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \'])\r\n    return board\r\n\r\ndef isValidMove(board, tile, xstart, ystart):\r\n    # Returns False if the player\'s move on space xstart, ystart is invalid.\r\n    # If it is a valid move, returns a list of spaces that would become the player\'s if they made a move here.\r\n    if board[xstart][ystart] != \' \' or not isOnBoard(xstart, ystart):\r\n        return False\r\n\r\n    if tile == \'X\':\r\n        otherTile = \'O\'\r\n    else:\r\n        otherTile = \'X\'\r\n\r\n    tilesToFlip = []\r\n    for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:\r\n        x, y = xstart, ystart\r\n        x += xdirection # First step in the x direction\r\n        y += ydirection # First step in the y direction\r\n        while isOnBoard(x, y) and board[x][y] == otherTile:\r\n            # Keep moving in this x & y direction.\r\n            x += xdirection\r\n            y += ydirection\r\n            if isOnBoard(x, y) and board[x][y] == tile:\r\n                # There are pieces to flip over. Go in the reverse direction until we reach the original space, noting all the tiles along the way.\r\n                while True:\r\n                    x -= xdirection\r\n                    y -= ydirection\r\n                    if x == xstart and y == ystart:\r\n                        break\r\n                    tilesToFlip.append([x, y])\r\n\r\n    if len(tilesToFlip) == 0: # If no tiles were flipped, this is not a valid move.\r\n        return False\r\n    return tilesToFlip\r\n\r\ndef isOnBoard(x, y):\r\n    # Returns True if the coordinates are located on the board.\r\n    return x >= 0 and x <= WIDTH - 1 and y >= 0 and y <= HEIGHT - 1\r\n\r\ndef getBoardWithValidMoves(board, tile):\r\n    # Returns a new board with periods marking the valid moves the player can make.\r\n    boardCopy = getBoardCopy(board)\r\n\r\n    for x, y in getValidMoves(boardCopy, tile):\r\n        boardCopy[x][y] = \'.\'\r\n    return boardCopy\r\n\r\ndef getValidMoves(board, tile):\r\n    # Returns a list of [x,y] lists of valid moves for the given player on the given board.\r\n    validMoves = []\r\n    for x in range(WIDTH):\r\n        for y in range(HEIGHT):\r\n            if isValidMove(board, tile, x, y) != False:\r\n                validMoves.append([x, y])\r\n    return validMoves\r\n\r\ndef getScoreOfBoard(board):\r\n    # Determine the score by counting the tiles. Returns a dictionary with keys \'X\' and \'O\'.\r\n    xscore = 0\r\n    oscore = 0\r\n    for x in range(WIDTH):\r\n        for y in range(HEIGHT):\r\n            if board[x][y] == \'X\':\r\n                xscore += 1\r\n            if board[x][y] == \'O\':\r\n                oscore += 1\r\n    return {\'X\':xscore, \'O\':oscore}\r\n\r\ndef enterPlayerTile():\r\n    # Lets the player type which tile they want to be.\r\n    # Returns a list with the player\'s tile as the first item and the computer\'s tile as the second.\r\n    tile = \'\'\r\n    while not (tile == \'X\' or tile == \'O\'):\r\n        print(\'Do you want to be X or O?\')\r\n        tile = input().upper()\r\n\r\n    # The first element in the list is the player\'s tile, and the second is the computer\'s tile.\r\n    if tile == \'X\':\r\n        return [\'X\', \'O\']\r\n    else:\r\n        return [\'O\', \'X\']\r\n\r\ndef whoGoesFirst():\r\n    # Randomly choose who goes first.\r\n    if random.randint(0, 1) == 0:\r\n        return \'computer\'\r\n    else:\r\n        return \'player\'\r\n\r\ndef makeMove(board, tile, xstart, ystart):\r\n    # Place the tile on the board at xstart, ystart, and flip any of the opponent\'s pieces.\r\n    # Returns False if this is an invalid move; True if it is valid.\r\n    tilesToFlip = isValidMove(board, tile, xstart, ystart)\r\n\r\n    if tilesToFlip == False:\r\n        return False\r\n\r\n    board[xstart][ystart] = tile\r\n    for x, y in tilesToFlip:\r\n        board[x][y] = tile\r\n    return True\r\n\r\ndef getBoardCopy(board):\r\n    # Make a duplicate of the board list and return it.\r\n    boardCopy = getNewBoard()\r\n\r\n    for x in range(WIDTH):\r\n        for y in range(HEIGHT):\r\n            boardCopy[x][y] = board[x][y]\r\n\r\n    return boardCopy\r\n\r\ndef isOnCorner(x, y):\r\n    # Returns True if the position is in one of the four corners.\r\n    return (x == 0 or x == WIDTH - 1) and (y == 0 or y == HEIGHT - 1)\r\n\r\ndef getPlayerMove(board, playerTile):\r\n    # Let the player enter their move.\r\n    # Returns the move as [x, y] (or returns the strings \'hints\' or \'quit\').\r\n    DIGITS1TO8 = \'1 2 3 4 5 6 7 8\'.split()\r\n    while True:\r\n        print(\'Enter your move, \"quit\" to end the game, or \"hints\" to toggle hints.\')\r\n        move = input().lower()\r\n        if move == \'quit\' or move == \'hints\':\r\n            return move\r\n\r\n        if len(move) == 2 and move[0] in DIGITS1TO8 and move[1] in DIGITS1TO8:\r\n            x = int(move[0]) - 1\r\n            y = int(move[1]) - 1\r\n            if isValidMove(board, playerTile, x, y) == False:\r\n                continue\r\n            else:\r\n                break\r\n        else:\r\n            print(\'That is not a valid move. Enter the column (1-8) and then the row (1-8).\')\r\n            print(\'For example, 81 will move on the top-right corner.\')\r\n\r\n    return [x, y]\r\n\r\ndef getComputerMove(board, computerTile):\r\n    # Given a board and the computer\'s tile, determine where to\r\n    # move and return that move as a [x, y] list.\r\n    possibleMoves = getValidMoves(board, computerTile)\r\n    random.shuffle(possibleMoves) # randomize the order of the moves\r\n\r\n    # Always go for a corner if available.\r\n    for x, y in possibleMoves:\r\n        if isOnCorner(x, y):\r\n            return [x, y]\r\n\r\n    # Find the highest-scoring move possible.\r\n    bestScore = -1\r\n    for x, y in possibleMoves:\r\n        boardCopy = getBoardCopy(board)\r\n        makeMove(boardCopy, computerTile, x, y)\r\n        score = getScoreOfBoard(boardCopy)[computerTile]\r\n        if score > bestScore:\r\n            bestMove = [x, y]\r\n            bestScore = score\r\n    return bestMove\r\n\r\ndef printScore(board, playerTile, computerTile):\r\n    scores = getScoreOfBoard(board)\r\n    print(\'You: %s points. Computer: %s points.\' % (scores[playerTile], scores[computerTile]))\r\n\r\ndef playGame(playerTile, computerTile):\r\n    showHints = False\r\n    turn = whoGoesFirst()\r\n    print(\'The \' + turn + \' will go first.\')\r\n\r\n    # Clear the board and place starting pieces.\r\n    board = getNewBoard()\r\n    board[3][3] = \'X\'\r\n    board[3][4] = \'O\'\r\n    board[4][3] = \'O\'\r\n    board[4][4] = \'X\'\r\n\r\n    while True:\r\n        playerValidMoves = getValidMoves(board, playerTile)\r\n        computerValidMoves = getValidMoves(board, computerTile)\r\n\r\n        if playerValidMoves == [] and computerValidMoves == []:\r\n            return board # No one can move, so end the game.\r\n\r\n        elif turn == \'player\': # Player\'s turn\r\n            if playerValidMoves != []:\r\n                #if showHints:\r\n                #    validMovesBoard = getBoardWithValidMoves(board, playerTile)\r\n                #    drawBoard(validMovesBoard)\r\n                #else:\r\n                    #drawBoard(board)\r\n                #printScore(board, playerTile, computerTile)\r\n\r\n                move = getComputerMove(board, playerTile)\r\n                #if move == \'quit\':\r\n                #    print(\'Thanks for playing!\')\r\n                #    sys.exit() # Terminate the program.\r\n                #elif move == \'hints\':\r\n                #    showHints = not showHints\r\n                #    continue\r\n                #else:\r\n                makeMove(board, playerTile, move[0], move[1])\r\n            turn = \'computer\'\r\n\r\n        elif turn == \'computer\': # Computer\'s turn\r\n            if computerValidMoves != []:\r\n                #drawBoard(board)\r\n                #printScore(board, playerTile, computerTile)\r\n\r\n                #input(\'Press Enter to see the computer\\\'s move.\')\r\n                move = getComputerMove(board, computerTile)\r\n                makeMove(board, computerTile, move[0], move[1])\r\n            turn = \'player\'\r\n\r\n\r\n\r\nprint(\'Welcome to Reversegam!\')\r\n\r\nplayerTile, computerTile = [\'X\', \'O\'] #enterPlayerTile()\r\n\r\nwhile True:\r\n    finalBoard = playGame(playerTile, computerTile)\r\n\r\n    # Display the final score.\r\n    drawBoard(finalBoard)\r\n    scores = getScoreOfBoard(finalBoard)\r\n    print(\'X scored %s points. O scored %s points.\' % (scores[\'X\'], scores[\'O\']))\r\n    if scores[playerTile] > scores[computerTile]:\r\n        print(\'You beat the computer by %s points! Congratulations!\' % (scores[playerTile] - scores[computerTile]))\r\n    elif scores[playerTile] < scores[computerTile]:\r\n        print(\'You lost. The computer beat you by %s points.\' % (scores[computerTile] - scores[playerTile]))\r\n    else:\r\n        print(\'The game was a tie!\')\r\n\r\n    print(\'Do you want to play again? (yes or no)\')\r\n    if not input().lower().startswith(\'y\'):\r\n        break\r\n",
    "AISim2":"# Reversegam: a clone of Othello\/Reversi\r\nimport random\r\nimport sys\r\nWIDTH = 8  # Board is 8 spaces wide\r\nHEIGHT = 8 # Board is 8 spaces tall\r\ndef drawBoard(board):\r\n    # This function prints the board that it was passed. Returns None.\r\n    print(\'  12345678\')\r\n    print(\' +--------+\')\r\n    for y in range(HEIGHT):\r\n        print(\'%s|\' % (y+1), end=\'\')\r\n        for x in range(WIDTH):\r\n            print(board[x][y], end=\'\')\r\n        print(\'|%s\' % (y+1))\r\n    print(\' +--------+\')\r\n    print(\'  12345678\')\r\n\r\ndef getNewBoard():\r\n    # Creates a brand-new, blank board data structure.\r\n    board = []\r\n    for i in range(WIDTH):\r\n        board.append([\' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \'])\r\n    return board\r\n\r\ndef isValidMove(board, tile, xstart, ystart):\r\n    # Returns False if the player\'s move on space xstart, ystart is invalid.\r\n    # If it is a valid move, returns a list of spaces that would become the player\'s if they made a move here.\r\n    if board[xstart][ystart] != \' \' or not isOnBoard(xstart, ystart):\r\n        return False\r\n\r\n    if tile == \'X\':\r\n        otherTile = \'O\'\r\n    else:\r\n        otherTile = \'X\'\r\n\r\n    tilesToFlip = []\r\n    for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:\r\n        x, y = xstart, ystart\r\n        x += xdirection # First step in the x direction\r\n        y += ydirection # First step in the y direction\r\n        while isOnBoard(x, y) and board[x][y] == otherTile:\r\n            # Keep moving in this x & y direction.\r\n            x += xdirection\r\n            y += ydirection\r\n            if isOnBoard(x, y) and board[x][y] == tile:\r\n                # There are pieces to flip over. Go in the reverse direction until we reach the original space, noting all the tiles along the way.\r\n                while True:\r\n                    x -= xdirection\r\n                    y -= ydirection\r\n                    if x == xstart and y == ystart:\r\n                        break\r\n                    tilesToFlip.append([x, y])\r\n\r\n    if len(tilesToFlip) == 0: # If no tiles were flipped, this is not a valid move.\r\n        return False\r\n    return tilesToFlip\r\n\r\ndef isOnBoard(x, y):\r\n    # Returns True if the coordinates are located on the board.\r\n    return x >= 0 and x <= WIDTH - 1 and y >= 0 and y <= HEIGHT - 1\r\n\r\ndef getBoardWithValidMoves(board, tile):\r\n    # Returns a new board with periods marking the valid moves the player can make.\r\n    boardCopy = getBoardCopy(board)\r\n\r\n    for x, y in getValidMoves(boardCopy, tile):\r\n        boardCopy[x][y] = \'.\'\r\n    return boardCopy\r\n\r\ndef getValidMoves(board, tile):\r\n    # Returns a list of [x,y] lists of valid moves for the given player on the given board.\r\n    validMoves = []\r\n    for x in range(WIDTH):\r\n        for y in range(HEIGHT):\r\n            if isValidMove(board, tile, x, y) != False:\r\n                validMoves.append([x, y])\r\n    return validMoves\r\n\r\ndef getScoreOfBoard(board):\r\n    # Determine the score by counting the tiles. Returns a dictionary with keys \'X\' and \'O\'.\r\n    xscore = 0\r\n    oscore = 0\r\n    for x in range(WIDTH):\r\n        for y in range(HEIGHT):\r\n            if board[x][y] == \'X\':\r\n                xscore += 1\r\n            if board[x][y] == \'O\':\r\n                oscore += 1\r\n    return {\'X\':xscore, \'O\':oscore}\r\n\r\ndef enterPlayerTile():\r\n    # Lets the player type which tile they want to be.\r\n    # Returns a list with the player\'s tile as the first item and the computer\'s tile as the second.\r\n    tile = \'\'\r\n    while not (tile == \'X\' or tile == \'O\'):\r\n        print(\'Do you want to be X or O?\')\r\n        tile = input().upper()\r\n\r\n    # The first element in the list is the player\'s tile, and the second is the computer\'s tile.\r\n    if tile == \'X\':\r\n        return [\'X\', \'O\']\r\n    else:\r\n        return [\'O\', \'X\']\r\n\r\ndef whoGoesFirst():\r\n    # Randomly choose who goes first.\r\n    if random.randint(0, 1) == 0:\r\n        return \'computer\'\r\n    else:\r\n        return \'player\'\r\n\r\ndef makeMove(board, tile, xstart, ystart):\r\n    # Place the tile on the board at xstart, ystart, and flip any of the opponent\'s pieces.\r\n    # Returns False if this is an invalid move; True if it is valid.\r\n    tilesToFlip = isValidMove(board, tile, xstart, ystart)\r\n\r\n    if tilesToFlip == False:\r\n        return False\r\n\r\n    board[xstart][ystart] = tile\r\n    for x, y in tilesToFlip:\r\n        board[x][y] = tile\r\n    return True\r\n\r\ndef getBoardCopy(board):\r\n    # Make a duplicate of the board list and return it.\r\n    boardCopy = getNewBoard()\r\n\r\n    for x in range(WIDTH):\r\n        for y in range(HEIGHT):\r\n            boardCopy[x][y] = board[x][y]\r\n\r\n    return boardCopy\r\n\r\ndef isOnCorner(x, y):\r\n    # Returns True if the position is in one of the four corners.\r\n    return (x == 0 or x == WIDTH - 1) and (y == 0 or y == HEIGHT - 1)\r\n\r\ndef getPlayerMove(board, playerTile):\r\n    # Let the player enter their move.\r\n    # Returns the move as [x, y] (or returns the strings \'hints\' or \'quit\').\r\n    DIGITS1TO8 = \'1 2 3 4 5 6 7 8\'.split()\r\n    while True:\r\n        print(\'Enter your move, \"quit\" to end the game, or \"hints\" to toggle hints.\')\r\n        move = input().lower()\r\n        if move == \'quit\' or move == \'hints\':\r\n            return move\r\n\r\n        if len(move) == 2 and move[0] in DIGITS1TO8 and move[1] in DIGITS1TO8:\r\n            x = int(move[0]) - 1\r\n            y = int(move[1]) - 1\r\n            if isValidMove(board, playerTile, x, y) == False:\r\n                continue\r\n            else:\r\n                break\r\n        else:\r\n            print(\'That is not a valid move. Enter the column (1-8) and then the row (1-8).\')\r\n            print(\'For example, 81 will move on the top-right corner.\')\r\n\r\n    return [x, y]\r\n\r\ndef getComputerMove(board, computerTile):\r\n    # Given a board and the computer\'s tile, determine where to\r\n    # move and return that move as a [x, y] list.\r\n    possibleMoves = getValidMoves(board, computerTile)\r\n    random.shuffle(possibleMoves) # randomize the order of the moves\r\n\r\n    # Always go for a corner if available.\r\n    for x, y in possibleMoves:\r\n        if isOnCorner(x, y):\r\n            return [x, y]\r\n\r\n    # Find the highest-scoring move possible.\r\n    bestScore = -1\r\n    for x, y in possibleMoves:\r\n        boardCopy = getBoardCopy(board)\r\n        makeMove(boardCopy, computerTile, x, y)\r\n        score = getScoreOfBoard(boardCopy)[computerTile]\r\n        if score > bestScore:\r\n            bestMove = [x, y]\r\n            bestScore = score\r\n    return bestMove\r\n\r\ndef printScore(board, playerTile, computerTile):\r\n    scores = getScoreOfBoard(board)\r\n    print(\'You: %s points. Computer: %s points.\' % (scores[playerTile], scores[computerTile]))\r\n\r\ndef playGame(playerTile, computerTile):\r\n    showHints = False\r\n    turn = whoGoesFirst()\r\n    #print(\'The \' + turn + \' will go first.\')\r\n\r\n    # Clear the board and place starting pieces.\r\n    board = getNewBoard()\r\n    board[3][3] = \'X\'\r\n    board[3][4] = \'O\'\r\n    board[4][3] = \'O\'\r\n    board[4][4] = \'X\'\r\n\r\n    while True:\r\n        playerValidMoves = getValidMoves(board, playerTile)\r\n        computerValidMoves = getValidMoves(board, computerTile)\r\n\r\n        if playerValidMoves == [] and computerValidMoves == []:\r\n            return board # No one can move, so end the game.\r\n\r\n        elif turn == \'player\': # Player\'s turn\r\n            if playerValidMoves != []:\r\n                #if showHints:\r\n                #    validMovesBoard = getBoardWithValidMoves(board, playerTile)\r\n                #    drawBoard(validMovesBoard)\r\n                #else:\r\n                    #drawBoard(board)\r\n                #printScore(board, playerTile, computerTile)\r\n\r\n                move = getComputerMove(board, playerTile)\r\n                #if move == \'quit\':\r\n                #    print(\'Thanks for playing!\')\r\n                #    sys.exit() # Terminate the program.\r\n                #elif move == \'hints\':\r\n                #    showHints = not showHints\r\n                #    continue\r\n                #else:\r\n                makeMove(board, playerTile, move[0], move[1])\r\n            turn = \'computer\'\r\n\r\n        elif turn == \'computer\': # Computer\'s turn\r\n            if computerValidMoves != []:\r\n                #drawBoard(board)\r\n                #printScore(board, playerTile, computerTile)\r\n\r\n                #input(\'Press Enter to see the computer\\\'s move.\')\r\n                move = getComputerMove(board, computerTile)\r\n                makeMove(board, computerTile, move[0], move[1])\r\n            turn = \'player\'\r\n\r\nNUM_GAMES = 250\r\nxWins = oWins = ties = 0\r\nprint(\'Welcome to Reversegam!\')\r\n\r\nplayerTile, computerTile = [\'X\', \'O\'] #enterPlayerTile()\r\n\r\nfor i in range(NUM_GAMES): #while True:\r\n    finalBoard = playGame(playerTile, computerTile)\r\n\r\n    # Display the final score.\r\n    #drawBoard(finalBoard)\r\n    scores = getScoreOfBoard(finalBoard)\r\n    print(\'#%s: X scored %s points. O scored %s points.\' % (i + 1, scores[\'X\'], scores[\'O\']))\r\n    if scores[playerTile] > scores[computerTile]:\r\n        xWins += 1 #print(\'You beat the computer by %s points! Congratulations!\' % (scores[playerTile] - scores[computerTile]))\r\n    elif scores[playerTile] < scores[computerTile]:\r\n        oWins += 1 #print(\'You lost. The computer beat you by %s points.\' % (scores[computerTile] - scores[playerTile]))\r\n    else:\r\n        ties += 1 #print(\'The game was a tie!\')\r\n\r\n    #print(\'Do you want to play again? (yes or no)\')\r\n    #if not input().lower().startswith(\'y\'):\r\n    #    break\r\n\r\nprint(\'X wins: %s (%s%%)\' % (xWins, round(xWins \/ NUM_GAMES * 100, 1)))\r\nprint(\'O wins: %s (%s%%)\' % (oWins, round(oWins \/ NUM_GAMES * 100, 1)))\r\nprint(\'Ties:   %s (%s%%)\' % (ties, round(ties \/ NUM_GAMES * 100, 1)))\r\n",
    "AISim3":"# Reversegam: a clone of Othello\/Reversi\r\nimport random\r\nimport sys\r\nWIDTH = 8  # Board is 8 spaces wide\r\nHEIGHT = 8 # Board is 8 spaces tall\r\ndef drawBoard(board):\r\n    # This function prints the board that it was passed. Returns None.\r\n    print(\'  12345678\')\r\n    print(\' +--------+\')\r\n    for y in range(HEIGHT):\r\n        print(\'%s|\' % (y+1), end=\'\')\r\n        for x in range(WIDTH):\r\n            print(board[x][y], end=\'\')\r\n        print(\'|%s\' % (y+1))\r\n    print(\' +--------+\')\r\n    print(\'  12345678\')\r\n\r\ndef getNewBoard():\r\n    # Creates a brand-new, blank board data structure.\r\n    board = []\r\n    for i in range(WIDTH):\r\n        board.append([\' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \'])\r\n    return board\r\n\r\ndef isValidMove(board, tile, xstart, ystart):\r\n    # Returns False if the player\'s move on space xstart, ystart is invalid.\r\n    # If it is a valid move, returns a list of spaces that would become the player\'s if they made a move here.\r\n    if board[xstart][ystart] != \' \' or not isOnBoard(xstart, ystart):\r\n        return False\r\n\r\n    if tile == \'X\':\r\n        otherTile = \'O\'\r\n    else:\r\n        otherTile = \'X\'\r\n\r\n    tilesToFlip = []\r\n    for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:\r\n        x, y = xstart, ystart\r\n        x += xdirection # First step in the x direction\r\n        y += ydirection # First step in the y direction\r\n        while isOnBoard(x, y) and board[x][y] == otherTile:\r\n            # Keep moving in this x & y direction.\r\n            x += xdirection\r\n            y += ydirection\r\n            if isOnBoard(x, y) and board[x][y] == tile:\r\n                # There are pieces to flip over. Go in the reverse direction until we reach the original space, noting all the tiles along the way.\r\n                while True:\r\n                    x -= xdirection\r\n                    y -= ydirection\r\n                    if x == xstart and y == ystart:\r\n                        break\r\n                    tilesToFlip.append([x, y])\r\n\r\n    if len(tilesToFlip) == 0: # If no tiles were flipped, this is not a valid move.\r\n        return False\r\n    return tilesToFlip\r\n\r\ndef isOnBoard(x, y):\r\n    # Returns True if the coordinates are located on the board.\r\n    return x >= 0 and x <= WIDTH - 1 and y >= 0 and y <= HEIGHT - 1\r\n\r\ndef getBoardWithValidMoves(board, tile):\r\n    # Returns a new board with periods marking the valid moves the player can make.\r\n    boardCopy = getBoardCopy(board)\r\n\r\n    for x, y in getValidMoves(boardCopy, tile):\r\n        boardCopy[x][y] = \'.\'\r\n    return boardCopy\r\n\r\ndef getValidMoves(board, tile):\r\n    # Returns a list of [x,y] lists of valid moves for the given player on the given board.\r\n    validMoves = []\r\n    for x in range(WIDTH):\r\n        for y in range(HEIGHT):\r\n            if isValidMove(board, tile, x, y) != False:\r\n                validMoves.append([x, y])\r\n    return validMoves\r\n\r\ndef getScoreOfBoard(board):\r\n    # Determine the score by counting the tiles. Returns a dictionary with keys \'X\' and \'O\'.\r\n    xscore = 0\r\n    oscore = 0\r\n    for x in range(WIDTH):\r\n        for y in range(HEIGHT):\r\n            if board[x][y] == \'X\':\r\n                xscore += 1\r\n            if board[x][y] == \'O\':\r\n                oscore += 1\r\n    return {\'X\':xscore, \'O\':oscore}\r\n\r\ndef enterPlayerTile():\r\n    # Lets the player type which tile they want to be.\r\n    # Returns a list with the player\'s tile as the first item and the computer\'s tile as the second.\r\n    tile = \'\'\r\n    while not (tile == \'X\' or tile == \'O\'):\r\n        print(\'Do you want to be X or O?\')\r\n        tile = input().upper()\r\n\r\n    # The first element in the list is the player\'s tile, and the second is the computer\'s tile.\r\n    if tile == \'X\':\r\n        return [\'X\', \'O\']\r\n    else:\r\n        return [\'O\', \'X\']\r\n\r\ndef whoGoesFirst():\r\n    # Randomly choose who goes first.\r\n    if random.randint(0, 1) == 0:\r\n        return \'computer\'\r\n    else:\r\n        return \'player\'\r\n\r\ndef makeMove(board, tile, xstart, ystart):\r\n    # Place the tile on the board at xstart, ystart, and flip any of the opponent\'s pieces.\r\n    # Returns False if this is an invalid move; True if it is valid.\r\n    tilesToFlip = isValidMove(board, tile, xstart, ystart)\r\n\r\n    if tilesToFlip == False:\r\n        return False\r\n\r\n    board[xstart][ystart] = tile\r\n    for x, y in tilesToFlip:\r\n        board[x][y] = tile\r\n    return True\r\n\r\ndef getBoardCopy(board):\r\n    # Make a duplicate of the board list and return it.\r\n    boardCopy = getNewBoard()\r\n\r\n    for x in range(WIDTH):\r\n        for y in range(HEIGHT):\r\n            boardCopy[x][y] = board[x][y]\r\n\r\n    return boardCopy\r\n\r\ndef isOnCorner(x, y):\r\n    # Returns True if the position is in one of the four corners.\r\n    return (x == 0 or x == WIDTH - 1) and (y == 0 or y == HEIGHT - 1)\r\n\r\ndef getPlayerMove(board, playerTile):\r\n    # Let the player enter their move.\r\n    # Returns the move as [x, y] (or returns the strings \'hints\' or \'quit\').\r\n    DIGITS1TO8 = \'1 2 3 4 5 6 7 8\'.split()\r\n    while True:\r\n        print(\'Enter your move, \"quit\" to end the game, or \"hints\" to toggle hints.\')\r\n        move = input().lower()\r\n        if move == \'quit\' or move == \'hints\':\r\n            return move\r\n\r\n        if len(move) == 2 and move[0] in DIGITS1TO8 and move[1] in DIGITS1TO8:\r\n            x = int(move[0]) - 1\r\n            y = int(move[1]) - 1\r\n            if isValidMove(board, playerTile, x, y) == False:\r\n                continue\r\n            else:\r\n                break\r\n        else:\r\n            print(\'That is not a valid move. Enter the column (1-8) and then the row (1-8).\')\r\n            print(\'For example, 81 will move on the top-right corner.\')\r\n\r\n    return [x, y]\r\n\r\ndef getCornerBestMove(board, computerTile):\r\n    # Given a board and the computer\'s tile, determine where to\r\n    # move and return that move as a [x, y] list.\r\n    possibleMoves = getValidMoves(board, computerTile)\r\n    random.shuffle(possibleMoves) # randomize the order of the moves\r\n\r\n    # Always go for a corner if available.\r\n    for x, y in possibleMoves:\r\n        if isOnCorner(x, y):\r\n            return [x, y]\r\n\r\n    # Find the highest-scoring move possible.\r\n    bestScore = -1\r\n    for x, y in possibleMoves:\r\n        boardCopy = getBoardCopy(board)\r\n        makeMove(boardCopy, computerTile, x, y)\r\n        score = getScoreOfBoard(boardCopy)[computerTile]\r\n        if score > bestScore:\r\n            bestMove = [x, y]\r\n            bestScore = score\r\n    return bestMove\r\n\r\ndef getWorstMove(board, tile):\r\n    # Return the move that flips the least number of tiles.\r\n    possibleMoves = getValidMoves(board, tile)\r\n    random.shuffle(possibleMoves) # Randomize the order of the moves.\r\n\r\n    # Go through all the possible moves and remember the best scoring move.\r\n    worstScore = 64\r\n    for x, y in possibleMoves:\r\n        boardCopy = getBoardCopy(board)\r\n        makeMove(boardCopy, tile, x, y)\r\n        score = getScoreOfBoard(boardCopy)[tile]\r\n        if score < worstScore:\r\n            worstMove = [x, y]\r\n            worstScore = score\r\n\r\n    return worstMove\r\n\r\ndef getRandomMove(board, tile):\r\n    possibleMoves = getValidMoves(board, tile)\r\n    return random.choice(possibleMoves)\r\n\r\ndef isOnSide(x, y):\r\n    return x == 0 or x == WIDTH - 1 or y == 0 or y == HEIGHT - 1\r\n\r\ndef getCornerSideBestMove(board, tile):\r\n    # Return a corner move, or a side move, or the best move.\r\n    possibleMoves = getValidMoves(board, tile)\r\n    random.shuffle(possibleMoves) # Randomize the order of the moves.\r\n\r\n    # Always go for a corner if available.\r\n    for x, y in possibleMoves:\r\n        if isOnCorner(x, y):\r\n            return [x, y]\r\n\r\n    # If there is no corner, return a side move.\r\n    for x, y in possibleMoves:\r\n        if isOnSide(x, y):\r\n            return [x, y]\r\n\r\n    return getCornerBestMove(board, tile) # Do what the normal AI would do.\r\n\r\ndef printScore(board, playerTile, computerTile):\r\n    scores = getScoreOfBoard(board)\r\n    print(\'You: %s points. Computer: %s points.\' % (scores[playerTile], scores[computerTile]))\r\n\r\ndef playGame(playerTile, computerTile):\r\n    showHints = False\r\n    turn = whoGoesFirst()\r\n    #print(\'The \' + turn + \' will go first.\')\r\n\r\n    # Clear the board and place starting pieces.\r\n    board = getNewBoard()\r\n    board[3][3] = \'X\'\r\n    board[3][4] = \'O\'\r\n    board[4][3] = \'O\'\r\n    board[4][4] = \'X\'\r\n\r\n    while True:\r\n        playerValidMoves = getValidMoves(board, playerTile)\r\n        computerValidMoves = getValidMoves(board, computerTile)\r\n\r\n        if playerValidMoves == [] and computerValidMoves == []:\r\n            return board # No one can move, so end the game.\r\n\r\n        elif turn == \'player\': # Player\'s turn\r\n            if playerValidMoves != []:\r\n                #if showHints:\r\n                #    validMovesBoard = getBoardWithValidMoves(board, playerTile)\r\n                #    drawBoard(validMovesBoard)\r\n                #else:\r\n                    #drawBoard(board)\r\n                #printScore(board, playerTile, computerTile)\r\n\r\n                move = getCornerBestMove(board, playerTile)\r\n                #if move == \'quit\':\r\n                #    print(\'Thanks for playing!\')\r\n                #    sys.exit() # Terminate the program.\r\n                #elif move == \'hints\':\r\n                #    showHints = not showHints\r\n                #    continue\r\n                #else:\r\n                makeMove(board, playerTile, move[0], move[1])\r\n            turn = \'computer\'\r\n\r\n        elif turn == \'computer\': # Computer\'s turn\r\n            if computerValidMoves != []:\r\n                #drawBoard(board)\r\n                #printScore(board, playerTile, computerTile)\r\n\r\n                #input(\'Press Enter to see the computer\\\'s move.\')\r\n                move = getWorstMove(board, computerTile)\r\n                makeMove(board, computerTile, move[0], move[1])\r\n            turn = \'player\'\r\n\r\nNUM_GAMES = 250\r\nxWins = oWins = ties = 0\r\nprint(\'Welcome to Reversegam!\')\r\n\r\nplayerTile, computerTile = [\'X\', \'O\'] #enterPlayerTile()\r\n\r\nfor i in range(NUM_GAMES): #while True:\r\n    finalBoard = playGame(playerTile, computerTile)\r\n\r\n    # Display the final score.\r\n    #drawBoard(finalBoard)\r\n    scores = getScoreOfBoard(finalBoard)\r\n    print(\'#%s: X scored %s points. O scored %s points.\' % (i + 1, scores[\'X\'], scores[\'O\']))\r\n    if scores[playerTile] > scores[computerTile]:\r\n        xWins += 1 #print(\'You beat the computer by %s points! Congratulations!\' % (scores[playerTile] - scores[computerTile]))\r\n    elif scores[playerTile] < scores[computerTile]:\r\n        oWins += 1 #print(\'You lost. The computer beat you by %s points.\' % (scores[computerTile] - scores[playerTile]))\r\n    else:\r\n        ties += 1 #print(\'The game was a tie!\')\r\n\r\n    #print(\'Do you want to play again? (yes or no)\')\r\n    #if not input().lower().startswith(\'y\'):\r\n    #    break\r\n\r\nprint(\'X wins: %s (%s%%)\' % (xWins, round(xWins \/ NUM_GAMES * 100, 1)))\r\nprint(\'O wins: %s (%s%%)\' % (oWins, round(oWins \/ NUM_GAMES * 100, 1)))\r\nprint(\'Ties:   %s (%s%%)\' % (ties, round(ties \/ NUM_GAMES * 100, 1)))\r\n",
    "animation":"import pygame, sys, time\r\nfrom pygame.locals import *\r\n\r\n# Set up pygame.\r\npygame.init()\r\n\r\n# Set up the window.\r\nWINDOWWIDTH = 400\r\nWINDOWHEIGHT = 400\r\nwindowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT), 0, 32)\r\npygame.display.set_caption(\'Animation\')\r\n\r\n# Set up direction variables.\r\nDOWNLEFT = \'downleft\'\r\nDOWNRIGHT = \'downright\'\r\nUPLEFT = \'upleft\'\r\nUPRIGHT = \'upright\'\r\n\r\nMOVESPEED = 4\r\n\r\n# Set up the colors.\r\nWHITE = (255, 255, 255)\r\nRED = (255, 0, 0)\r\nGREEN = (0, 255, 0)\r\nBLUE = (0, 0, 255)\r\n\r\n# Set up the box data structure.\r\nb1 = {\'rect\':pygame.Rect(300, 80, 50, 100), \'color\':RED, \'dir\':UPRIGHT}\r\nb2 = {\'rect\':pygame.Rect(200, 200, 20, 20), \'color\':GREEN, \'dir\':UPLEFT}\r\nb3 = {\'rect\':pygame.Rect(100, 150, 60, 60), \'color\':BLUE, \'dir\':DOWNLEFT}\r\nboxes = [b1, b2, b3]\r\n\r\n# Run the game loop.\r\nwhile True:\r\n    # Check for the QUIT event.\r\n    for event in pygame.event.get():\r\n        if event.type == QUIT:\r\n            pygame.quit()\r\n            sys.exit()\r\n\r\n    # Draw the white background onto the surface.\r\n    windowSurface.fill(WHITE)\r\n\r\n    for b in boxes:\r\n        # Move the box data structure.\r\n        if b[\'dir\'] == DOWNLEFT:\r\n            b[\'rect\'].left -= MOVESPEED\r\n            b[\'rect\'].top += MOVESPEED\r\n        if b[\'dir\'] == DOWNRIGHT:\r\n            b[\'rect\'].left += MOVESPEED\r\n            b[\'rect\'].top += MOVESPEED\r\n        if b[\'dir\'] == UPLEFT:\r\n            b[\'rect\'].left -= MOVESPEED\r\n            b[\'rect\'].top -= MOVESPEED\r\n        if b[\'dir\'] == UPRIGHT:\r\n            b[\'rect\'].left += MOVESPEED\r\n            b[\'rect\'].top -= MOVESPEED\r\n\r\n        # Check whether the box has moved out of the window.\r\n        if b[\'rect\'].top < 0:\r\n            # The box has moved past the top.\r\n            if b[\'dir\'] == UPLEFT:\r\n                b[\'dir\'] = DOWNLEFT\r\n            if b[\'dir\'] == UPRIGHT:\r\n                b[\'dir\'] = DOWNRIGHT\r\n        if b[\'rect\'].bottom > WINDOWHEIGHT:\r\n            # The box has moved past the bottom.\r\n            if b[\'dir\'] == DOWNLEFT:\r\n                b[\'dir\'] = UPLEFT\r\n            if b[\'dir\'] == DOWNRIGHT:\r\n                b[\'dir\'] = UPRIGHT\r\n        if b[\'rect\'].left < 0:\r\n            # The box has moved past the left side.\r\n            if b[\'dir\'] == DOWNLEFT:\r\n                b[\'dir\'] = DOWNRIGHT\r\n            if b[\'dir\'] == UPLEFT:\r\n                b[\'dir\'] = UPRIGHT\r\n        if b[\'rect\'].right > WINDOWWIDTH:\r\n            # The box has moved past the right side.\r\n            if b[\'dir\'] == DOWNRIGHT:\r\n                b[\'dir\'] = DOWNLEFT\r\n            if b[\'dir\'] == UPRIGHT:\r\n                b[\'dir\'] = UPLEFT\r\n\r\n        # Draw the box onto the surface.\r\n        pygame.draw.rect(windowSurface, b[\'color\'], b[\'rect\'])\r\n\r\n    # Draw the window onto the screen.\r\n    pygame.display.update()\r\n    time.sleep(0.02)\r\n",
    "bagels":"import random\r\n\r\nNUM_DIGITS = 3\r\nMAX_GUESS = 10\r\n\r\ndef getSecretNum():\r\n    # Returns a string of unique random digits that is NUM_DIGITS long.\r\n    numbers = list(range(10))\r\n    random.shuffle(numbers)\r\n    secretNum = \'\'\r\n    for i in range(NUM_DIGITS):\r\n        secretNum += str(numbers[i])\r\n    return secretNum\r\n\r\ndef getClues(guess, secretNum):\r\n    # Returns a string with the Pico, Fermi, & Bagels clues to the user.\r\n    if guess == secretNum:\r\n        return \'You got it!\'\r\n\r\n    clues = []\r\n    for i in range(len(guess)):\r\n        if guess[i] == secretNum[i]:\r\n            clues.append(\'Fermi\')\r\n        elif guess[i] in secretNum:\r\n            clues.append(\'Pico\')\r\n    if len(clues) == 0:\r\n        return \'Bagels\'\r\n\r\n    clues.sort()\r\n    return \' \'.join(clues)\r\n\r\ndef isOnlyDigits(num):\r\n    # Returns True if num is a string of only digits. Otherwise, returns False.\r\n    if num == \'\':\r\n        return False\r\n\r\n    for i in num:\r\n        if i not in \'0 1 2 3 4 5 6 7 8 9\'.split():\r\n            return False\r\n\r\n    return True\r\n\r\n\r\nprint(\'I am thinking of a %s-digit number. Try to guess what it is.\' % (NUM_DIGITS))\r\nprint(\'The clues I give are...\')\r\nprint(\'When I say:    That means:\')\r\nprint(\'  Bagels       None of the digits is correct.\')\r\nprint(\'  Pico         One digit is correct but in the wrong position.\')\r\nprint(\'  Fermi        One digit is correct and in the right position.\')\r\n\r\nwhile True:\r\n    secretNum = getSecretNum()\r\n    print(\'I have thought up a number. You have %s guesses to get it.\' % (MAX_GUESS))\r\n\r\n    guessesTaken = 1\r\n    while guessesTaken <= MAX_GUESS:\r\n        guess = \'\'\r\n        while len(guess) != NUM_DIGITS or not isOnlyDigits(guess):\r\n            print(\'Guess #%s: \' % (guessesTaken))\r\n            guess = input()\r\n\r\n        print(getClues(guess, secretNum))\r\n        guessesTaken += 1\r\n\r\n        if guess == secretNum:\r\n            break\r\n        if guessesTaken > MAX_GUESS:\r\n            print(\'You ran out of guesses. The answer was %s.\' % (secretNum))\r\n\r\n    print(\'Do you want to play again? (yes or no)\')\r\n    if not input().lower().startswith(\'y\'):\r\n        break\r\n",
    "buggy":"import random\r\nnumber1 = random.randint(1, 10)\r\nnumber2 = random.randint(1, 10)\r\nprint(\'What is \' + str(number1) + \' + \' + str(number2) + \'?\')\r\nanswer = input()\r\nif answer == number1 + number2:\r\n    print(\'Correct!\')\r\nelse:\r\n    print(\'Nope! The answer is \' + str(number1 + number2))\r\n",
    "cipher":"# Caesar Cipher\r\nSYMBOLS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\'\r\nMAX_KEY_SIZE = len(SYMBOLS)\r\n\r\ndef getMode():\r\n    while True:\r\n        print(\'Do you wish to encrypt or decrypt a message?\')\r\n        mode = input().lower()\r\n        if mode in [\'encrypt\', \'e\', \'decrypt\', \'d\']:\r\n            return mode\r\n        else:\r\n            print(\'Enter either \"encrypt\" or \"e\" or \"decrypt\" or \"d\".\')\r\n\r\ndef getMessage():\r\n    print(\'Enter your message:\')\r\n    return input()\r\n\r\ndef getKey():\r\n    key = 0\r\n    while True:\r\n        print(\'Enter the key number (1-%s)\' % (MAX_KEY_SIZE))\r\n        key = int(input())\r\n        if (key >= 1 and key <= MAX_KEY_SIZE):\r\n            return key\r\n\r\ndef getTranslatedMessage(mode, message, key):\r\n    if mode[0] == \'d\':\r\n        key = -key\r\n    translated = \'\'\r\n\r\n    for symbol in message:\r\n        symbolIndex = SYMBOLS.find(symbol)\r\n        if symbolIndex == -1: # Symbol not found in SYMBOLS.\r\n            # Just add this symbol without any change.\r\n            translated += symbol\r\n        else:\r\n            # Encrypt or decrypt\r\n            symbolIndex += key\r\n\r\n            if symbolIndex >= len(SYMBOLS):\r\n                symbolIndex -= len(SYMBOLS)\r\n            elif symbolIndex < 0:\r\n                symbolIndex += len(SYMBOLS)\r\n\r\n            translated += SYMBOLS[symbolIndex]\r\n    return translated\r\n\r\nmode = getMode()\r\nmessage = getMessage()\r\nkey = getKey()\r\nprint(\'Your translated text is:\')\r\nprint(getTranslatedMessage(mode, message, key))\r\n",
    "coinFlips":"import random\r\nprint(\'I will flip a coin 1000 times. Guess how many times it will come up heads. (Press enter to begin)\')\r\ninput()\r\nflips = 0\r\nheads = 0\r\nwhile flips < 1000:\r\n    if random.randint(0, 1) == 1:\r\n        heads = heads + 1\r\n    flips = flips + 1\r\n\r\n    if flips == 900:\r\n        print(\'900 flips and there have been \' + str(heads) + \' heads.\')\r\n    if flips == 100:\r\n        print(\'At 100 tosses, heads has come up \' + str(heads) + \' times so far.\')\r\n    if flips == 500:\r\n        print(\'Halfway done, and heads has come up \' + str(heads) + \' times.\')\r\n\r\nprint()\r\nprint(\'Out of 1000 coin tosses, heads came up \' + str(heads) + \' times!\')\r\nprint(\'Were you close?\')",
    "collisionDetection":"import pygame, sys, random\r\nfrom pygame.locals import *\r\n\r\n# Set up pygame.\r\npygame.init()\r\nmainClock = pygame.time.Clock()\r\n\r\n# Set up the window.\r\nWINDOWWIDTH = 400\r\nWINDOWHEIGHT = 400\r\nwindowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT), 0, 32)\r\npygame.display.set_caption(\'Input\')\r\n\r\n# Set up the colors.\r\nBLACK = (0, 0, 0)\r\nGREEN = (0, 255, 0)\r\nWHITE = (255, 255, 255)\r\n\r\n# Set up the player and food data structure.\r\nfoodCounter = 0\r\nNEWFOOD = 40\r\nFOODSIZE = 20\r\nplayer = pygame.Rect(300, 100, 50, 50)\r\nfoods = []\r\nfor i in range(20):\r\n    foods.append(pygame.Rect(random.randint(0, WINDOWWIDTH - FOODSIZE), random.randint(0, WINDOWHEIGHT - FOODSIZE), FOODSIZE, FOODSIZE))\r\n\r\n# Set up movement variables.\r\nmoveLeft = False\r\nmoveRight = False\r\nmoveUp = False\r\nmoveDown = False\r\n\r\nMOVESPEED = 6\r\n\r\n\r\n# Run the game loop.\r\nwhile True:\r\n    # Check for events.\r\n    for event in pygame.event.get():\r\n        if event.type == QUIT:\r\n            pygame.quit()\r\n            sys.exit()\r\n        if event.type == KEYDOWN:\r\n            # Change the keyboard variables.\r\n            if event.key == K_LEFT or event.key == K_a:\r\n                moveRight = False\r\n                moveLeft = True\r\n            if event.key == K_RIGHT or event.key == K_d:\r\n                moveLeft = False\r\n                moveRight = True\r\n            if event.key == K_UP or event.key == K_w:\r\n                moveDown = False\r\n                moveUp = True\r\n            if event.key == K_DOWN or event.key == K_s:\r\n                moveUp = False\r\n                moveDown = True\r\n        if event.type == KEYUP:\r\n            if event.key == K_ESCAPE:\r\n                pygame.quit()\r\n                sys.exit()\r\n            if event.key == K_LEFT or event.key == K_a:\r\n                moveLeft = False\r\n            if event.key == K_RIGHT or event.key == K_d:\r\n                moveRight = False\r\n            if event.key == K_UP or event.key == K_w:\r\n                moveUp = False\r\n            if event.key == K_DOWN or event.key == K_s:\r\n                moveDown = False\r\n            if event.key == K_x:\r\n                player.top = random.randint(0, WINDOWHEIGHT - player.height)\r\n                player.left = random.randint(0, WINDOWWIDTH - player.width)\r\n\r\n        if event.type == MOUSEBUTTONUP:\r\n            foods.append(pygame.Rect(event.pos[0], event.pos[1], FOODSIZE, FOODSIZE))\r\n\r\n    foodCounter += 1\r\n    if foodCounter >= NEWFOOD:\r\n        # Add new food.\r\n        foodCounter = 0\r\n        foods.append(pygame.Rect(random.randint(0, WINDOWWIDTH - FOODSIZE), random.randint(0, WINDOWHEIGHT - FOODSIZE), FOODSIZE, FOODSIZE))\r\n\r\n    # Draw the white background onto the surface.\r\n    windowSurface.fill(WHITE)\r\n\r\n    # Move the player.\r\n    if moveDown and player.bottom < WINDOWHEIGHT:\r\n        player.top += MOVESPEED\r\n    if moveUp and player.top > 0:\r\n        player.top -= MOVESPEED\r\n    if moveLeft and player.left > 0:\r\n        player.left -= MOVESPEED\r\n    if moveRight and player.right < WINDOWWIDTH:\r\n        player.right += MOVESPEED\r\n\r\n    # Draw the player onto the surface.\r\n    pygame.draw.rect(windowSurface, BLACK, player)\r\n\r\n    # Check if the player has intersected with any food squares.\r\n    for food in foods[:]:\r\n        if player.colliderect(food):\r\n            foods.remove(food)\r\n\r\n    # Draw the food.\r\n    for i in range(len(foods)):\r\n        pygame.draw.rect(windowSurface, GREEN, foods[i])\r\n\r\n    # Draw the window onto the screen.\r\n    pygame.display.update()\r\n    mainClock.tick(40 )\r\n",
    "dodger":"import pygame, random, sys\r\nfrom pygame.locals import *\r\n\r\nWINDOWWIDTH = 600\r\nWINDOWHEIGHT = 600\r\nTEXTCOLOR = (0, 0, 0)\r\nBACKGROUNDCOLOR = (255, 255, 255)\r\nFPS = 60\r\nBADDIEMINSIZE = 10\r\nBADDIEMAXSIZE = 40\r\nBADDIEMINSPEED = 1\r\nBADDIEMAXSPEED = 8\r\nADDNEWBADDIERATE = 6\r\nPLAYERMOVERATE = 5\r\n\r\ndef terminate():\r\n    pygame.quit()\r\n    sys.exit()\r\n\r\ndef waitForPlayerToPressKey():\r\n    while True:\r\n        for event in pygame.event.get():\r\n            if event.type == QUIT:\r\n                terminate()\r\n            if event.type == KEYDOWN:\r\n                if event.key == K_ESCAPE: # Pressing ESC quits.\r\n                    terminate()\r\n                return\r\n\r\ndef playerHasHitBaddie(playerRect, baddies):\r\n    for b in baddies:\r\n        if playerRect.colliderect(b[\'rect\']):\r\n            return True\r\n    return False\r\n\r\ndef drawText(text, font, surface, x, y):\r\n    textobj = font.render(text, 1, TEXTCOLOR)\r\n    textrect = textobj.get_rect()\r\n    textrect.topleft = (x, y)\r\n    surface.blit(textobj, textrect)\r\n\r\n# Set up pygame, the window, and the mouse cursor.\r\npygame.init()\r\nmainClock = pygame.time.Clock()\r\nwindowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))\r\npygame.display.set_caption(\'Dodger\')\r\npygame.mouse.set_visible(False)\r\n\r\n# Set up the fonts.\r\nfont = pygame.font.SysFont(None, 48)\r\n\r\n# Set up sounds.\r\ngameOverSound = pygame.mixer.Sound(\'gameover.wav\')\r\npygame.mixer.music.load(\'background.mid\')\r\n\r\n# Set up images.\r\nplayerImage = pygame.image.load(\'player.png\')\r\nplayerRect = playerImage.get_rect()\r\nbaddieImage = pygame.image.load(\'baddie.png\')\r\n\r\n# Show the \"Start\" screen.\r\nwindowSurface.fill(BACKGROUNDCOLOR)\r\ndrawText(\'Dodger\', font, windowSurface, (WINDOWWIDTH \/ 3), (WINDOWHEIGHT \/ 3))\r\ndrawText(\'Press a key to start.\', font, windowSurface, (WINDOWWIDTH \/ 3) - 30, (WINDOWHEIGHT \/ 3) + 50)\r\npygame.display.update()\r\nwaitForPlayerToPressKey()\r\n\r\ntopScore = 0\r\nwhile True:\r\n    # Set up the start of the game.\r\n    baddies = []\r\n    score = 0\r\n    playerRect.topleft = (WINDOWWIDTH \/ 2, WINDOWHEIGHT - 50)\r\n    moveLeft = moveRight = moveUp = moveDown = False\r\n    reverseCheat = slowCheat = False\r\n    baddieAddCounter = 0\r\n    pygame.mixer.music.play(-1, 0.0)\r\n\r\n    while True: # The game loop runs while the game part is playing.\r\n        score += 1 # Increase score.\r\n\r\n        for event in pygame.event.get():\r\n            if event.type == QUIT:\r\n                terminate()\r\n\r\n            if event.type == KEYDOWN:\r\n                if event.key == K_z:\r\n                    reverseCheat = True\r\n                if event.key == K_x:\r\n                    slowCheat = True\r\n                if event.key == K_LEFT or event.key == K_a:\r\n                    moveRight = False\r\n                    moveLeft = True\r\n                if event.key == K_RIGHT or event.key == K_d:\r\n                    moveLeft = False\r\n                    moveRight = True\r\n                if event.key == K_UP or event.key == K_w:\r\n                    moveDown = False\r\n                    moveUp = True\r\n                if event.key == K_DOWN or event.key == K_s:\r\n                    moveUp = False\r\n                    moveDown = True\r\n\r\n            if event.type == KEYUP:\r\n                if event.key == K_z:\r\n                    reverseCheat = False\r\n                    score = 0\r\n                if event.key == K_x:\r\n                    slowCheat = False\r\n                    score = 0\r\n                if event.key == K_ESCAPE:\r\n                        terminate()\r\n\r\n                if event.key == K_LEFT or event.key == K_a:\r\n                    moveLeft = False\r\n                if event.key == K_RIGHT or event.key == K_d:\r\n                    moveRight = False\r\n                if event.key == K_UP or event.key == K_w:\r\n                    moveUp = False\r\n                if event.key == K_DOWN or event.key == K_s:\r\n                    moveDown = False\r\n\r\n            if event.type == MOUSEMOTION:\r\n                # If the mouse moves, move the player where to the cursor.\r\n                playerRect.centerx = event.pos[0]\r\n                playerRect.centery = event.pos[1]\r\n        # Add new baddies at the top of the screen, if needed.\r\n        if not reverseCheat and not slowCheat:\r\n            baddieAddCounter += 1\r\n        if baddieAddCounter == ADDNEWBADDIERATE:\r\n            baddieAddCounter = 0\r\n            baddieSize = random.randint(BADDIEMINSIZE, BADDIEMAXSIZE)\r\n            newBaddie = {\'rect\': pygame.Rect(random.randint(0, WINDOWWIDTH - baddieSize), 0 - baddieSize, baddieSize, baddieSize),\r\n                        \'speed\': random.randint(BADDIEMINSPEED, BADDIEMAXSPEED),\r\n                        \'surface\':pygame.transform.scale(baddieImage, (baddieSize, baddieSize)),\r\n                        }\r\n\r\n            baddies.append(newBaddie)\r\n\r\n        # Move the player around.\r\n        if moveLeft and playerRect.left > 0:\r\n            playerRect.move_ip(-1 * PLAYERMOVERATE, 0)\r\n        if moveRight and playerRect.right < WINDOWWIDTH:\r\n            playerRect.move_ip(PLAYERMOVERATE, 0)\r\n        if moveUp and playerRect.top > 0:\r\n            playerRect.move_ip(0, -1 * PLAYERMOVERATE)\r\n        if moveDown and playerRect.bottom < WINDOWHEIGHT:\r\n            playerRect.move_ip(0, PLAYERMOVERATE)\r\n\r\n        # Move the baddies down.\r\n        for b in baddies:\r\n            if not reverseCheat and not slowCheat:\r\n                b[\'rect\'].move_ip(0, b[\'speed\'])\r\n            elif reverseCheat:\r\n                b[\'rect\'].move_ip(0, -5)\r\n            elif slowCheat:\r\n                b[\'rect\'].move_ip(0, 1)\r\n\r\n        # Delete baddies that have fallen past the bottom.\r\n        for b in baddies[:]:\r\n            if b[\'rect\'].top > WINDOWHEIGHT:\r\n                baddies.remove(b)\r\n\r\n        # Draw the game world on the window.\r\n        windowSurface.fill(BACKGROUNDCOLOR)\r\n\r\n        # Draw the score and top score.\r\n        drawText(\'Score: %s\' % (score), font, windowSurface, 10, 0)\r\n        drawText(\'Top Score: %s\' % (topScore), font, windowSurface, 10, 40)\r\n\r\n        # Draw the player\'s rectangle.\r\n        windowSurface.blit(playerImage, playerRect)\r\n\r\n        # Draw each baddie.\r\n        for b in baddies:\r\n            windowSurface.blit(b[\'surface\'], b[\'rect\'])\r\n\r\n        pygame.display.update()\r\n\r\n        # Check if any of the baddies have hit the player.\r\n        if playerHasHitBaddie(playerRect, baddies):\r\n            if score > topScore:\r\n                topScore = score # set new top score\r\n            break\r\n\r\n        mainClock.tick(FPS)\r\n\r\n    # Stop the game and show the \"Game Over\" screen.\r\n    pygame.mixer.music.stop()\r\n    gameOverSound.play()\r\n\r\n    drawText(\'GAME OVER\', font, windowSurface, (WINDOWWIDTH \/ 3), (WINDOWHEIGHT \/ 3))\r\n    drawText(\'Press a key to play again.\', font, windowSurface, (WINDOWWIDTH \/ 3) - 80, (WINDOWHEIGHT \/ 3) + 50)\r\n    pygame.display.update()\r\n    waitForPlayerToPressKey()\r\n\r\n    gameOverSound.stop()\r\n",
    "dragon":"import random\r\nimport time\r\n\r\ndef displayIntro():\r\n    print(\'\'\'You are in a land full of dragons. In front of you,\r\nyou see two caves. In one cave, the dragon is friendly\r\nand will share his treasure with you. The other dragon\r\nis greedy and hungry, and will eat you on sight.\'\'\')\r\n    print()\r\n\r\ndef chooseCave():\r\n    cave = \'\'\r\n    while cave != \'1\' and cave != \'2\':\r\n        print(\'Which cave will you go into? (1 or 2)\')\r\n        cave = input()\r\n\r\n    return cave\r\n\r\ndef checkCave(chosenCave):\r\n    print(\'You approach the cave...\')\r\n    time.sleep(2)\r\n    print(\'It is dark and spooky...\')\r\n    time.sleep(2)\r\n    print(\'A large dragon jumps out in front of you! He opens his jaws and...\')\r\n    print()\r\n    time.sleep(2)\r\n\r\n    friendlyCave = random.randint(1, 2)\r\n\r\n    if chosenCave == str(friendlyCave):\r\n         print(\'Gives you his treasure!\')\r\n    else:\r\n         print(\'Gobbles you down in one bite!\')\r\n\r\nplayAgain = \'yes\'\r\nwhile playAgain == \'yes\' or playAgain == \'y\':\r\n    displayIntro()\r\n    caveNumber = chooseCave()\r\n    checkCave(caveNumber)\r\n\r\n    print(\'Do you want to play again? (yes or no)\')\r\n    playAgain = input()\r\n",
    "guess":"# This is a Guess the Number game.\r\nimport random\r\n\r\nguessesTaken = 0\r\n\r\nprint(\'Hello! What is your name?\')\r\nmyName = input()\r\n\r\nnumber = random.randint(1, 20)\r\nprint(\'Well, \' + myName + \', I am thinking of a number between 1 and 20.\')\r\n\r\nfor guessesTaken in range(6):\r\n    print(\'Take a guess.\') # Four spaces in front of \"print\".\r\n    guess = input()\r\n    guess = int(guess)\r\n\r\n    if guess < number:\r\n        print(\'Your guess is too low.\') # Eight spaces in front of \"print\"\r\n\r\n    if guess > number:\r\n        print(\'Your guess is too high.\')\r\n\r\n    if guess == number:\r\n        break\r\n\r\nif guess == number:\r\n    guessesTaken = str(guessesTaken + 1)\r\n    print(\'Good job, \' + myName + \'! You guessed my number in \' + guessesTaken + \' guesses!\')\r\n\r\nif guess != number:\r\n    number = str(number)\r\n    print(\'Nope. The number I was thinking of was \' + number + \'.\')\r\n",
    "hangman":"import random\r\nHANGMAN_PICS = [\'\'\'\r\n  +---+\r\n      |\r\n      |\r\n      |\r\n     ===\'\'\', \'\'\'\r\n  +---+\r\n  O   |\r\n      |\r\n      |\r\n     ===\'\'\', \'\'\'\r\n  +---+\r\n  O   |\r\n  |   |\r\n      |\r\n     ===\'\'\', \'\'\'\r\n  +---+\r\n  O   |\r\n \/|   |\r\n      |\r\n     ===\'\'\', \'\'\'\r\n  +---+\r\n  O   |\r\n \/|\\  |\r\n      |\r\n     ===\'\'\', \'\'\'\r\n  +---+\r\n  O   |\r\n \/|\\  |\r\n \/    |\r\n     ===\'\'\', \'\'\'\r\n  +---+\r\n  O   |\r\n \/|\\  |\r\n \/ \\  |\r\n     ===\'\'\']\r\nwords = \'ant baboon badger bat bear beaver camel cat clam cobra cougar coyote crow deer dog donkey duck eagle ferret fox frog goat goose hawk lion lizard llama mole monkey moose mouse mule newt otter owl panda parrot pigeon python rabbit ram rat raven rhino salmon seal shark sheep skunk sloth snake spider stork swan tiger toad trout turkey turtle weasel whale wolf wombat zebra\'.split()\r\n\r\ndef getRandomWord(wordList):\r\n    # This function returns a random string from the passed list of strings.\r\n    wordIndex = random.randint(0, len(wordList) - 1)\r\n    return wordList[wordIndex]\r\n\r\ndef displayBoard(missedLetters, correctLetters, secretWord):\r\n    print(HANGMAN_PICS[len(missedLetters)])\r\n    print()\r\n\r\n    print(\'Missed letters:\', end=\' \')\r\n    for letter in missedLetters:\r\n        print(letter, end=\' \')\r\n    print()\r\n\r\n    blanks = \'_\' * len(secretWord)\r\n\r\n    for i in range(len(secretWord)): # replace blanks with correctly guessed letters\r\n        if secretWord[i] in correctLetters:\r\n            blanks = blanks[:i] + secretWord[i] + blanks[i+1:]\r\n\r\n    for letter in blanks: # show the secret word with spaces in between each letter\r\n        print(letter, end=\' \')\r\n    print()\r\n\r\ndef getGuess(alreadyGuessed):\r\n    # Returns the letter the player entered. This function makes sure the player entered a single letter and not something else.\r\n    while True:\r\n        print(\'Guess a letter.\')\r\n        guess = input()\r\n        guess = guess.lower()\r\n        if len(guess) != 1:\r\n            print(\'Please enter a single letter.\')\r\n        elif guess in alreadyGuessed:\r\n            print(\'You have already guessed that letter. Choose again.\')\r\n        elif guess not in \'abcdefghijklmnopqrstuvwxyz\':\r\n            print(\'Please enter a LETTER.\')\r\n        else:\r\n            return guess\r\n\r\ndef playAgain():\r\n    # This function returns True if the player wants to play again; otherwise, it returns False.\r\n    print(\'Do you want to play again? (yes or no)\')\r\n    return input().lower().startswith(\'y\')\r\n\r\n\r\nprint(\'H A N G M A N\')\r\nmissedLetters = \'\'\r\ncorrectLetters = \'\'\r\nsecretWord = getRandomWord(words)\r\ngameIsDone = False\r\n\r\nwhile True:\r\n    displayBoard(missedLetters, correctLetters, secretWord)\r\n\r\n    # Let the player enter a letter.\r\n    guess = getGuess(missedLetters + correctLetters)\r\n\r\n    if guess in secretWord:\r\n        correctLetters = correctLetters + guess\r\n\r\n        # Check if the player has won.\r\n        foundAllLetters = True\r\n        for i in range(len(secretWord)):\r\n            if secretWord[i] not in correctLetters:\r\n                foundAllLetters = False\r\n                break\r\n        if foundAllLetters:\r\n            print(\'Yes! The secret word is \"\' + secretWord + \'\"! You have won!\')\r\n            gameIsDone = True\r\n    else:\r\n        missedLetters = missedLetters + guess\r\n\r\n        # Check if player has guessed too many times and lost.\r\n        if len(missedLetters) == len(HANGMAN_PICS) - 1:\r\n            displayBoard(missedLetters, correctLetters, secretWord)\r\n            print(\'You have run out of guesses!\\nAfter \' + str(len(missedLetters)) + \' missed guesses and \' + str(len(correctLetters)) + \' correct guesses, the word was \"\' + secretWord + \'\"\')\r\n            gameIsDone = True\r\n\r\n    # Ask the player if they want to play again (but only if the game is done).\r\n    if gameIsDone:\r\n        if playAgain():\r\n            missedLetters = \'\'\r\n            correctLetters = \'\'\r\n            gameIsDone = False\r\n            secretWord = getRandomWord(words)\r\n        else:\r\n            break\r\n",
    "hangman2":"import random\r\nHANGMAN_PICS = [\'\'\'\r\n  +---+\r\n      |\r\n      |\r\n      |\r\n     ===\'\'\', \'\'\'\r\n  +---+\r\n  O   |\r\n      |\r\n      |\r\n     ===\'\'\', \'\'\'\r\n  +---+\r\n  O   |\r\n  |   |\r\n      |\r\n     ===\'\'\', \'\'\'\r\n  +---+\r\n  O   |\r\n \/|   |\r\n      |\r\n     ===\'\'\', \'\'\'\r\n  +---+\r\n  O   |\r\n \/|\\  |\r\n      |\r\n     ===\'\'\', \'\'\'\r\n  +---+\r\n  O   |\r\n \/|\\  |\r\n \/    |\r\n     ===\'\'\', \'\'\'\r\n  +---+\r\n  O   |\r\n \/|\\  |\r\n \/ \\  |\r\n     ===\'\'\', \'\'\'\r\n  +---+\r\n [O   |\r\n \/|\\  |\r\n \/ \\  |\r\n     ===\'\'\', \'\'\'\r\n  +---+\r\n [O]  |\r\n \/|\\  |\r\n \/ \\  |\r\n     ===\'\'\']\r\nwords = {\'Colors\':\'red orange yellow green blue indigo violet white black brown\'.split(),\r\n\'Shapes\':\'square triangle rectangle circle ellipse rhombus trapazoid chevron pentagon hexagon septagon octogon\'.split(),\r\n\'Fruits\':\'apple orange lemon lime pear watermelon grape grapefruit cherry banana cantalope mango strawberry tomato\'.split(),\r\n\'Animals\':\'bat bear beaver cat cougar crab deer dog donkey duck eagle fish frog goat leech lion lizard monkey moose mouse otter owl panda python rabbit rat shark sheep skunk squid tiger turkey turtle weasel whale wolf wombat zebra\'.split()}\r\n\r\ndef getRandomWord(wordDict):\r\n    # This function returns a random string from the passed dictionary of lists of strings, and the key also.\r\n    # First, randomly select a key from the dictionary:\r\n    wordKey = random.choice(list(wordDict.keys()))\r\n\r\n    # Second, randomly select a word from the key\'s list in the dictionary:\r\n    wordIndex = random.randint(0, len(wordDict[wordKey]) - 1)\r\n\r\n    return [wordDict[wordKey][wordIndex], wordKey]\r\n\r\ndef displayBoard(missedLetters, correctLetters, secretWord):\r\n    print(HANGMAN_PICS[len(missedLetters)])\r\n    print()\r\n\r\n    print(\'Missed letters:\', end=\' \')\r\n    for letter in missedLetters:\r\n        print(letter, end=\' \')\r\n    print()\r\n\r\n    blanks = \'_\' * len(secretWord)\r\n\r\n    for i in range(len(secretWord)): # replace blanks with correctly guessed letters\r\n        if secretWord[i] in correctLetters:\r\n            blanks = blanks[:i] + secretWord[i] + blanks[i+1:]\r\n\r\n    for letter in blanks: # show the secret word with spaces in between each letter\r\n        print(letter, end=\' \')\r\n    print()\r\n\r\ndef getGuess(alreadyGuessed):\r\n    # Returns the letter the player entered. This function makes sure the player entered a single letter, and not something else.\r\n    while True:\r\n        print(\'Guess a letter.\')\r\n        guess = input()\r\n        guess = guess.lower()\r\n        if len(guess) != 1:\r\n            print(\'Please enter a single letter.\')\r\n        elif guess in alreadyGuessed:\r\n            print(\'You have already guessed that letter. Choose again.\')\r\n        elif guess not in \'abcdefghijklmnopqrstuvwxyz\':\r\n            print(\'Please enter a LETTER.\')\r\n        else:\r\n            return guess\r\n\r\ndef playAgain():\r\n    # This function returns True if the player wants to play again, otherwise it returns False.\r\n    print(\'Do you want to play again? (yes or no)\')\r\n    return input().lower().startswith(\'y\')\r\n\r\n\r\nprint(\'H A N G M A N\')\r\n\r\ndifficulty = \'\'\r\nwhile difficulty not in \'EMH\':\r\n  print(\'Enter difficulty: E - Easy, M - Medium, H - Hard\')\r\n  difficulty = input().upper()\r\nif difficulty == \'M\':\r\n    del HANGMAN_PICS[8]\r\n    del HANGMAN_PICS[7]\r\nif difficulty == \'H\':\r\n    del HANGMAN_PICS[8]\r\n    del HANGMAN_PICS[7]\r\n    del HANGMAN_PICS[5]\r\n    del HANGMAN_PICS[3]\r\n\r\nmissedLetters = \'\'\r\ncorrectLetters = \'\'\r\nsecretWord, secretSet = getRandomWord(words)\r\ngameIsDone = False\r\n\r\nwhile True:\r\n    print(\'The secret word is in the set: \' + secretSet)\r\n    displayBoard(missedLetters, correctLetters, secretWord)\r\n\r\n    # Let the player type in a letter.\r\n    guess = getGuess(missedLetters + correctLetters)\r\n\r\n    if guess in secretWord:\r\n        correctLetters = correctLetters + guess\r\n\r\n        # Check if the player has won\r\n        foundAllLetters = True\r\n        for i in range(len(secretWord)):\r\n            if secretWord[i] not in correctLetters:\r\n                foundAllLetters = False\r\n                break\r\n        if foundAllLetters:\r\n            print(\'Yes! The secret word is \"\' + secretWord + \'\"! You have won!\')\r\n            gameIsDone = True\r\n    else:\r\n        missedLetters = missedLetters + guess\r\n\r\n        # Check if player has guessed too many times and lost.\r\n        if len(missedLetters) == len(HANGMAN_PICS) - 1:\r\n            displayBoard(missedLetters, correctLetters, secretWord)\r\n            print(\'You have run out of guesses!\\nAfter \' + str(len(missedLetters)) + \' missed guesses and \' + str(len(correctLetters)) + \' correct guesses, the word was \"\' + secretWord + \'\"\')\r\n            gameIsDone = True\r\n\r\n    # Ask the player if they want to play again (but only if the game is done).\r\n    if gameIsDone:\r\n        if playAgain():\r\n            missedLetters = \'\'\r\n            correctLetters = \'\'\r\n            gameIsDone = False\r\n            secretWord, secretSet = getRandomWord(words)\r\n        else:\r\n            break\r\n",
    "hello":"# This program says hello and asks for my name.\r\nprint(\'Hello world!\')\r\nprint(\'What is your name?\')\r\nmyName = input()\r\nprint(\'It is good to meet you, \' + myName)",
    "jokes":"print(\'What do you get when you cross a snowman with a vampire?\')\r\ninput()\r\nprint(\'Frostbite!\')\r\nprint()\r\nprint(\'What do dentists call an astronaut\\\'s cavity?\')\r\ninput()\r\nprint(\'A black hole!\')\r\nprint()\r\nprint(\'Knock knock.\')\r\ninput()\r\nprint(\"Who\'s there?\")\r\ninput()\r\nprint(\'Interrupting cow.\')\r\ninput()\r\nprint(\'Interrupting cow wh\', end=\'\')\r\nprint(\'-MOO!\')\r\n",
    "pygameHelloWorld":"import pygame, sys\r\nfrom pygame.locals import *\r\n\r\n# Set up pygame.\r\npygame.init()\r\n\r\n# Set up the window.\r\nwindowSurface = pygame.display.set_mode((500, 400), 0, 32)\r\npygame.display.set_caption(\'Hello world!\')\r\n\r\n# Set up the colors.\r\nBLACK = (0, 0, 0)\r\nWHITE = (255, 255, 255)\r\nRED = (255, 0, 0)\r\nGREEN = (0, 255, 0)\r\nBLUE = (0, 0, 255)\r\n\r\n# Set up fonts.\r\nbasicFont = pygame.font.SysFont(None, 48)\r\n\r\n# Set up the text.\r\ntext = basicFont.render(\'Hello world!\', True, WHITE, BLUE)\r\ntextRect = text.get_rect()\r\ntextRect.centerx = windowSurface.get_rect().centerx\r\ntextRect.centery = windowSurface.get_rect().centery\r\n\r\n# Draw the white background onto the surface.\r\nwindowSurface.fill(WHITE)\r\n\r\n# Draw a green polygon onto the surface.\r\npygame.draw.polygon(windowSurface, GREEN, ((146, 0), (291, 106), (236, 277), (56, 277), (0, 106)))\r\n\r\n# Draw some blue lines onto the surface.\r\npygame.draw.line(windowSurface, BLUE, (60, 60), (120, 60), 4)\r\npygame.draw.line(windowSurface, BLUE, (120, 60), (60, 120))\r\npygame.draw.line(windowSurface, BLUE, (60, 120), (120, 120), 4)\r\n\r\n# draw a blue circle onto the surface.\r\npygame.draw.circle(windowSurface, BLUE, (300, 50), 20, 0)\r\n\r\n# Draw a red ellipse onto the surface.\r\npygame.draw.ellipse(windowSurface, RED, (300, 250, 40, 80), 1)\r\n\r\n# Draw the text\'s background rectangle onto the surface.\r\npygame.draw.rect(windowSurface, RED, (textRect.left - 20, textRect.top - 20, textRect.width + 40, textRect.height + 40))\r\n\r\n# Get a pixel array of the surface.\r\npixArray = pygame.PixelArray(windowSurface)\r\npixArray[480][380] = BLACK\r\ndel pixArray\r\n\r\n# Draw the text onto the surface.\r\nwindowSurface.blit(text, textRect)\r\n\r\n# Draw the window onto the screen.\r\npygame.display.update()\r\n\r\n# Run the game loop.\r\nwhile True:\r\n    for event in pygame.event.get():\r\n        if event.type == QUIT:\r\n            pygame.quit()\r\n            sys.exit()\r\n",
    "reversegam":"# Reversegam: a clone of Othello\/Reversi\r\nimport random\r\nimport sys\r\nWIDTH = 8  # Board is 8 spaces wide\r\nHEIGHT = 8 # Board is 8 spaces tall\r\ndef drawBoard(board):\r\n    # This function prints the board that it was passed. Returns None.\r\n    print(\'  12345678\')\r\n    print(\' +--------+\')\r\n    for y in range(HEIGHT):\r\n        print(\'%s|\' % (y+1), end=\'\')\r\n        for x in range(WIDTH):\r\n            print(board[x][y], end=\'\')\r\n        print(\'|%s\' % (y+1))\r\n    print(\' +--------+\')\r\n    print(\'  12345678\')\r\n\r\ndef getNewBoard():\r\n    # Creates a brand-new, blank board data structure.\r\n    board = []\r\n    for i in range(WIDTH):\r\n        board.append([\' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \'])\r\n    return board\r\n\r\ndef isValidMove(board, tile, xstart, ystart):\r\n    # Returns False if the player\'s move on space xstart, ystart is invalid.\r\n    # If it is a valid move, returns a list of spaces that would become the player\'s if they made a move here.\r\n    if board[xstart][ystart] != \' \' or not isOnBoard(xstart, ystart):\r\n        return False\r\n\r\n    if tile == \'X\':\r\n        otherTile = \'O\'\r\n    else:\r\n        otherTile = \'X\'\r\n\r\n    tilesToFlip = []\r\n    for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:\r\n        x, y = xstart, ystart\r\n        x += xdirection # First step in the x direction\r\n        y += ydirection # First step in the y direction\r\n        while isOnBoard(x, y) and board[x][y] == otherTile:\r\n            # Keep moving in this x & y direction.\r\n            x += xdirection\r\n            y += ydirection\r\n            if isOnBoard(x, y) and board[x][y] == tile:\r\n                # There are pieces to flip over. Go in the reverse direction until we reach the original space, noting all the tiles along the way.\r\n                while True:\r\n                    x -= xdirection\r\n                    y -= ydirection\r\n                    if x == xstart and y == ystart:\r\n                        break\r\n                    tilesToFlip.append([x, y])\r\n\r\n    if len(tilesToFlip) == 0: # If no tiles were flipped, this is not a valid move.\r\n        return False\r\n    return tilesToFlip\r\n\r\ndef isOnBoard(x, y):\r\n    # Returns True if the coordinates are located on the board.\r\n    return x >= 0 and x <= WIDTH - 1 and y >= 0 and y <= HEIGHT - 1\r\n\r\ndef getBoardWithValidMoves(board, tile):\r\n    # Returns a new board with periods marking the valid moves the player can make.\r\n    boardCopy = getBoardCopy(board)\r\n\r\n    for x, y in getValidMoves(boardCopy, tile):\r\n        boardCopy[x][y] = \'.\'\r\n    return boardCopy\r\n\r\ndef getValidMoves(board, tile):\r\n    # Returns a list of [x,y] lists of valid moves for the given player on the given board.\r\n    validMoves = []\r\n    for x in range(WIDTH):\r\n        for y in range(HEIGHT):\r\n            if isValidMove(board, tile, x, y) != False:\r\n                validMoves.append([x, y])\r\n    return validMoves\r\n\r\ndef getScoreOfBoard(board):\r\n    # Determine the score by counting the tiles. Returns a dictionary with keys \'X\' and \'O\'.\r\n    xscore = 0\r\n    oscore = 0\r\n    for x in range(WIDTH):\r\n        for y in range(HEIGHT):\r\n            if board[x][y] == \'X\':\r\n                xscore += 1\r\n            if board[x][y] == \'O\':\r\n                oscore += 1\r\n    return {\'X\':xscore, \'O\':oscore}\r\n\r\ndef enterPlayerTile():\r\n    # Lets the player type which tile they want to be.\r\n    # Returns a list with the player\'s tile as the first item and the computer\'s tile as the second.\r\n    tile = \'\'\r\n    while not (tile == \'X\' or tile == \'O\'):\r\n        print(\'Do you want to be X or O?\')\r\n        tile = input().upper()\r\n\r\n    # The first element in the list is the player\'s tile, and the second is the computer\'s tile.\r\n    if tile == \'X\':\r\n        return [\'X\', \'O\']\r\n    else:\r\n        return [\'O\', \'X\']\r\n\r\ndef whoGoesFirst():\r\n    # Randomly choose who goes first.\r\n    if random.randint(0, 1) == 0:\r\n        return \'computer\'\r\n    else:\r\n        return \'player\'\r\n\r\ndef makeMove(board, tile, xstart, ystart):\r\n    # Place the tile on the board at xstart, ystart, and flip any of the opponent\'s pieces.\r\n    # Returns False if this is an invalid move; True if it is valid.\r\n    tilesToFlip = isValidMove(board, tile, xstart, ystart)\r\n\r\n    if tilesToFlip == False:\r\n        return False\r\n\r\n    board[xstart][ystart] = tile\r\n    for x, y in tilesToFlip:\r\n        board[x][y] = tile\r\n    return True\r\n\r\ndef getBoardCopy(board):\r\n    # Make a duplicate of the board list and return it.\r\n    boardCopy = getNewBoard()\r\n\r\n    for x in range(WIDTH):\r\n        for y in range(HEIGHT):\r\n            boardCopy[x][y] = board[x][y]\r\n\r\n    return boardCopy\r\n\r\ndef isOnCorner(x, y):\r\n    # Returns True if the position is in one of the four corners.\r\n    return (x == 0 or x == WIDTH - 1) and (y == 0 or y == HEIGHT - 1)\r\n\r\ndef getPlayerMove(board, playerTile):\r\n    # Let the player enter their move.\r\n    # Returns the move as [x, y] (or returns the strings \'hints\' or \'quit\').\r\n    DIGITS1TO8 = \'1 2 3 4 5 6 7 8\'.split()\r\n    while True:\r\n        print(\'Enter your move, \"quit\" to end the game, or \"hints\" to toggle hints.\')\r\n        move = input().lower()\r\n        if move == \'quit\' or move == \'hints\':\r\n            return move\r\n\r\n        if len(move) == 2 and move[0] in DIGITS1TO8 and move[1] in DIGITS1TO8:\r\n            x = int(move[0]) - 1\r\n            y = int(move[1]) - 1\r\n            if isValidMove(board, playerTile, x, y) == False:\r\n                continue\r\n            else:\r\n                break\r\n        else:\r\n            print(\'That is not a valid move. Enter the column (1-8) and then the row (1-8).\')\r\n            print(\'For example, 81 will move on the top-right corner.\')\r\n\r\n    return [x, y]\r\n\r\ndef getComputerMove(board, computerTile):\r\n    # Given a board and the computer\'s tile, determine where to\r\n    # move and return that move as a [x, y] list.\r\n    possibleMoves = getValidMoves(board, computerTile)\r\n    random.shuffle(possibleMoves) # randomize the order of the moves\r\n\r\n    # Always go for a corner if available.\r\n    for x, y in possibleMoves:\r\n        if isOnCorner(x, y):\r\n            return [x, y]\r\n\r\n    # Find the highest-scoring move possible.\r\n    bestScore = -1\r\n    for x, y in possibleMoves:\r\n        boardCopy = getBoardCopy(board)\r\n        makeMove(boardCopy, computerTile, x, y)\r\n        score = getScoreOfBoard(boardCopy)[computerTile]\r\n        if score > bestScore:\r\n            bestMove = [x, y]\r\n            bestScore = score\r\n    return bestMove\r\n\r\ndef printScore(board, playerTile, computerTile):\r\n    scores = getScoreOfBoard(board)\r\n    print(\'You: %s points. Computer: %s points.\' % (scores[playerTile], scores[computerTile]))\r\n\r\ndef playGame(playerTile, computerTile):\r\n    showHints = False\r\n    turn = whoGoesFirst()\r\n    print(\'The \' + turn + \' will go first.\')\r\n\r\n    # Clear the board and place starting pieces.\r\n    board = getNewBoard()\r\n    board[3][3] = \'X\'\r\n    board[3][4] = \'O\'\r\n    board[4][3] = \'O\'\r\n    board[4][4] = \'X\'\r\n\r\n    while True:\r\n        playerValidMoves = getValidMoves(board, playerTile)\r\n        computerValidMoves = getValidMoves(board, computerTile)\r\n\r\n        if playerValidMoves == [] and computerValidMoves == []:\r\n            return board # No one can move, so end the game.\r\n\r\n        elif turn == \'player\': # Player\'s turn\r\n            if playerValidMoves != []:\r\n                if showHints:\r\n                    validMovesBoard = getBoardWithValidMoves(board, playerTile)\r\n                    drawBoard(validMovesBoard)\r\n                else:\r\n                    drawBoard(board)\r\n                printScore(board, playerTile, computerTile)\r\n\r\n                move = getPlayerMove(board, playerTile)\r\n                if move == \'quit\':\r\n                    print(\'Thanks for playing!\')\r\n                    sys.exit() # Terminate the program.\r\n                elif move == \'hints\':\r\n                    showHints = not showHints\r\n                    continue\r\n                else:\r\n                    makeMove(board, playerTile, move[0], move[1])\r\n            turn = \'computer\'\r\n\r\n        elif turn == \'computer\': # Computer\'s turn\r\n            if computerValidMoves != []:\r\n                drawBoard(board)\r\n                printScore(board, playerTile, computerTile)\r\n\r\n                input(\'Press Enter to see the computer\\\'s move.\')\r\n                move = getComputerMove(board, computerTile)\r\n                makeMove(board, computerTile, move[0], move[1])\r\n            turn = \'player\'\r\n\r\n\r\n\r\nprint(\'Welcome to Reversegam!\')\r\n\r\nplayerTile, computerTile = enterPlayerTile()\r\n\r\nwhile True:\r\n    finalBoard = playGame(playerTile, computerTile)\r\n\r\n    # Display the final score.\r\n    drawBoard(finalBoard)\r\n    scores = getScoreOfBoard(finalBoard)\r\n    print(\'X scored %s points. O scored %s points.\' % (scores[\'X\'], scores[\'O\']))\r\n    if scores[playerTile] > scores[computerTile]:\r\n        print(\'You beat the computer by %s points! Congratulations!\' % (scores[playerTile] - scores[computerTile]))\r\n    elif scores[playerTile] < scores[computerTile]:\r\n        print(\'You lost. The computer beat you by %s points.\' % (scores[computerTile] - scores[playerTile]))\r\n    else:\r\n        print(\'The game was a tie!\')\r\n\r\n    print(\'Do you want to play again? (yes or no)\')\r\n    if not input().lower().startswith(\'y\'):\r\n        break\r\n",
    "sonar":"# Sonar\r\n\r\nimport random\r\nimport sys\r\nimport math\r\n\r\ndef getNewBoard():\r\n    # Create a new 60x15 board data structure.\r\n    board = []\r\n    for x in range(60): # The main list is a list of 60 lists.\r\n        board.append([])\r\n        for y in range(15): # Each list in the main list has 15 single-character strings.\r\n            # Use different characters for the ocean to make it more readable.\r\n            if random.randint(0, 1) == 0:\r\n                board[x].append(\'~\')\r\n            else:\r\n                board[x].append(\'`\')\r\n    return board\r\n\r\ndef drawBoard(board):\r\n    # Draw the board data structure.\r\n    tensDigitsLine = \'    \' # Initial space for the numbers down the left side of the board.\r\n    for i in range(1, 6):\r\n        tensDigitsLine += (\' \' * 9) + str(i)\r\n\r\n    # Print the numbers across the top of the board.\r\n    print(tensDigitsLine)\r\n    print(\'   \' + (\'0123456789\' * 6))\r\n    print()\r\n\r\n    # Print each of the 15 rows.\r\n    for row in range(15):\r\n        # Single-digit numbers need to be padded with an extra space.\r\n        if row < 10:\r\n            extraSpace = \' \'\r\n        else:\r\n            extraSpace = \'\'\r\n\r\n        # Create the string for this row on the board.\r\n        boardRow = \'\'\r\n        for column in range(60):\r\n            boardRow += board[column][row]\r\n\r\n        print(\'%s%s %s %s\' % (extraSpace, row, boardRow, row))\r\n\r\n    # Print the numbers across the bottom.\r\n    print()\r\n    print(\'   \' + (\'0123456789\' * 6))\r\n    print(tensDigitsLine)\r\n\r\ndef getRandomChests(numChests):\r\n    # Create a list of chest data structures (two-item lists of x, y int coordinates).\r\n    chests = []\r\n    while len(chests) < numChests:\r\n        newChest = [random.randint(0, 59), random.randint(0, 14)]\r\n        if newChest not in chests: # Make sure a chest is not already here.\r\n            chests.append(newChest)\r\n    return chests\r\n\r\ndef isOnBoard(x, y):\r\n    # Return True if the coordinates are on the board; otherwise, return False.\r\n    return x >= 0 and x <= 59 and y >= 0 and y <= 14\r\n\r\ndef makeMove(board, chests, x, y):\r\n    # Change the board data structure with a sonar device character. Remove treasure chests\r\n    # from the chests list as they are found. Return False if this is an invalid move.\r\n    # Otherwise, return the string of the result of this move.\r\n    smallestDistance = 100 # any chest will be closer than 100.\r\n    for cx, cy in chests:\r\n        distance = math.sqrt((cx - x) * (cx - x) + (cy - y) * (cy - y))\r\n\r\n        if distance < smallestDistance: # We want the closest treasure chest.\r\n            smallestDistance = distance\r\n\r\n    smallestDistance = round(smallestDistance)\r\n\r\n    if smallestDistance == 0:\r\n        # xy is directly on a treasure chest!\r\n        chests.remove([x, y])\r\n        return \'You have found a sunken treasure chest!\'\r\n    else:\r\n        if smallestDistance < 10:\r\n            board[x][y] = str(smallestDistance)\r\n            return \'Treasure detected at a distance of %s from the sonar device.\' % (smallestDistance)\r\n        else:\r\n            board[x][y] = \'X\'\r\n            return \'Sonar did not detect anything. All treasure chests out of range.\'\r\n\r\ndef enterPlayerMove(previousMoves):\r\n    # Let the player enter their move. Return a two-item list of int xy coordinates.\r\n    print(\'Where do you want to drop the next sonar device? (0-59 0-14) (or type quit)\')\r\n    while True:\r\n        move = input()\r\n        if move.lower() == \'quit\':\r\n            print(\'Thanks for playing!\')\r\n            sys.exit()\r\n\r\n        move = move.split()\r\n        if len(move) == 2 and move[0].isdigit() and move[1].isdigit() and isOnBoard(int(move[0]), int(move[1])):\r\n            if [int(move[0]), int(move[1])] in previousMoves:\r\n                print(\'You already moved there.\')\r\n                continue\r\n            return [int(move[0]), int(move[1])]\r\n\r\n        print(\'Enter a number from 0 to 59, a space, then a number from 0 to 14.\')\r\n\r\ndef showInstructions():\r\n    print(\'\'\'Instructions:\r\nYou are the captain of the Simon, a treasure-hunting ship. Your current mission\r\nis to use sonar devices to find three sunken treasure chests at the bottom of\r\nthe ocean. But you only have cheap sonar that finds distance, not direction.\r\n\r\nEnter the coordinates to drop a sonar device. The ocean map will be marked with\r\nhow far away the nearest chest is, or an X if it is beyond the sonar device\'s\r\nrange. For example, the C marks are where chests are. The sonar device shows a\r\n3 because the closest chest is 3 spaces away.\r\n\r\n                    1         2         3\r\n          012345678901234567890123456789012\r\n\r\n        0 ~~~~`~```~`~``~~~``~`~~``~~~``~`~ 0\r\n        1 ~`~`~``~~`~```~~~```~~`~`~~~`~~~~ 1\r\n        2 `~`C``3`~~~~`C`~~~~`````~~``~~~`` 2\r\n        3 ````````~~~`````~~~`~`````~`~``~` 3\r\n        4 ~`~~~~`~~`~~`C`~``~~`~~~`~```~``~ 4\r\n\r\n          012345678901234567890123456789012\r\n                    1         2         3\r\n(In the real game, the chests are not visible in the ocean.)\r\n\r\nPress enter to continue...\'\'\')\r\n    input()\r\n\r\n    print(\'\'\'When you drop a sonar device directly on a chest, you retrieve it and the other\r\nsonar devices update to show how far away the next nearest chest is. The chests\r\nare beyond the range of the sonar device on the left, so it shows an X.\r\n\r\n                    1         2         3\r\n          012345678901234567890123456789012\r\n\r\n        0 ~~~~`~```~`~``~~~``~`~~``~~~``~`~ 0\r\n        1 ~`~`~``~~`~```~~~```~~`~`~~~`~~~~ 1\r\n        2 `~`X``7`~~~~`C`~~~~`````~~``~~~`` 2\r\n        3 ````````~~~`````~~~`~`````~`~``~` 3\r\n        4 ~`~~~~`~~`~~`C`~``~~`~~~`~```~``~ 4\r\n\r\n          012345678901234567890123456789012\r\n                    1         2         3\r\n\r\nThe treasure chests don\'t move around. Sonar devices can detect treasure chests\r\nup to a distance of 9 spaces. Try to collect all 3 chests before running out of\r\nsonar devices. Good luck!\r\n\r\nPress enter to continue...\'\'\')\r\n    input()\r\n\r\n\r\n\r\nprint(\'S O N A R !\')\r\nprint()\r\nprint(\'Would you like to view the instructions? (yes\/no)\')\r\nif input().lower().startswith(\'y\'):\r\n    showInstructions()\r\n\r\nwhile True:\r\n    # Game setup\r\n    sonarDevices = 20\r\n    theBoard = getNewBoard()\r\n    theChests = getRandomChests(3)\r\n    drawBoard(theBoard)\r\n    previousMoves = []\r\n\r\n    while sonarDevices > 0:\r\n        # Show sonar device and chest statuses.\r\n        print(\'You have %s sonar device(s) left. %s treasure chest(s) remaining.\' % (sonarDevices, len(theChests)))\r\n\r\n        x, y = enterPlayerMove(previousMoves)\r\n        previousMoves.append([x, y]) # we must track all moves so that sonar devices can be updated.\r\n\r\n        moveResult = makeMove(theBoard, theChests, x, y)\r\n        if moveResult == False:\r\n            continue\r\n        else:\r\n            if moveResult == \'You have found a sunken treasure chest!\':\r\n                # Update all the sonar devices currently on the map.\r\n                for x, y in previousMoves:\r\n                    makeMove(theBoard, theChests, x, y)\r\n            drawBoard(theBoard)\r\n            print(moveResult)\r\n\r\n        if len(theChests) == 0:\r\n            print(\'You have found all the sunken treasure chests! Congratulations and good game!\')\r\n            break\r\n\r\n        sonarDevices -= 1\r\n\r\n    if sonarDevices == 0:\r\n        print(\'We\\\'ve run out of sonar devices! Now we have to turn the ship around and head\')\r\n        print(\'for home with treasure chests still out there! Game over.\')\r\n        print(\'    The remaining chests were here:\')\r\n        for x, y in theChests:\r\n            print(\'    %s, %s\' % (x, y))\r\n\r\n    print(\'Do you want to play again? (yes or no)\')\r\n    if not input().lower().startswith(\'y\'):\r\n        sys.exit()\r\n",
    "spritesAndSounds":"import pygame, sys, time, random\r\nfrom pygame.locals import *\r\n\r\n# Set up pygame.\r\npygame.init()\r\nmainClock = pygame.time.Clock()\r\n\r\n# Set up the window.\r\nWINDOWWIDTH = 400\r\nWINDOWHEIGHT = 400\r\nwindowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT), 0, 32)\r\npygame.display.set_caption(\'Sprites and Sounds\')\r\n\r\n# Set up the colors.\r\nWHITE = (255, 255, 255)\r\n\r\n# Set up the block data structure.\r\nplayer = pygame.Rect(300, 100, 40, 40)\r\nplayerImage = pygame.image.load(\'player.png\')\r\nplayerStretchedImage = pygame.transform.scale(playerImage, (40, 40))\r\nfoodImage = pygame.image.load(\'cherry.png\')\r\nfoods = []\r\nfor i in range(20):\r\n    foods.append(pygame.Rect(random.randint(0, WINDOWWIDTH - 20), random.randint(0, WINDOWHEIGHT - 20), 20, 20))\r\n\r\nfoodCounter = 0\r\nNEWFOOD = 40\r\n\r\n# Set up keyboard variables.\r\nmoveLeft = False\r\nmoveRight = False\r\nmoveUp = False\r\nmoveDown = False\r\n\r\nMOVESPEED = 6\r\n\r\n# Set up the music.\r\npickUpSound = pygame.mixer.Sound(\'pickup.wav\')\r\npygame.mixer.music.load(\'background.mid\')\r\npygame.mixer.music.play(-1, 0.0)\r\nmusicPlaying = True\r\n\r\n# Run the game loop.\r\nwhile True:\r\n    # Check for the QUIT event.\r\n    for event in pygame.event.get():\r\n        if event.type == QUIT:\r\n            pygame.quit()\r\n            sys.exit()\r\n        if event.type == KEYDOWN:\r\n            # Change the keyboard variables.\r\n            if event.key == K_LEFT or event.key == K_a:\r\n                moveRight = False\r\n                moveLeft = True\r\n            if event.key == K_RIGHT or event.key == K_d:\r\n                moveLeft = False\r\n                moveRight = True\r\n            if event.key == K_UP or event.key == K_w:\r\n                moveDown = False\r\n                moveUp = True\r\n            if event.key == K_DOWN or event.key == K_s:\r\n                moveUp = False\r\n                moveDown = True\r\n        if event.type == KEYUP:\r\n            if event.key == K_ESCAPE:\r\n                pygame.quit()\r\n                sys.exit()\r\n            if event.key == K_LEFT or event.key == K_a:\r\n                moveLeft = False\r\n            if event.key == K_RIGHT or event.key == K_d:\r\n                moveRight = False\r\n            if event.key == K_UP or event.key == K_w:\r\n                moveUp = False\r\n            if event.key == K_DOWN or event.key == K_s:\r\n                moveDown = False\r\n            if event.key == K_x:\r\n                player.top = random.randint(0, WINDOWHEIGHT - player.height)\r\n                player.left = random.randint(0, WINDOWWIDTH - player.width)\r\n            if event.key == K_m:\r\n                if musicPlaying:\r\n                    pygame.mixer.music.stop()\r\n                else:\r\n                    pygame.mixer.music.play(-1, 0.0)\r\n                musicPlaying = not musicPlaying\r\n\r\n        if event.type == MOUSEBUTTONUP:\r\n            foods.append(pygame.Rect(event.pos[0] - 10, event.pos[1] - 10, 20, 20))\r\n\r\n    foodCounter += 1\r\n    if foodCounter >= NEWFOOD:\r\n        # Add new food.\r\n        foodCounter = 0\r\n        foods.append(pygame.Rect(random.randint(0, WINDOWWIDTH - 20), random.randint(0, WINDOWHEIGHT - 20), 20, 20))\r\n\r\n    # Draw the white background onto the surface.\r\n    windowSurface.fill(WHITE)\r\n\r\n    # Move the player.\r\n    if moveDown and player.bottom < WINDOWHEIGHT:\r\n        player.top += MOVESPEED\r\n    if moveUp and player.top > 0:\r\n        player.top -= MOVESPEED\r\n    if moveLeft and player.left > 0:\r\n        player.left -= MOVESPEED\r\n    if moveRight and player.right < WINDOWWIDTH:\r\n        player.right += MOVESPEED\r\n\r\n\r\n    # Draw the block onto the surface.\r\n    windowSurface.blit(playerStretchedImage, player)\r\n\r\n    # Check whether the block has intersected with any food squares.\r\n    for food in foods[:]:\r\n        if player.colliderect(food):\r\n            foods.remove(food)\r\n            player = pygame.Rect(player.left, player.top, player.width + 2, player.height + 2)\r\n            playerStretchedImage = pygame.transform.scale(playerImage, (player.width, player.height))\r\n            if musicPlaying:\r\n                pickUpSound.play()\r\n\r\n    # Draw the food.\r\n    for food in foods:\r\n        windowSurface.blit(foodImage, food)\r\n\r\n    # Draw the window onto the screen.\r\n    pygame.display.update()\r\n    mainClock.tick(40 )\r\n",
    "tictactoe":"# Tic Tac Toe\r\n\r\nimport random\r\n\r\ndef drawBoard(board):\r\n    # This function prints out the board that it was passed.\r\n\r\n    # \"board\" is a list of 10 strings representing the board (ignore index 0)\r\n    print(board[7] + \'|\' + board[8] + \'|\' + board[9])\r\n    print(\'-+-+-\')\r\n    print(board[4] + \'|\' + board[5] + \'|\' + board[6])\r\n    print(\'-+-+-\')\r\n    print(board[1] + \'|\' + board[2] + \'|\' + board[3])\r\n\r\ndef inputPlayerLetter():\r\n    # Lets the player type which letter they want to be.\r\n    # Returns a list with the player\'s letter as the first item, and the computer\'s letter as the second.\r\n    letter = \'\'\r\n    while not (letter == \'X\' or letter == \'O\'):\r\n        print(\'Do you want to be X or O?\')\r\n        letter = input().upper()\r\n\r\n    # the first element in the list is the player\'s letter, the second is the computer\'s letter.\r\n    if letter == \'X\':\r\n        return [\'X\', \'O\']\r\n    else:\r\n        return [\'O\', \'X\']\r\n\r\ndef whoGoesFirst():\r\n    # Randomly choose the player who goes first.\r\n    if random.randint(0, 1) == 0:\r\n        return \'computer\'\r\n    else:\r\n        return \'player\'\r\n\r\ndef makeMove(board, letter, move):\r\n    board[move] = letter\r\n\r\ndef isWinner(bo, le):\r\n    # Given a board and a player\'s letter, this function returns True if that player has won.\r\n    # We use bo instead of board and le instead of letter so we don\'t have to type as much.\r\n    return ((bo[7] == le and bo[8] == le and bo[9] == le) or # across the top\r\n    (bo[4] == le and bo[5] == le and bo[6] == le) or # across the middle\r\n    (bo[1] == le and bo[2] == le and bo[3] == le) or # across the bottom\r\n    (bo[7] == le and bo[4] == le and bo[1] == le) or # down the left side\r\n    (bo[8] == le and bo[5] == le and bo[2] == le) or # down the middle\r\n    (bo[9] == le and bo[6] == le and bo[3] == le) or # down the right side\r\n    (bo[7] == le and bo[5] == le and bo[3] == le) or # diagonal\r\n    (bo[9] == le and bo[5] == le and bo[1] == le)) # diagonal\r\n\r\ndef getBoardCopy(board):\r\n    # Make a copy of the board list and return it.\r\n    boardCopy = []\r\n    for i in board:\r\n        boardCopy.append(i)\r\n    return boardCopy\r\n\r\ndef isSpaceFree(board, move):\r\n    # Return true if the passed move is free on the passed board.\r\n    return board[move] == \' \'\r\n\r\ndef getPlayerMove(board):\r\n    # Let the player type in their move.\r\n    move = \' \'\r\n    while move not in \'1 2 3 4 5 6 7 8 9\'.split() or not isSpaceFree(board, int(move)):\r\n        print(\'What is your next move? (1-9)\')\r\n        move = input()\r\n    return int(move)\r\n\r\ndef chooseRandomMoveFromList(board, movesList):\r\n    # Returns a valid move from the passed list on the passed board.\r\n    # Returns None if there is no valid move.\r\n    possibleMoves = []\r\n    for i in movesList:\r\n        if isSpaceFree(board, i):\r\n            possibleMoves.append(i)\r\n\r\n    if len(possibleMoves) != 0:\r\n        return random.choice(possibleMoves)\r\n    else:\r\n        return None\r\n\r\ndef getComputerMove(board, computerLetter):\r\n    # Given a board and the computer\'s letter, determine where to move and return that move.\r\n    if computerLetter == \'X\':\r\n        playerLetter = \'O\'\r\n    else:\r\n        playerLetter = \'X\'\r\n\r\n    # Here is our algorithm for our Tic Tac Toe AI:\r\n    # First, check if we can win in the next move\r\n    for i in range(1, 10):\r\n        boardCopy = getBoardCopy(board)\r\n        if isSpaceFree(boardCopy, i):\r\n            makeMove(boardCopy, computerLetter, i)\r\n            if isWinner(boardCopy, computerLetter):\r\n                return i\r\n\r\n    # Check if the player could win on his next move, and block them.\r\n    for i in range(1, 10):\r\n        boardCopy = getBoardCopy(board)\r\n        if isSpaceFree(boardCopy, i):\r\n            makeMove(boardCopy, playerLetter, i)\r\n            if isWinner(boardCopy, playerLetter):\r\n                return i\r\n\r\n    # Try to take one of the corners, if they are free.\r\n    move = chooseRandomMoveFromList(board, [1, 3, 7, 9])\r\n    if move != None:\r\n        return move\r\n\r\n    # Try to take the center, if it is free.\r\n    if isSpaceFree(board, 5):\r\n        return 5\r\n\r\n    # Move on one of the sides.\r\n    return chooseRandomMoveFromList(board, [2, 4, 6, 8])\r\n\r\ndef isBoardFull(board):\r\n    # Return True if every space on the board has been taken. Otherwise return False.\r\n    for i in range(1, 10):\r\n        if isSpaceFree(board, i):\r\n            return False\r\n    return True\r\n\r\n\r\nprint(\'Welcome to Tic Tac Toe!\')\r\n\r\nwhile True:\r\n    # Reset the board\r\n    theBoard = [\' \'] * 10\r\n    playerLetter, computerLetter = inputPlayerLetter()\r\n    turn = whoGoesFirst()\r\n    print(\'The \' + turn + \' will go first.\')\r\n    gameIsPlaying = True\r\n\r\n    while gameIsPlaying:\r\n        if turn == \'player\':\r\n            # Player\'s turn.\r\n            drawBoard(theBoard)\r\n            move = getPlayerMove(theBoard)\r\n            makeMove(theBoard, playerLetter, move)\r\n\r\n            if isWinner(theBoard, playerLetter):\r\n                drawBoard(theBoard)\r\n                print(\'Hooray! You have won the game!\')\r\n                gameIsPlaying = False\r\n            else:\r\n                if isBoardFull(theBoard):\r\n                    drawBoard(theBoard)\r\n                    print(\'The game is a tie!\')\r\n                    break\r\n                else:\r\n                    turn = \'computer\'\r\n\r\n        else:\r\n            # Computer\'s turn.\r\n            move = getComputerMove(theBoard, computerLetter)\r\n            makeMove(theBoard, computerLetter, move)\r\n\r\n            if isWinner(theBoard, computerLetter):\r\n                drawBoard(theBoard)\r\n                print(\'The computer has beaten you! You lose.\')\r\n                gameIsPlaying = False\r\n            else:\r\n                if isBoardFull(theBoard):\r\n                    drawBoard(theBoard)\r\n                    print(\'The game is a tie!\')\r\n                    break\r\n                else:\r\n                    turn = \'player\'\r\n\r\n    print(\'Do you want to play again? (yes or no)\')\r\n    if not input().lower().startswith(\'y\'):\r\n        break\r\n"
};
