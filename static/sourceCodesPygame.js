// Thanks to http://www.htmlescape.net/stringescape_tool.html
var sourceCodes = {
    "catanimation": "import pygame, sys\nfrom pygame.locals import *\n\npygame.init()\n\nFPS = 30 # frames per second setting\nfpsClock = pygame.time.Clock()\n\n# set up the window\nDISPLAYSURF = pygame.display.set_mode((400, 300), 0, 32)\npygame.display.set_caption(\'Animation\')\n\nWHITE = (255, 255, 255)\ncatImg = pygame.image.load(\'cat.png\')\ncatx = 10\ncaty = 10\ndirection = \'right\'\n\nwhile True: # the main game loop\n    DISPLAYSURF.fill(WHITE)\n\n    if direction == \'right\':\n        catx += 5\n        if catx == 280:\n            direction = \'down\'\n    elif direction == \'down\':\n        caty += 5\n        if caty == 220:\n            direction = \'left\'\n    elif direction == \'left\':\n        catx -= 5\n        if catx == 10:\n            direction = \'up\'\n    elif direction == \'up\':\n        caty -= 5\n        if caty == 10:\n            direction = \'right\'\n\n    DISPLAYSURF.blit(catImg, (catx, caty))\n\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n            sys.exit()\n\n    pygame.display.update()\n    fpsClock.tick(FPS)",
    "starpusher": "# Star Pusher (a Sokoban clone)\n# By Al Sweigart al@inventwithpython.com\n# http:\x2F\x2Finventwithpython.com\x2Fpygame\n# Released under a \"Simplified BSD\" license\n\nimport random, sys, copy, os, pygame\nfrom pygame.locals import *\n\nFPS = 30 # frames per second to update the screen\nWINWIDTH = 800 # width of the program\'s window, in pixels\nWINHEIGHT = 600 # height in pixels\nHALF_WINWIDTH = int(WINWIDTH \x2F 2)\nHALF_WINHEIGHT = int(WINHEIGHT \x2F 2)\n\n# The total width and height of each tile in pixels.\nTILEWIDTH = 50\nTILEHEIGHT = 85\nTILEFLOORHEIGHT = 40\n\nCAM_MOVE_SPEED = 5 # how many pixels per frame the camera moves\n\n# The percentage of outdoor tiles that have additional\n# decoration on them, such as a tree or rock.\nOUTSIDE_DECORATION_PCT = 20\n\nBRIGHTBLUE = (  0, 170, 255)\nWHITE      = (255, 255, 255)\nBGCOLOR = BRIGHTBLUE\nTEXTCOLOR = WHITE\n\nUP = \'up\'\nDOWN = \'down\'\nLEFT = \'left\'\nRIGHT = \'right\'\n\n\ndef main():\n    global FPSCLOCK, DISPLAYSURF, IMAGESDICT, TILEMAPPING, OUTSIDEDECOMAPPING, BASICFONT, PLAYERIMAGES, currentImage\n\n    # Pygame initialization and basic set up of the global variables.\n    pygame.init()\n    FPSCLOCK = pygame.time.Clock()\n\n    # Because the Surface object stored in DISPLAYSURF was returned\n    # from the pygame.display.set_mode() function, this is the\n    # Surface object that is drawn to the actual computer screen\n    # when pygame.display.update() is called.\n    DISPLAYSURF = pygame.display.set_mode((WINWIDTH, WINHEIGHT))\n\n    pygame.display.set_caption(\'Star Pusher\')\n    BASICFONT = pygame.font.Font(\'freesansbold.ttf\', 18)\n\n    # A global dict value that will contain all the Pygame\n    # Surface objects returned by pygame.image.load().\n    IMAGESDICT = {\'uncovered goal\': pygame.image.load(\'RedSelector.png\'),\n                  \'covered goal\': pygame.image.load(\'Selector.png\'),\n                  \'star\': pygame.image.load(\'Star.png\'),\n                  \'corner\': pygame.image.load(\'Wall_Block_Tall.png\'),\n                  \'wall\': pygame.image.load(\'Wood_Block_Tall.png\'),\n                  \'inside floor\': pygame.image.load(\'Plain_Block.png\'),\n                  \'outside floor\': pygame.image.load(\'Grass_Block.png\'),\n                  \'title\': pygame.image.load(\'star_title.png\'),\n                  \'solved\': pygame.image.load(\'star_solved.png\'),\n                  \'princess\': pygame.image.load(\'princess.png\'),\n                  \'boy\': pygame.image.load(\'boy.png\'),\n                  \'catgirl\': pygame.image.load(\'catgirl.png\'),\n                  \'horngirl\': pygame.image.load(\'horngirl.png\'),\n                  \'pinkgirl\': pygame.image.load(\'pinkgirl.png\'),\n                  \'rock\': pygame.image.load(\'Rock.png\'),\n                  \'short tree\': pygame.image.load(\'Tree_Short.png\'),\n                  \'tall tree\': pygame.image.load(\'Tree_Tall.png\'),\n                  \'ugly tree\': pygame.image.load(\'Tree_Ugly.png\')}\n\n    # These dict values are global, and map the character that appears\n    # in the level file to the Surface object it represents.\n    TILEMAPPING = {\'x\': IMAGESDICT[\'corner\'],\n                   \'#\': IMAGESDICT[\'wall\'],\n                   \'o\': IMAGESDICT[\'inside floor\'],\n                   \' \': IMAGESDICT[\'outside floor\']}\n    OUTSIDEDECOMAPPING = {\'1\': IMAGESDICT[\'rock\'],\n                          \'2\': IMAGESDICT[\'short tree\'],\n                          \'3\': IMAGESDICT[\'tall tree\'],\n                          \'4\': IMAGESDICT[\'ugly tree\']}\n\n    # PLAYERIMAGES is a list of all possible characters the player can be.\n    # currentImage is the index of the player\'s current player image.\n    currentImage = 0\n    PLAYERIMAGES = [IMAGESDICT[\'princess\'],\n                    IMAGESDICT[\'boy\'],\n                    IMAGESDICT[\'catgirl\'],\n                    IMAGESDICT[\'horngirl\'],\n                    IMAGESDICT[\'pinkgirl\']]\n\n    startScreen() # show the title screen until the user presses a key\n\n    # Read in the levels from the text file. See the readLevelsFile() for\n    # details on the format of this file and how to make your own levels.\n    levels = readLevelsFile(\'starPusherLevels.txt\')\n    currentLevelIndex = 0\n\n    # The main game loop. This loop runs a single level, when the user\n    # finishes that level, the next\x2Fprevious level is loaded.\n    while True: # main game loop\n        # Run the level to actually start playing the game:\n        result = runLevel(levels, currentLevelIndex)\n\n        if result in (\'solved\', \'next\'):\n            # Go to the next level.\n            currentLevelIndex += 1\n            if currentLevelIndex \x3E= len(levels):\n                # If there are no more levels, go back to the first one.\n                currentLevelIndex = 0\n        elif result == \'back\':\n            # Go to the previous level.\n            currentLevelIndex -= 1\n            if currentLevelIndex \x3C 0:\n                # If there are no previous levels, go to the last one.\n                currentLevelIndex = len(levels)-1\n        elif result == \'reset\':\n            pass # Do nothing. Loop re-calls runLevel() to reset the level\n\n\ndef runLevel(levels, levelNum):\n    global currentImage\n    levelObj = levels[levelNum]\n    mapObj = decorateMap(levelObj[\'mapObj\'], levelObj[\'startState\'][\'player\'])\n    gameStateObj = copy.deepcopy(levelObj[\'startState\'])\n    mapNeedsRedraw = True # set to True to call drawMap()\n    levelSurf = BASICFONT.render(\'Level %s of %s\' % (levelNum + 1, len(levels)), 1, TEXTCOLOR)\n    levelRect = levelSurf.get_rect()\n    levelRect.bottomleft = (20, WINHEIGHT - 35)\n    mapWidth = len(mapObj) * TILEWIDTH\n    mapHeight = (len(mapObj[0]) - 1) * TILEFLOORHEIGHT + TILEHEIGHT\n    MAX_CAM_X_PAN = abs(HALF_WINHEIGHT - int(mapHeight \x2F 2)) + TILEWIDTH\n    MAX_CAM_Y_PAN = abs(HALF_WINWIDTH - int(mapWidth \x2F 2)) + TILEHEIGHT\n\n    levelIsComplete = False\n    # Track how much the camera has moved:\n    cameraOffsetX = 0\n    cameraOffsetY = 0\n    # Track if the keys to move the camera are being held down:\n    cameraUp = False\n    cameraDown = False\n    cameraLeft = False\n    cameraRight = False\n\n    while True: # main game loop\n        # Reset these variables:\n        playerMoveTo = None\n        keyPressed = False\n\n        for event in pygame.event.get(): # event handling loop\n            if event.type == QUIT:\n                # Player clicked the \"X\" at the corner of the window.\n                terminate()\n\n            elif event.type == KEYDOWN:\n                # Handle key presses\n                keyPressed = True\n                if event.key == K_LEFT:\n                    playerMoveTo = LEFT\n                elif event.key == K_RIGHT:\n                    playerMoveTo = RIGHT\n                elif event.key == K_UP:\n                    playerMoveTo = UP\n                elif event.key == K_DOWN:\n                    playerMoveTo = DOWN\n\n                # Set the camera move mode.\n                elif event.key == K_a:\n                    cameraLeft = True\n                elif event.key == K_d:\n                    cameraRight = True\n                elif event.key == K_w:\n                    cameraUp = True\n                elif event.key == K_s:\n                    cameraDown = True\n\n                elif event.key == K_n:\n                    return \'next\'\n                elif event.key == K_b:\n                    return \'back\'\n\n                elif event.key == K_ESCAPE:\n                    terminate() # Esc key quits.\n                elif event.key == K_BACKSPACE:\n                    return \'reset\' # Reset the level.\n                elif event.key == K_p:\n                    # Change the player image to the next one.\n                    currentImage += 1\n                    if currentImage \x3E= len(PLAYERIMAGES):\n                        # After the last player image, use the first one.\n                        currentImage = 0\n                    mapNeedsRedraw = True\n\n            elif event.type == KEYUP:\n                # Unset the camera move mode.\n                if event.key == K_a:\n                    cameraLeft = False\n                elif event.key == K_d:\n                    cameraRight = False\n                elif event.key == K_w:\n                    cameraUp = False\n                elif event.key == K_s:\n                    cameraDown = False\n\n        if playerMoveTo != None and not levelIsComplete:\n            # If the player pushed a key to move, make the move\n            # (if possible) and push any stars that are pushable.\n            moved = makeMove(mapObj, gameStateObj, playerMoveTo)\n\n            if moved:\n                # increment the step counter.\n                gameStateObj[\'stepCounter\'] += 1\n                mapNeedsRedraw = True\n\n            if isLevelFinished(levelObj, gameStateObj):\n                # level is solved, we should show the \"Solved!\" image.\n                levelIsComplete = True\n                keyPressed = False\n\n        DISPLAYSURF.fill(BGCOLOR)\n\n        if mapNeedsRedraw:\n            mapSurf = drawMap(mapObj, gameStateObj, levelObj[\'goals\'])\n            mapNeedsRedraw = False\n\n        if cameraUp and cameraOffsetY \x3C MAX_CAM_X_PAN:\n            cameraOffsetY += CAM_MOVE_SPEED\n        elif cameraDown and cameraOffsetY \x3E -MAX_CAM_X_PAN:\n            cameraOffsetY -= CAM_MOVE_SPEED\n        if cameraLeft and cameraOffsetX \x3C MAX_CAM_Y_PAN:\n            cameraOffsetX += CAM_MOVE_SPEED\n        elif cameraRight and cameraOffsetX \x3E -MAX_CAM_Y_PAN:\n            cameraOffsetX -= CAM_MOVE_SPEED\n\n        # Adjust mapSurf\'s Rect object based on the camera offset.\n        mapSurfRect = mapSurf.get_rect()\n        mapSurfRect.center = (HALF_WINWIDTH + cameraOffsetX, HALF_WINHEIGHT + cameraOffsetY)\n\n        # Draw mapSurf to the DISPLAYSURF Surface object.\n        DISPLAYSURF.blit(mapSurf, mapSurfRect)\n\n        DISPLAYSURF.blit(levelSurf, levelRect)\n        stepSurf = BASICFONT.render(\'Steps: %s\' % (gameStateObj[\'stepCounter\']), 1, TEXTCOLOR)\n        stepRect = stepSurf.get_rect()\n        stepRect.bottomleft = (20, WINHEIGHT - 10)\n        DISPLAYSURF.blit(stepSurf, stepRect)\n\n        if levelIsComplete:\n            # is solved, show the \"Solved!\" image until the player\n            # has pressed a key.\n            solvedRect = IMAGESDICT[\'solved\'].get_rect()\n            solvedRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT)\n            DISPLAYSURF.blit(IMAGESDICT[\'solved\'], solvedRect)\n\n            if keyPressed:\n                return \'solved\'\n\n        pygame.display.update() # draw DISPLAYSURF to the screen.\n        FPSCLOCK.tick()\n\n\ndef isWall(mapObj, x, y):\n    \"\"\"Returns True if the (x, y) position on\n    the map is a wall, otherwise return False.\"\"\"\n    if x \x3C 0 or x \x3E= len(mapObj) or y \x3C 0 or y \x3E= len(mapObj[x]):\n        return False # x and y aren\'t actually on the map.\n    elif mapObj[x][y] in (\'#\', \'x\'):\n        return True # wall is blocking\n    return False\n\n\ndef decorateMap(mapObj, startxy):\n    \"\"\"Makes a copy of the given map object and modifies it.\n    Here is what is done to it:\n        * Walls that are corners are turned into corner pieces.\n        * The outside\x2Finside floor tile distinction is made.\n        * Tree\x2Frock decorations are randomly added to the outside tiles.\n\n    Returns the decorated map object.\"\"\"\n\n    startx, starty = startxy # Syntactic sugar\n\n    # Copy the map object so we don\'t modify the original passed\n    mapObjCopy = copy.deepcopy(mapObj)\n\n    # Remove the non-wall characters from the map data\n    for x in range(len(mapObjCopy)):\n        for y in range(len(mapObjCopy[0])):\n            if mapObjCopy[x][y] in (\'$\', \'.\', \'@\', \'+\', \'*\'):\n                mapObjCopy[x][y] = \' \'\n\n    # Flood fill to determine inside\x2Foutside floor tiles.\n    floodFill(mapObjCopy, startx, starty, \' \', \'o\')\n\n    # Convert the adjoined walls into corner tiles.\n    for x in range(len(mapObjCopy)):\n        for y in range(len(mapObjCopy[0])):\n\n            if mapObjCopy[x][y] == \'#\':\n                if (isWall(mapObjCopy, x, y-1) and isWall(mapObjCopy, x+1, y)) or \\\n                   (isWall(mapObjCopy, x+1, y) and isWall(mapObjCopy, x, y+1)) or \\\n                   (isWall(mapObjCopy, x, y+1) and isWall(mapObjCopy, x-1, y)) or \\\n                   (isWall(mapObjCopy, x-1, y) and isWall(mapObjCopy, x, y-1)):\n                    mapObjCopy[x][y] = \'x\'\n\n            elif mapObjCopy[x][y] == \' \' and random.randint(0, 99) \x3C OUTSIDE_DECORATION_PCT:\n                mapObjCopy[x][y] = random.choice(list(OUTSIDEDECOMAPPING.keys()))\n\n    return mapObjCopy\n\n\ndef isBlocked(mapObj, gameStateObj, x, y):\n    \"\"\"Returns True if the (x, y) position on the map is\n    blocked by a wall or star, otherwise return False.\"\"\"\n\n    if isWall(mapObj, x, y):\n        return True\n\n    elif x \x3C 0 or x \x3E= len(mapObj) or y \x3C 0 or y \x3E= len(mapObj[x]):\n        return True # x and y aren\'t actually on the map.\n\n    elif (x, y) in gameStateObj[\'stars\']:\n        return True # a star is blocking\n\n    return False\n\n\ndef makeMove(mapObj, gameStateObj, playerMoveTo):\n    \"\"\"Given a map and game state object, see if it is possible for the\n    player to make the given move. If it is, then change the player\'s\n    position (and the position of any pushed star). If not, do nothing.\n\n    Returns True if the player moved, otherwise False.\"\"\"\n\n    # Make sure the player can move in the direction they want.\n    playerx, playery = gameStateObj[\'player\']\n\n    # This variable is \"syntactic sugar\". Typing \"stars\" is more\n    # readable than typing \"gameStateObj[\'stars\']\" in our code.\n    stars = gameStateObj[\'stars\']\n\n    # The code for handling each of the directions is so similar aside\n    # from adding or subtracting 1 to the x\x2Fy coordinates. We can\n    # simplify it by using the xOffset and yOffset variables.\n    if playerMoveTo == UP:\n        xOffset = 0\n        yOffset = -1\n    elif playerMoveTo == RIGHT:\n        xOffset = 1\n        yOffset = 0\n    elif playerMoveTo == DOWN:\n        xOffset = 0\n        yOffset = 1\n    elif playerMoveTo == LEFT:\n        xOffset = -1\n        yOffset = 0\n\n    # See if the player can move in that direction.\n    if isWall(mapObj, playerx + xOffset, playery + yOffset):\n        return False\n    else:\n        if (playerx + xOffset, playery + yOffset) in stars:\n            # There is a star in the way, see if the player can push it.\n            if not isBlocked(mapObj, gameStateObj, playerx + (xOffset*2), playery + (yOffset*2)):\n                # Move the star.\n                ind = stars.index((playerx + xOffset, playery + yOffset))\n                stars[ind] = (stars[ind][0] + xOffset, stars[ind][1] + yOffset)\n            else:\n                return False\n        # Move the player upwards.\n        gameStateObj[\'player\'] = (playerx + xOffset, playery + yOffset)\n        return True\n\n\ndef startScreen():\n    \"\"\"Display the start screen (which has the title and instructions)\n    until the player presses a key. Returns None.\"\"\"\n\n    # Position the title image.\n    titleRect = IMAGESDICT[\'title\'].get_rect()\n    topCoord = 50 # topCoord tracks where to position the top of the text\n    titleRect.top = topCoord\n    titleRect.centerx = HALF_WINWIDTH\n    topCoord += titleRect.height\n\n    # Unfortunately, Pygame\'s font \& text system only shows one line at\n    # a time, so we can\'t use strings with \\n newline characters in them.\n    # So we will use a list with each line in it.\n    instructionText = [\'Push the stars over the marks.\',\n                       \'Arrow keys to move, WASD for camera control, P to change character.\',\n                       \'Backspace to reset level, Esc to quit.\',\n                       \'N for next level, B to go back a level.\']\n\n    # Start with drawing a blank color to the entire window:\n    DISPLAYSURF.fill(BGCOLOR)\n\n    # Draw the title image to the window:\n    DISPLAYSURF.blit(IMAGESDICT[\'title\'], titleRect)\n\n    # Position and draw the text.\n    for i in range(len(instructionText)):\n        instSurf = BASICFONT.render(instructionText[i], 1, TEXTCOLOR)\n        instRect = instSurf.get_rect()\n        topCoord += 10 # 10 pixels will go in between each line of text.\n        instRect.top = topCoord\n        instRect.centerx = HALF_WINWIDTH\n        topCoord += instRect.height # Adjust for the height of the line.\n        DISPLAYSURF.blit(instSurf, instRect)\n\n    while True: # Main loop for the start screen.\n        for event in pygame.event.get():\n            if event.type == QUIT:\n                terminate()\n            elif event.type == KEYDOWN:\n                if event.key == K_ESCAPE:\n                    terminate()\n                return # user has pressed a key, so return.\n\n        # Display the DISPLAYSURF contents to the actual screen.\n        pygame.display.update()\n        FPSCLOCK.tick()\n\n\ndef readLevelsFile(filename):\n    assert os.path.exists(filename), \'Cannot find the level file: %s\' % (filename)\n    mapFile = open(filename, \'r\')\n    # Each level must end with a blank line\n    content = mapFile.readlines() + [\'\\r\\n\']\n    mapFile.close()\n\n    levels = [] # Will contain a list of level objects.\n    levelNum = 0\n    mapTextLines = [] # contains the lines for a single level\'s map.\n    mapObj = [] # the map object made from the data in mapTextLines\n    for lineNum in range(len(content)):\n        # Process each line that was in the level file.\n        line = content[lineNum].rstrip(\'\\r\\n\')\n\n        if \';\' in line:\n            # Ignore the ; lines, they\'re comments in the level file.\n            line = line[:line.find(\';\')]\n\n        if line != \'\':\n            # This line is part of the map.\n            mapTextLines.append(line)\n        elif line == \'\' and len(mapTextLines) \x3E 0:\n            # A blank line indicates the end of a level\'s map in the file.\n            # Convert the text in mapTextLines into a level object.\n\n            # Find the longest row in the map.\n            maxWidth = -1\n            for i in range(len(mapTextLines)):\n                if len(mapTextLines[i]) \x3E maxWidth:\n                    maxWidth = len(mapTextLines[i])\n            # Add spaces to the ends of the shorter rows. This\n            # ensures the map will be rectangular.\n            for i in range(len(mapTextLines)):\n                mapTextLines[i] += \' \' * (maxWidth - len(mapTextLines[i]))\n\n            # Convert mapTextLines to a map object.\n            for x in range(len(mapTextLines[0])):\n                mapObj.append([])\n            for y in range(len(mapTextLines)):\n                for x in range(maxWidth):\n                    mapObj[x].append(mapTextLines[y][x])\n\n            # Loop through the spaces in the map and find the @, ., and $\n            # characters for the starting game state.\n            startx = None # The x and y for the player\'s starting position\n            starty = None\n            goals = [] # list of (x, y) tuples for each goal.\n            stars = [] # list of (x, y) for each star\'s starting position.\n            for x in range(maxWidth):\n                for y in range(len(mapObj[x])):\n                    if mapObj[x][y] in (\'@\', \'+\'):\n                        # \'@\' is player, \'+\' is player \& goal\n                        startx = x\n                        starty = y\n                    if mapObj[x][y] in (\'.\', \'+\', \'*\'):\n                        # \'.\' is goal, \'*\' is star \& goal\n                        goals.append((x, y))\n                    if mapObj[x][y] in (\'$\', \'*\'):\n                        # \'$\' is star\n                        stars.append((x, y))\n\n            # Basic level design sanity checks:\n            assert startx != None and starty != None, \'Level %s (around line %s) in %s is missing a \"@\" or \"+\" to mark the start point.\' % (levelNum+1, lineNum, filename)\n            assert len(goals) \x3E 0, \'Level %s (around line %s) in %s must have at least one goal.\' % (levelNum+1, lineNum, filename)\n            assert len(stars) \x3E= len(goals), \'Level %s (around line %s) in %s is impossible to solve. It has %s goals but only %s stars.\' % (levelNum+1, lineNum, filename, len(goals), len(stars))\n\n            # Create level object and starting game state object.\n            gameStateObj = {\'player\': (startx, starty),\n                            \'stepCounter\': 0,\n                            \'stars\': stars}\n            levelObj = {\'width\': maxWidth,\n                        \'height\': len(mapObj),\n                        \'mapObj\': mapObj,\n                        \'goals\': goals,\n                        \'startState\': gameStateObj}\n\n            levels.append(levelObj)\n\n            # Reset the variables for reading the next map.\n            mapTextLines = []\n            mapObj = []\n            gameStateObj = {}\n            levelNum += 1\n    return levels\n\n\ndef floodFill(mapObj, x, y, oldCharacter, newCharacter):\n    \"\"\"Changes any values matching oldCharacter on the map object to\n    newCharacter at the (x, y) position, and does the same for the\n    positions to the left, right, down, and up of (x, y), recursively.\"\"\"\n\n    # In this game, the flood fill algorithm creates the inside\x2Foutside\n    # floor distinction. This is a \"recursive\" function.\n    # For more info on the Flood Fill algorithm, see:\n    #   http:\x2F\x2Fen.wikipedia.org\x2Fwiki\x2FFlood_fill\n    if mapObj[x][y] == oldCharacter:\n        mapObj[x][y] = newCharacter\n\n    if x \x3C len(mapObj) - 1 and mapObj[x+1][y] == oldCharacter:\n        floodFill(mapObj, x+1, y, oldCharacter, newCharacter) # call right\n    if x \x3E 0 and mapObj[x-1][y] == oldCharacter:\n        floodFill(mapObj, x-1, y, oldCharacter, newCharacter) # call left\n    if y \x3C len(mapObj[x]) - 1 and mapObj[x][y+1] == oldCharacter:\n        floodFill(mapObj, x, y+1, oldCharacter, newCharacter) # call down\n    if y \x3E 0 and mapObj[x][y-1] == oldCharacter:\n        floodFill(mapObj, x, y-1, oldCharacter, newCharacter) # call up\n\n\ndef drawMap(mapObj, gameStateObj, goals):\n    \"\"\"Draws the map to a Surface object, including the player and\n    stars. This function does not call pygame.display.update(), nor\n    does it draw the \"Level\" and \"Steps\" text in the corner.\"\"\"\n\n    # mapSurf will be the single Surface object that the tiles are drawn\n    # on, so that it is easy to position the entire map on the DISPLAYSURF\n    # Surface object. First, the width and height must be calculated.\n    mapSurfWidth = len(mapObj) * TILEWIDTH\n    mapSurfHeight = (len(mapObj[0]) - 1) * TILEFLOORHEIGHT + TILEHEIGHT\n    mapSurf = pygame.Surface((mapSurfWidth, mapSurfHeight))\n    mapSurf.fill(BGCOLOR) # start with a blank color on the surface.\n\n    # Draw the tile sprites onto this surface.\n    for x in range(len(mapObj)):\n        for y in range(len(mapObj[x])):\n            spaceRect = pygame.Rect((x * TILEWIDTH, y * TILEFLOORHEIGHT, TILEWIDTH, TILEHEIGHT))\n            if mapObj[x][y] in TILEMAPPING:\n                baseTile = TILEMAPPING[mapObj[x][y]]\n            elif mapObj[x][y] in OUTSIDEDECOMAPPING:\n                baseTile = TILEMAPPING[\' \']\n\n            # First draw the base ground\x2Fwall tile.\n            mapSurf.blit(baseTile, spaceRect)\n\n            if mapObj[x][y] in OUTSIDEDECOMAPPING:\n                # Draw any tree\x2Frock decorations that are on this tile.\n                mapSurf.blit(OUTSIDEDECOMAPPING[mapObj[x][y]], spaceRect)\n            elif (x, y) in gameStateObj[\'stars\']:\n                if (x, y) in goals:\n                    # A goal AND star are on this space, draw goal first.\n                    mapSurf.blit(IMAGESDICT[\'covered goal\'], spaceRect)\n                # Then draw the star sprite.\n                mapSurf.blit(IMAGESDICT[\'star\'], spaceRect)\n            elif (x, y) in goals:\n                # Draw a goal without a star on it.\n                mapSurf.blit(IMAGESDICT[\'uncovered goal\'], spaceRect)\n\n            # Last draw the player on the board.\n            if (x, y) == gameStateObj[\'player\']:\n                # Note: The value \"currentImage\" refers\n                # to a key in \"PLAYERIMAGES\" which has the\n                # specific player image we want to show.\n                mapSurf.blit(PLAYERIMAGES[currentImage], spaceRect)\n\n    return mapSurf\n\n\ndef isLevelFinished(levelObj, gameStateObj):\n    \"\"\"Returns True if all the goals have stars in them.\"\"\"\n    for goal in levelObj[\'goals\']:\n        if goal not in gameStateObj[\'stars\']:\n            # Found a space with a goal but no star on it.\n            return False\n    return True\n\n\ndef terminate():\n    pygame.quit()\n    sys.exit()\n\n\nif __name__ == \'__main__\':\n    main()",
    "drawing": "import pygame, sys\nfrom pygame.locals import *\n\npygame.init()\n\n# set up the window\nDISPLAYSURF = pygame.display.set_mode((400, 300), 0, 32)\npygame.display.set_caption(\'Drawing\')\n\n# set up the colors\nBLACK = (  0,   0,   0)\nWHITE = (255, 255, 255)\nRED   = (255,   0,   0)\nGREEN = (  0, 255,   0)\nBLUE  = (  0,   0, 255)\n\n# draw on the surface object\nDISPLAYSURF.fill(WHITE)\npygame.draw.polygon(DISPLAYSURF, GREEN, ((146, 0), (291, 106), (236, 277), (56, 277), (0, 106)))\npygame.draw.line(DISPLAYSURF, BLUE, (60, 60), (120, 60), 4)\npygame.draw.line(DISPLAYSURF, BLUE, (120, 60), (60, 120))\npygame.draw.line(DISPLAYSURF, BLUE, (60, 120), (120, 120), 4)\npygame.draw.circle(DISPLAYSURF, BLUE, (300, 50), 20, 0)\npygame.draw.ellipse(DISPLAYSURF, RED, (300, 200, 40, 80), 1)\npygame.draw.rect(DISPLAYSURF, RED, (200, 150, 100, 50))\n\npixObj = pygame.PixelArray(DISPLAYSURF)\npixObj[380][280] = BLACK\npixObj[382][282] = BLACK\npixObj[384][284] = BLACK\npixObj[386][286] = BLACK\npixObj[388][288] = BLACK\ndel pixObj\n\n# run the game loop\nwhile True:\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n            sys.exit()\n    pygame.display.update()\n",
    "flippy": "# Flippy (an Othello or Reversi clone)\n# By Al Sweigart al@inventwithpython.com\n# http:\x2F\x2Finventwithpython.com\x2Fpygame\n# Released under a \"Simplified BSD\" license\n\n# Based on the \"reversi.py\" code that originally appeared in \"Invent\n# Your Own Computer Games with Python\", chapter 15:\n#   http:\x2F\x2Finventwithpython.com\x2Fchapter15.html\n\nimport random, sys, pygame, time, copy\nfrom pygame.locals import *\n\nFPS = 10 # frames per second to update the screen\nWINDOWWIDTH = 640 # width of the program\'s window, in pixels\nWINDOWHEIGHT = 480 # height in pixels\nSPACESIZE = 50 # width \& height of each space on the board, in pixels\nBOARDWIDTH = 8 # how many columns of spaces on the game board\nBOARDHEIGHT = 8 # how many rows of spaces on the game board\nWHITE_TILE = \'WHITE_TILE\' # an arbitrary but unique value\nBLACK_TILE = \'BLACK_TILE\' # an arbitrary but unique value\nEMPTY_SPACE = \'EMPTY_SPACE\' # an arbitrary but unique value\nHINT_TILE = \'HINT_TILE\' # an arbitrary but unique value\nANIMATIONSPEED = 25 # integer from 1 to 100, higher is faster animation\n\n# Amount of space on the left \& right side (XMARGIN) or above and below\n# (YMARGIN) the game board, in pixels.\nXMARGIN = int((WINDOWWIDTH - (BOARDWIDTH * SPACESIZE)) \x2F 2)\nYMARGIN = int((WINDOWHEIGHT - (BOARDHEIGHT * SPACESIZE)) \x2F 2)\n\n#              R    G    B\nWHITE      = (255, 255, 255)\nBLACK      = (  0,   0,   0)\nGREEN      = (  0, 155,   0)\nBRIGHTBLUE = (  0,  50, 255)\nBROWN      = (174,  94,   0)\n\nTEXTBGCOLOR1 = BRIGHTBLUE\nTEXTBGCOLOR2 = GREEN\nGRIDLINECOLOR = BLACK\nTEXTCOLOR = WHITE\nHINTCOLOR = BROWN\n\n\ndef main():\n    global MAINCLOCK, DISPLAYSURF, FONT, BIGFONT, BGIMAGE\n\n    pygame.init()\n    MAINCLOCK = pygame.time.Clock()\n    DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))\n    pygame.display.set_caption(\'Flippy\')\n    FONT = pygame.font.Font(\'freesansbold.ttf\', 16)\n    BIGFONT = pygame.font.Font(\'freesansbold.ttf\', 32)\n\n    # Set up the background image.\n    boardImage = pygame.image.load(\'flippyboard.png\')\n    # Use smoothscale() to stretch the board image to fit the entire board:\n    boardImage = pygame.transform.smoothscale(boardImage, (BOARDWIDTH * SPACESIZE, BOARDHEIGHT * SPACESIZE))\n    boardImageRect = boardImage.get_rect()\n    boardImageRect.topleft = (XMARGIN, YMARGIN)\n    BGIMAGE = pygame.image.load(\'flippybackground.png\')\n    # Use smoothscale() to stretch the background image to fit the entire window:\n    BGIMAGE = pygame.transform.smoothscale(BGIMAGE, (WINDOWWIDTH, WINDOWHEIGHT))\n    BGIMAGE.blit(boardImage, boardImageRect)\n\n    # Run the main game.\n    while True:\n        if runGame() == False:\n            break\n\n\ndef runGame():\n    # Plays a single game of reversi each time this function is called.\n\n    # Reset the board and game.\n    mainBoard = getNewBoard()\n    resetBoard(mainBoard)\n    showHints = False\n    turn = random.choice([\'computer\', \'player\'])\n\n    # Draw the starting board and ask the player what color they want.\n    drawBoard(mainBoard)\n    playerTile, computerTile = enterPlayerTile()\n\n    # Make the Surface and Rect objects for the \"New Game\" and \"Hints\" buttons\n    newGameSurf = FONT.render(\'New Game\', True, TEXTCOLOR, TEXTBGCOLOR2)\n    newGameRect = newGameSurf.get_rect()\n    newGameRect.topright = (WINDOWWIDTH - 8, 10)\n    hintsSurf = FONT.render(\'Hints\', True, TEXTCOLOR, TEXTBGCOLOR2)\n    hintsRect = hintsSurf.get_rect()\n    hintsRect.topright = (WINDOWWIDTH - 8, 40)\n\n    while True: # main game loop\n        # Keep looping for player and computer\'s turns.\n        if turn == \'player\':\n            # Player\'s turn:\n            if getValidMoves(mainBoard, playerTile) == []:\n                # If it\'s the player\'s turn but they\n                # can\'t move, then end the game.\n                break\n            movexy = None\n            while movexy == None:\n                # Keep looping until the player clicks on a valid space.\n\n                # Determine which board data structure to use for display.\n                if showHints:\n                    boardToDraw = getBoardWithValidMoves(mainBoard, playerTile)\n                else:\n                    boardToDraw = mainBoard\n\n                checkForQuit()\n                for event in pygame.event.get(): # event handling loop\n                    if event.type == MOUSEBUTTONUP:\n                        # Handle mouse click events\n                        mousex, mousey = event.pos\n                        if newGameRect.collidepoint( (mousex, mousey) ):\n                            # Start a new game\n                            return True\n                        elif hintsRect.collidepoint( (mousex, mousey) ):\n                            # Toggle hints mode\n                            showHints = not showHints\n                        # movexy is set to a two-item tuple XY coordinate, or None value\n                        movexy = getSpaceClicked(mousex, mousey)\n                        if movexy != None and not isValidMove(mainBoard, playerTile, movexy[0], movexy[1]):\n                            movexy = None\n\n                # Draw the game board.\n                drawBoard(boardToDraw)\n                drawInfo(boardToDraw, playerTile, computerTile, turn)\n\n                # Draw the \"New Game\" and \"Hints\" buttons.\n                DISPLAYSURF.blit(newGameSurf, newGameRect)\n                DISPLAYSURF.blit(hintsSurf, hintsRect)\n\n                MAINCLOCK.tick(FPS)\n                pygame.display.update()\n\n            # Make the move and end the turn.\n            makeMove(mainBoard, playerTile, movexy[0], movexy[1], True)\n            if getValidMoves(mainBoard, computerTile) != []:\n                # Only set for the computer\'s turn if it can make a move.\n                turn = \'computer\'\n\n        else:\n            # Computer\'s turn:\n            if getValidMoves(mainBoard, computerTile) == []:\n                # If it was set to be the computer\'s turn but\n                # they can\'t move, then end the game.\n                break\n\n            # Draw the board.\n            drawBoard(mainBoard)\n            drawInfo(mainBoard, playerTile, computerTile, turn)\n\n            # Draw the \"New Game\" and \"Hints\" buttons.\n            DISPLAYSURF.blit(newGameSurf, newGameRect)\n            DISPLAYSURF.blit(hintsSurf, hintsRect)\n\n            # Make it look like the computer is thinking by pausing a bit.\n            pauseUntil = time.time() + random.randint(5, 15) * 0.1\n            while time.time() \x3C pauseUntil:\n                pygame.display.update()\n\n            # Make the move and end the turn.\n            x, y = getComputerMove(mainBoard, computerTile)\n            makeMove(mainBoard, computerTile, x, y, True)\n            if getValidMoves(mainBoard, playerTile) != []:\n                # Only set for the player\'s turn if they can make a move.\n                turn = \'player\'\n\n    # Display the final score.\n    drawBoard(mainBoard)\n    scores = getScoreOfBoard(mainBoard)\n\n    # Determine the text of the message to display.\n    if scores[playerTile] \x3E scores[computerTile]:\n        text = \'You beat the computer by %s points! Congratulations!\' % \\\n               (scores[playerTile] - scores[computerTile])\n    elif scores[playerTile] \x3C scores[computerTile]:\n        text = \'You lost. The computer beat you by %s points.\' % \\\n               (scores[computerTile] - scores[playerTile])\n    else:\n        text = \'The game was a tie!\'\n\n    textSurf = FONT.render(text, True, TEXTCOLOR, TEXTBGCOLOR1)\n    textRect = textSurf.get_rect()\n    textRect.center = (int(WINDOWWIDTH \x2F 2), int(WINDOWHEIGHT \x2F 2))\n    DISPLAYSURF.blit(textSurf, textRect)\n\n    # Display the \"Play again?\" text with Yes and No buttons.\n    text2Surf = BIGFONT.render(\'Play again?\', True, TEXTCOLOR, TEXTBGCOLOR1)\n    text2Rect = text2Surf.get_rect()\n    text2Rect.center = (int(WINDOWWIDTH \x2F 2), int(WINDOWHEIGHT \x2F 2) + 50)\n\n    # Make \"Yes\" button.\n    yesSurf = BIGFONT.render(\'Yes\', True, TEXTCOLOR, TEXTBGCOLOR1)\n    yesRect = yesSurf.get_rect()\n    yesRect.center = (int(WINDOWWIDTH \x2F 2) - 60, int(WINDOWHEIGHT \x2F 2) + 90)\n\n    # Make \"No\" button.\n    noSurf = BIGFONT.render(\'No\', True, TEXTCOLOR, TEXTBGCOLOR1)\n    noRect = noSurf.get_rect()\n    noRect.center = (int(WINDOWWIDTH \x2F 2) + 60, int(WINDOWHEIGHT \x2F 2) + 90)\n\n    while True:\n        # Process events until the user clicks on Yes or No.\n        checkForQuit()\n        for event in pygame.event.get(): # event handling loop\n            if event.type == MOUSEBUTTONUP:\n                mousex, mousey = event.pos\n                if yesRect.collidepoint( (mousex, mousey) ):\n                    return True\n                elif noRect.collidepoint( (mousex, mousey) ):\n                    return False\n        DISPLAYSURF.blit(textSurf, textRect)\n        DISPLAYSURF.blit(text2Surf, text2Rect)\n        DISPLAYSURF.blit(yesSurf, yesRect)\n        DISPLAYSURF.blit(noSurf, noRect)\n        pygame.display.update()\n        MAINCLOCK.tick(FPS)\n\n\ndef translateBoardToPixelCoord(x, y):\n    return XMARGIN + x * SPACESIZE + int(SPACESIZE \x2F 2), YMARGIN + y * SPACESIZE + int(SPACESIZE \x2F 2)\n\n\ndef animateTileChange(tilesToFlip, tileColor, additionalTile):\n    # Draw the additional tile that was just laid down. (Otherwise we\'d\n    # have to completely redraw the board \& the board info.)\n    if tileColor == WHITE_TILE:\n        additionalTileColor = WHITE\n    else:\n        additionalTileColor = BLACK\n    additionalTileX, additionalTileY = translateBoardToPixelCoord(additionalTile[0], additionalTile[1])\n    pygame.draw.circle(DISPLAYSURF, additionalTileColor, (additionalTileX, additionalTileY), int(SPACESIZE \x2F 2) - 4)\n    pygame.display.update()\n\n    for rgbValues in range(0, 255, int(ANIMATIONSPEED * 2.55)):\n        if rgbValues \x3E 255:\n            rgbValues = 255\n        elif rgbValues \x3C 0:\n            rgbValues = 0\n\n        if tileColor == WHITE_TILE:\n            color = tuple([rgbValues] * 3) # rgbValues goes from 0 to 255\n        elif tileColor == BLACK_TILE:\n            color = tuple([255 - rgbValues] * 3) # rgbValues goes from 255 to 0\n\n        for x, y in tilesToFlip:\n            centerx, centery = translateBoardToPixelCoord(x, y)\n            pygame.draw.circle(DISPLAYSURF, color, (centerx, centery), int(SPACESIZE \x2F 2) - 4)\n        pygame.display.update()\n        MAINCLOCK.tick(FPS)\n        checkForQuit()\n\n\ndef drawBoard(board):\n    # Draw background of board.\n    DISPLAYSURF.blit(BGIMAGE, BGIMAGE.get_rect())\n\n    # Draw grid lines of the board.\n    for x in range(BOARDWIDTH + 1):\n        # Draw the horizontal lines.\n        startx = (x * SPACESIZE) + XMARGIN\n        starty = YMARGIN\n        endx = (x * SPACESIZE) + XMARGIN\n        endy = YMARGIN + (BOARDHEIGHT * SPACESIZE)\n        pygame.draw.line(DISPLAYSURF, GRIDLINECOLOR, (startx, starty), (endx, endy))\n    for y in range(BOARDHEIGHT + 1):\n        # Draw the vertical lines.\n        startx = XMARGIN\n        starty = (y * SPACESIZE) + YMARGIN\n        endx = XMARGIN + (BOARDWIDTH * SPACESIZE)\n        endy = (y * SPACESIZE) + YMARGIN\n        pygame.draw.line(DISPLAYSURF, GRIDLINECOLOR, (startx, starty), (endx, endy))\n\n    # Draw the black \& white tiles or hint spots.\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            centerx, centery = translateBoardToPixelCoord(x, y)\n            if board[x][y] == WHITE_TILE or board[x][y] == BLACK_TILE:\n                if board[x][y] == WHITE_TILE:\n                    tileColor = WHITE\n                else:\n                    tileColor = BLACK\n                pygame.draw.circle(DISPLAYSURF, tileColor, (centerx, centery), int(SPACESIZE \x2F 2) - 4)\n            if board[x][y] == HINT_TILE:\n                pygame.draw.rect(DISPLAYSURF, HINTCOLOR, (centerx - 4, centery - 4, 8, 8))\n\n\ndef getSpaceClicked(mousex, mousey):\n    # Return a tuple of two integers of the board space coordinates where\n    # the mouse was clicked. (Or returns None not in any space.)\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            if mousex \x3E x * SPACESIZE + XMARGIN and \\\n               mousex \x3C (x + 1) * SPACESIZE + XMARGIN and \\\n               mousey \x3E y * SPACESIZE + YMARGIN and \\\n               mousey \x3C (y + 1) * SPACESIZE + YMARGIN:\n                return (x, y)\n    return None\n\n\ndef drawInfo(board, playerTile, computerTile, turn):\n    # Draws scores and whose turn it is at the bottom of the screen.\n    scores = getScoreOfBoard(board)\n    scoreSurf = FONT.render(\"Player Score: %s    Computer Score: %s    %s\'s Turn\" % (str(scores[playerTile]), str(scores[computerTile]), turn.title()), True, TEXTCOLOR)\n    scoreRect = scoreSurf.get_rect()\n    scoreRect.bottomleft = (10, WINDOWHEIGHT - 5)\n    DISPLAYSURF.blit(scoreSurf, scoreRect)\n\n\ndef resetBoard(board):\n    # Blanks out the board it is passed, and sets up starting tiles.\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            board[x][y] = EMPTY_SPACE\n\n    # Add starting pieces to the center\n    board[3][3] = WHITE_TILE\n    board[3][4] = BLACK_TILE\n    board[4][3] = BLACK_TILE\n    board[4][4] = WHITE_TILE\n\n\ndef getNewBoard():\n    # Creates a brand new, empty board data structure.\n    board = []\n    for i in range(BOARDWIDTH):\n        board.append([EMPTY_SPACE] * BOARDHEIGHT)\n\n    return board\n\n\ndef isValidMove(board, tile, xstart, ystart):\n    # Returns False if the player\'s move is invalid. If it is a valid\n    # move, returns a list of spaces of the captured pieces.\n    if board[xstart][ystart] != EMPTY_SPACE or not isOnBoard(xstart, ystart):\n        return False\n\n    board[xstart][ystart] = tile # temporarily set the tile on the board.\n\n    if tile == WHITE_TILE:\n        otherTile = BLACK_TILE\n    else:\n        otherTile = WHITE_TILE\n\n    tilesToFlip = []\n    # check each of the eight directions:\n    for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:\n        x, y = xstart, ystart\n        x += xdirection\n        y += ydirection\n        if isOnBoard(x, y) and board[x][y] == otherTile:\n            # The piece belongs to the other player next to our piece.\n            x += xdirection\n            y += ydirection\n            if not isOnBoard(x, y):\n                continue\n            while board[x][y] == otherTile:\n                x += xdirection\n                y += ydirection\n                if not isOnBoard(x, y):\n                    break # break out of while loop, continue in for loop\n            if not isOnBoard(x, y):\n                continue\n            if board[x][y] == tile:\n                # There are pieces to flip over. Go in the reverse\n                # direction until we reach the original space, noting all\n                # the tiles along the way.\n                while True:\n                    x -= xdirection\n                    y -= ydirection\n                    if x == xstart and y == ystart:\n                        break\n                    tilesToFlip.append([x, y])\n\n    board[xstart][ystart] = EMPTY_SPACE # make space empty\n    if len(tilesToFlip) == 0: # If no tiles flipped, this move is invalid\n        return False\n    return tilesToFlip\n\n\ndef isOnBoard(x, y):\n    # Returns True if the coordinates are located on the board.\n    return x \x3E= 0 and x \x3C BOARDWIDTH and y \x3E= 0 and y \x3C BOARDHEIGHT\n\n\ndef getBoardWithValidMoves(board, tile):\n    # Returns a new board with hint markings.\n    dupeBoard = copy.deepcopy(board)\n\n    for x, y in getValidMoves(dupeBoard, tile):\n        dupeBoard[x][y] = HINT_TILE\n    return dupeBoard\n\n\ndef getValidMoves(board, tile):\n    # Returns a list of (x,y) tuples of all valid moves.\n    validMoves = []\n\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            if isValidMove(board, tile, x, y) != False:\n                validMoves.append((x, y))\n    return validMoves\n\n\ndef getScoreOfBoard(board):\n    # Determine the score by counting the tiles.\n    xscore = 0\n    oscore = 0\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            if board[x][y] == WHITE_TILE:\n                xscore += 1\n            if board[x][y] == BLACK_TILE:\n                oscore += 1\n    return {WHITE_TILE:xscore, BLACK_TILE:oscore}\n\n\ndef enterPlayerTile():\n    # Draws the text and handles the mouse click events for letting\n    # the player choose which color they want to be.  Returns\n    # [WHITE_TILE, BLACK_TILE] if the player chooses to be White,\n    # [BLACK_TILE, WHITE_TILE] if Black.\n\n    # Create the text.\n    textSurf = FONT.render(\'Do you want to be white or black?\', True, TEXTCOLOR, TEXTBGCOLOR1)\n    textRect = textSurf.get_rect()\n    textRect.center = (int(WINDOWWIDTH \x2F 2), int(WINDOWHEIGHT \x2F 2))\n\n    xSurf = BIGFONT.render(\'White\', True, TEXTCOLOR, TEXTBGCOLOR1)\n    xRect = xSurf.get_rect()\n    xRect.center = (int(WINDOWWIDTH \x2F 2) - 60, int(WINDOWHEIGHT \x2F 2) + 40)\n\n    oSurf = BIGFONT.render(\'Black\', True, TEXTCOLOR, TEXTBGCOLOR1)\n    oRect = oSurf.get_rect()\n    oRect.center = (int(WINDOWWIDTH \x2F 2) + 60, int(WINDOWHEIGHT \x2F 2) + 40)\n\n    while True:\n        # Keep looping until the player has clicked on a color.\n        checkForQuit()\n        for event in pygame.event.get(): # event handling loop\n            if event.type == MOUSEBUTTONUP:\n                mousex, mousey = event.pos\n                if xRect.collidepoint( (mousex, mousey) ):\n                    return [WHITE_TILE, BLACK_TILE]\n                elif oRect.collidepoint( (mousex, mousey) ):\n                    return [BLACK_TILE, WHITE_TILE]\n\n        # Draw the screen.\n        DISPLAYSURF.blit(textSurf, textRect)\n        DISPLAYSURF.blit(xSurf, xRect)\n        DISPLAYSURF.blit(oSurf, oRect)\n        pygame.display.update()\n        MAINCLOCK.tick(FPS)\n\n\ndef makeMove(board, tile, xstart, ystart, realMove=False):\n    # Place the tile on the board at xstart, ystart, and flip tiles\n    # Returns False if this is an invalid move, True if it is valid.\n    tilesToFlip = isValidMove(board, tile, xstart, ystart)\n\n    if tilesToFlip == False:\n        return False\n\n    board[xstart][ystart] = tile\n\n    if realMove:\n        animateTileChange(tilesToFlip, tile, (xstart, ystart))\n\n    for x, y in tilesToFlip:\n        board[x][y] = tile\n    return True\n\n\ndef isOnCorner(x, y):\n    # Returns True if the position is in one of the four corners.\n    return (x == 0 and y == 0) or \\\n           (x == BOARDWIDTH and y == 0) or \\\n           (x == 0 and y == BOARDHEIGHT) or \\\n           (x == BOARDWIDTH and y == BOARDHEIGHT)\n\n\ndef getComputerMove(board, computerTile):\n    # Given a board and the computer\'s tile, determine where to\n    # move and return that move as a [x, y] list.\n    possibleMoves = getValidMoves(board, computerTile)\n\n    # randomize the order of the possible moves\n    random.shuffle(possibleMoves)\n\n    # always go for a corner if available.\n    for x, y in possibleMoves:\n        if isOnCorner(x, y):\n            return [x, y]\n\n    # Go through all possible moves and remember the best scoring move\n    bestScore = -1\n    for x, y in possibleMoves:\n        dupeBoard = copy.deepcopy(board)\n        makeMove(dupeBoard, computerTile, x, y)\n        score = getScoreOfBoard(dupeBoard)[computerTile]\n        if score \x3E bestScore:\n            bestMove = [x, y]\n            bestScore = score\n    return bestMove\n\n\ndef checkForQuit():\n    for event in pygame.event.get((QUIT, KEYUP)): # event handling loop\n        if event.type == QUIT or (event.type == KEYUP and event.key == K_ESCAPE):\n            pygame.quit()\n            sys.exit()\n\n\nif __name__ == \'__main__\':\n    main()\n",
    "fourinarow": "# Four-In-A-Row (a Connect Four clone)\n# By Al Sweigart al@inventwithpython.com\n# http:\x2F\x2Finventwithpython.com\x2Fpygame\n# Released under a \"Simplified BSD\" license\n\nimport random, copy, sys, pygame\nfrom pygame.locals import *\n\nBOARDWIDTH = 7  # how many spaces wide the board is\nBOARDHEIGHT = 6 # how many spaces tall the board is\nassert BOARDWIDTH \x3E= 4 and BOARDHEIGHT \x3E= 4, \'Board must be at least 4x4.\'\n\nDIFFICULTY = 2 # how many moves to look ahead. (\x3E2 is usually too much)\n\nSPACESIZE = 50 # size of the tokens and individual board spaces in pixels\n\nFPS = 30 # frames per second to update the screen\nWINDOWWIDTH = 640 # width of the program\'s window, in pixels\nWINDOWHEIGHT = 480 # height in pixels\n\nXMARGIN = int((WINDOWWIDTH - BOARDWIDTH * SPACESIZE) \x2F 2)\nYMARGIN = int((WINDOWHEIGHT - BOARDHEIGHT * SPACESIZE) \x2F 2)\n\nBRIGHTBLUE = (0, 50, 255)\nWHITE = (255, 255, 255)\n\nBGCOLOR = BRIGHTBLUE\nTEXTCOLOR = WHITE\n\nRED = \'red\'\nBLACK = \'black\'\nEMPTY = None\nHUMAN = \'human\'\nCOMPUTER = \'computer\'\n\n\ndef main():\n    global FPSCLOCK, DISPLAYSURF, REDPILERECT, BLACKPILERECT, REDTOKENIMG\n    global BLACKTOKENIMG, BOARDIMG, ARROWIMG, ARROWRECT, HUMANWINNERIMG\n    global COMPUTERWINNERIMG, WINNERRECT, TIEWINNERIMG\n\n    pygame.init()\n    FPSCLOCK = pygame.time.Clock()\n    DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))\n    pygame.display.set_caption(\'Four in a Row\')\n\n    REDPILERECT = pygame.Rect(int(SPACESIZE \x2F 2), WINDOWHEIGHT - int(3 * SPACESIZE \x2F 2), SPACESIZE, SPACESIZE)\n    BLACKPILERECT = pygame.Rect(WINDOWWIDTH - int(3 * SPACESIZE \x2F 2), WINDOWHEIGHT - int(3 * SPACESIZE \x2F 2), SPACESIZE, SPACESIZE)\n    REDTOKENIMG = pygame.image.load(\'4row_red.png\')\n    REDTOKENIMG = pygame.transform.smoothscale(REDTOKENIMG, (SPACESIZE, SPACESIZE))\n    BLACKTOKENIMG = pygame.image.load(\'4row_black.png\')\n    BLACKTOKENIMG = pygame.transform.smoothscale(BLACKTOKENIMG, (SPACESIZE, SPACESIZE))\n    BOARDIMG = pygame.image.load(\'4row_board.png\')\n    BOARDIMG = pygame.transform.smoothscale(BOARDIMG, (SPACESIZE, SPACESIZE))\n\n    HUMANWINNERIMG = pygame.image.load(\'4row_humanwinner.png\')\n    COMPUTERWINNERIMG = pygame.image.load(\'4row_computerwinner.png\')\n    TIEWINNERIMG = pygame.image.load(\'4row_tie.png\')\n    WINNERRECT = HUMANWINNERIMG.get_rect()\n    WINNERRECT.center = (int(WINDOWWIDTH \x2F 2), int(WINDOWHEIGHT \x2F 2))\n\n    ARROWIMG = pygame.image.load(\'4row_arrow.png\')\n    ARROWRECT = ARROWIMG.get_rect()\n    ARROWRECT.left = REDPILERECT.right + 10\n    ARROWRECT.centery = REDPILERECT.centery\n\n    isFirstGame = True\n\n    while True:\n        runGame(isFirstGame)\n        isFirstGame = False\n\n\ndef runGame(isFirstGame):\n    if isFirstGame:\n        # Let the computer go first on the first game, so the player\n        # can see how the tokens are dragged from the token piles.\n        turn = COMPUTER\n        showHelp = True\n    else:\n        # Randomly choose who goes first.\n        if random.randint(0, 1) == 0:\n            turn = COMPUTER\n        else:\n            turn = HUMAN\n        showHelp = False\n\n    # Set up a blank board data structure.\n    mainBoard = getNewBoard()\n\n    while True: # main game loop\n        if turn == HUMAN:\n            # Human player\'s turn.\n            getHumanMove(mainBoard, showHelp)\n            if showHelp:\n                # turn off help arrow after the first move\n                showHelp = False\n            if isWinner(mainBoard, RED):\n                winnerImg = HUMANWINNERIMG\n                break\n            turn = COMPUTER # switch to other player\'s turn\n        else:\n            # Computer player\'s turn.\n            column = getComputerMove(mainBoard)\n            animateComputerMoving(mainBoard, column)\n            makeMove(mainBoard, BLACK, column)\n            if isWinner(mainBoard, BLACK):\n                winnerImg = COMPUTERWINNERIMG\n                break\n            turn = HUMAN # switch to other player\'s turn\n\n        if isBoardFull(mainBoard):\n            # A completely filled board means it\'s a tie.\n            winnerImg = TIEWINNERIMG\n            break\n\n    while True:\n        # Keep looping until player clicks the mouse or quits.\n        drawBoard(mainBoard)\n        DISPLAYSURF.blit(winnerImg, WINNERRECT)\n        pygame.display.update()\n        FPSCLOCK.tick()\n        for event in pygame.event.get(): # event handling loop\n            if event.type == QUIT or (event.type == KEYUP and event.key == K_ESCAPE):\n                pygame.quit()\n                sys.exit()\n            elif event.type == MOUSEBUTTONUP:\n                return\n\n\ndef makeMove(board, player, column):\n    lowest = getLowestEmptySpace(board, column)\n    if lowest != -1:\n        board[column][lowest] = player\n\n\ndef drawBoard(board, extraToken=None):\n    DISPLAYSURF.fill(BGCOLOR)\n\n    # draw tokens\n    spaceRect = pygame.Rect(0, 0, SPACESIZE, SPACESIZE)\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            spaceRect.topleft = (XMARGIN + (x * SPACESIZE), YMARGIN + (y * SPACESIZE))\n            if board[x][y] == RED:\n                DISPLAYSURF.blit(REDTOKENIMG, spaceRect)\n            elif board[x][y] == BLACK:\n                DISPLAYSURF.blit(BLACKTOKENIMG, spaceRect)\n\n    # draw the extra token\n    if extraToken != None:\n        if extraToken[\'color\'] == RED:\n            DISPLAYSURF.blit(REDTOKENIMG, (extraToken[\'x\'], extraToken[\'y\'], SPACESIZE, SPACESIZE))\n        elif extraToken[\'color\'] == BLACK:\n            DISPLAYSURF.blit(BLACKTOKENIMG, (extraToken[\'x\'], extraToken[\'y\'], SPACESIZE, SPACESIZE))\n\n    # draw board over the tokens\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            spaceRect.topleft = (XMARGIN + (x * SPACESIZE), YMARGIN + (y * SPACESIZE))\n            DISPLAYSURF.blit(BOARDIMG, spaceRect)\n\n    # draw the red and black tokens off to the side\n    DISPLAYSURF.blit(REDTOKENIMG, REDPILERECT) # red on the left\n    DISPLAYSURF.blit(BLACKTOKENIMG, BLACKPILERECT) # black on the right\n\n\ndef getNewBoard():\n    board = []\n    for x in range(BOARDWIDTH):\n        board.append([EMPTY] * BOARDHEIGHT)\n    return board\n\n\ndef getHumanMove(board, isFirstMove):\n    draggingToken = False\n    tokenx, tokeny = None, None\n    while True:\n        for event in pygame.event.get(): # event handling loop\n            if event.type == QUIT:\n                pygame.quit()\n                sys.exit()\n            elif event.type == MOUSEBUTTONDOWN and not draggingToken and REDPILERECT.collidepoint(event.pos):\n                # start of dragging on red token pile.\n                draggingToken = True\n                tokenx, tokeny = event.pos\n            elif event.type == MOUSEMOTION and draggingToken:\n                # update the position of the red token being dragged\n                tokenx, tokeny = event.pos\n            elif event.type == MOUSEBUTTONUP and draggingToken:\n                # let go of the token being dragged\n                if tokeny \x3C YMARGIN and tokenx \x3E XMARGIN and tokenx \x3C WINDOWWIDTH - XMARGIN:\n                    # let go at the top of the screen.\n                    column = int((tokenx - XMARGIN) \x2F SPACESIZE)\n                    if isValidMove(board, column):\n                        animateDroppingToken(board, column, RED)\n                        board[column][getLowestEmptySpace(board, column)] = RED\n                        drawBoard(board)\n                        pygame.display.update()\n                        return\n                tokenx, tokeny = None, None\n                draggingToken = False\n        if tokenx != None and tokeny != None:\n            drawBoard(board, {\'x\':tokenx - int(SPACESIZE \x2F 2), \'y\':tokeny - int(SPACESIZE \x2F 2), \'color\':RED})\n        else:\n            drawBoard(board)\n\n        if isFirstMove:\n            # Show the help arrow for the player\'s first move.\n            DISPLAYSURF.blit(ARROWIMG, ARROWRECT)\n\n        pygame.display.update()\n        FPSCLOCK.tick()\n\n\ndef animateDroppingToken(board, column, color):\n    x = XMARGIN + column * SPACESIZE\n    y = YMARGIN - SPACESIZE\n    dropSpeed = 1.0\n\n    lowestEmptySpace = getLowestEmptySpace(board, column)\n\n    while True:\n        y += int(dropSpeed)\n        dropSpeed += 0.5\n        if int((y - YMARGIN) \x2F SPACESIZE) \x3E= lowestEmptySpace:\n            return\n        drawBoard(board, {\'x\':x, \'y\':y, \'color\':color})\n        pygame.display.update()\n        FPSCLOCK.tick()\n\n\ndef animateComputerMoving(board, column):\n    x = BLACKPILERECT.left\n    y = BLACKPILERECT.top\n    speed = 1.0\n    # moving the black tile up\n    while y \x3E (YMARGIN - SPACESIZE):\n        y -= int(speed)\n        speed += 0.5\n        drawBoard(board, {\'x\':x, \'y\':y, \'color\':BLACK})\n        pygame.display.update()\n        FPSCLOCK.tick()\n    # moving the black tile over\n    y = YMARGIN - SPACESIZE\n    speed = 1.0\n    while x \x3E (XMARGIN + column * SPACESIZE):\n        x -= int(speed)\n        speed += 0.5\n        drawBoard(board, {\'x\':x, \'y\':y, \'color\':BLACK})\n        pygame.display.update()\n        FPSCLOCK.tick()\n    # dropping the black tile\n    animateDroppingToken(board, column, BLACK)\n\n\ndef getComputerMove(board):\n    potentialMoves = getPotentialMoves(board, BLACK, DIFFICULTY)\n    # get the best fitness from the potential moves\n    bestMoveFitness = -1\n    for i in range(BOARDWIDTH):\n        if potentialMoves[i] \x3E bestMoveFitness and isValidMove(board, i):\n            bestMoveFitness = potentialMoves[i]\n    # find all potential moves that have this best fitness\n    bestMoves = []\n    for i in range(len(potentialMoves)):\n        if potentialMoves[i] == bestMoveFitness and isValidMove(board, i):\n            bestMoves.append(i)\n    return random.choice(bestMoves)\n\n\ndef getPotentialMoves(board, tile, lookAhead):\n    if lookAhead == 0 or isBoardFull(board):\n        return [0] * BOARDWIDTH\n\n    if tile == RED:\n        enemyTile = BLACK\n    else:\n        enemyTile = RED\n\n    # Figure out the best move to make.\n    potentialMoves = [0] * BOARDWIDTH\n    for firstMove in range(BOARDWIDTH):\n        dupeBoard = copy.deepcopy(board)\n        if not isValidMove(dupeBoard, firstMove):\n            continue\n        makeMove(dupeBoard, tile, firstMove)\n        if isWinner(dupeBoard, tile):\n            # a winning move automatically gets a perfect fitness\n            potentialMoves[firstMove] = 1\n            break # don\'t bother calculating other moves\n        else:\n            # do other player\'s counter moves and determine best one\n            if isBoardFull(dupeBoard):\n                potentialMoves[firstMove] = 0\n            else:\n                for counterMove in range(BOARDWIDTH):\n                    dupeBoard2 = copy.deepcopy(dupeBoard)\n                    if not isValidMove(dupeBoard2, counterMove):\n                        continue\n                    makeMove(dupeBoard2, enemyTile, counterMove)\n                    if isWinner(dupeBoard2, enemyTile):\n                        # a losing move automatically gets the worst fitness\n                        potentialMoves[firstMove] = -1\n                        break\n                    else:\n                        # do the recursive call to getPotentialMoves()\n                        results = getPotentialMoves(dupeBoard2, tile, lookAhead - 1)\n                        potentialMoves[firstMove] += (sum(results) \x2F BOARDWIDTH) \x2F BOARDWIDTH\n    return potentialMoves\n\n\ndef getLowestEmptySpace(board, column):\n    # Return the row number of the lowest empty row in the given column.\n    for y in range(BOARDHEIGHT-1, -1, -1):\n        if board[column][y] == EMPTY:\n            return y\n    return -1\n\n\ndef isValidMove(board, column):\n    # Returns True if there is an empty space in the given column.\n    # Otherwise returns False.\n    if column \x3C 0 or column \x3E= (BOARDWIDTH) or board[column][0] != EMPTY:\n        return False\n    return True\n\n\ndef isBoardFull(board):\n    # Returns True if there are no empty spaces anywhere on the board.\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            if board[x][y] == EMPTY:\n                return False\n    return True\n\n\ndef isWinner(board, tile):\n    # check horizontal spaces\n    for x in range(BOARDWIDTH - 3):\n        for y in range(BOARDHEIGHT):\n            if board[x][y] == tile and board[x+1][y] == tile and board[x+2][y] == tile and board[x+3][y] == tile:\n                return True\n    # check vertical spaces\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT - 3):\n            if board[x][y] == tile and board[x][y+1] == tile and board[x][y+2] == tile and board[x][y+3] == tile:\n                return True\n    # check \x2F diagonal spaces\n    for x in range(BOARDWIDTH - 3):\n        for y in range(3, BOARDHEIGHT):\n            if board[x][y] == tile and board[x+1][y-1] == tile and board[x+2][y-2] == tile and board[x+3][y-3] == tile:\n                return True\n    # check \\ diagonal spaces\n    for x in range(BOARDWIDTH - 3):\n        for y in range(BOARDHEIGHT - 3):\n            if board[x][y] == tile and board[x+1][y+1] == tile and board[x+2][y+2] == tile and board[x+3][y+3] == tile:\n                return True\n    return False\n\n\nif __name__ == \'__main__\':\n    main()\n",
    "gemgem": "# Gemgem (a Bejeweled clone)\n# By Al Sweigart al@inventwithpython.com\n# http:\x2F\x2Finventwithpython.com\x2Fpygame\n# Released under a \"Simplified BSD\" license\n\n\"\"\"\nThis program has \"gem data structures\", which are basically dictionaries\nwith the following keys:\n  \'x\' and \'y\' - The location of the gem on the board. 0,0 is the top left.\n                There is also a ROWABOVEBOARD row that \'y\' can be set to,\n                to indicate that it is above the board.\n  \'direction\' - one of the four constant variables UP, DOWN, LEFT, RIGHT.\n                This is the direction the gem is moving.\n  \'imageNum\'  - The integer index into GEMIMAGES to denote which image\n                this gem uses.\n\"\"\"\n\nimport random, time, pygame, sys, copy\nfrom pygame.locals import *\n\nFPS = 30 # frames per second to update the screen\nWINDOWWIDTH = 600  # width of the program\'s window, in pixels\nWINDOWHEIGHT = 600 # height in pixels\n\nBOARDWIDTH = 8 # how many columns in the board\nBOARDHEIGHT = 8 # how many rows in the board\nGEMIMAGESIZE = 64 # width \& height of each space in pixels\n\n# NUMGEMIMAGES is the number of gem types. You will need .png image\n# files named gem0.png, gem1.png, etc. up to gem(N-1).png.\nNUMGEMIMAGES = 7\nassert NUMGEMIMAGES \x3E= 5 # game needs at least 5 types of gems to work\n\n# NUMMATCHSOUNDS is the number of different sounds to choose from when\n# a match is made. The .wav files are named match0.wav, match1.wav, etc.\nNUMMATCHSOUNDS = 6\n\nMOVERATE = 25 # 1 to 100, larger num means faster animations\nDEDUCTSPEED = 0.8 # reduces score by 1 point every DEDUCTSPEED seconds.\n\n#             R    G    B\nPURPLE    = (255,   0, 255)\nLIGHTBLUE = (170, 190, 255)\nBLUE      = (  0,   0, 255)\nRED       = (255, 100, 100)\nBLACK     = (  0,   0,   0)\nBROWN     = ( 85,  65,   0)\nHIGHLIGHTCOLOR = PURPLE # color of the selected gem\'s border\nBGCOLOR = LIGHTBLUE # background color on the screen\nGRIDCOLOR = BLUE # color of the game board\nGAMEOVERCOLOR = RED # color of the \"Game over\" text.\nGAMEOVERBGCOLOR = BLACK # background color of the \"Game over\" text.\nSCORECOLOR = BROWN # color of the text for the player\'s score\n\n# The amount of space to the sides of the board to the edge of the window\n# is used several times, so calculate it once here and store in variables.\nXMARGIN = int((WINDOWWIDTH - GEMIMAGESIZE * BOARDWIDTH) \x2F 2)\nYMARGIN = int((WINDOWHEIGHT - GEMIMAGESIZE * BOARDHEIGHT) \x2F 2)\n\n# constants for direction values\nUP = \'up\'\nDOWN = \'down\'\nLEFT = \'left\'\nRIGHT = \'right\'\n\nEMPTY_SPACE = -1 # an arbitrary, nonpositive value\nROWABOVEBOARD = \'row above board\' # an arbitrary, noninteger value\n\ndef main():\n    global FPSCLOCK, DISPLAYSURF, GEMIMAGES, GAMESOUNDS, BASICFONT, BOARDRECTS\n\n    # Initial set up.\n    pygame.init()\n    FPSCLOCK = pygame.time.Clock()\n    DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))\n    pygame.display.set_caption(\'Gemgem\')\n    BASICFONT = pygame.font.Font(\'freesansbold.ttf\', 36)\n\n    # Load the images\n    GEMIMAGES = []\n    for i in range(1, NUMGEMIMAGES+1):\n        gemImage = pygame.image.load(\'gem%s.png\' % i)\n        if gemImage.get_size() != (GEMIMAGESIZE, GEMIMAGESIZE):\n            gemImage = pygame.transform.smoothscale(gemImage, (GEMIMAGESIZE, GEMIMAGESIZE))\n        GEMIMAGES.append(gemImage)\n\n    # Load the sounds.\n    GAMESOUNDS = {}\n    GAMESOUNDS[\'bad swap\'] = pygame.mixer.Sound(\'badswap.wav\')\n    GAMESOUNDS[\'match\'] = []\n    for i in range(NUMMATCHSOUNDS):\n        GAMESOUNDS[\'match\'].append(pygame.mixer.Sound(\'match%s.wav\' % i))\n\n    # Create pygame.Rect objects for each board space to\n    # do board-coordinate-to-pixel-coordinate conversions.\n    BOARDRECTS = []\n    for x in range(BOARDWIDTH):\n        BOARDRECTS.append([])\n        for y in range(BOARDHEIGHT):\n            r = pygame.Rect((XMARGIN + (x * GEMIMAGESIZE),\n                             YMARGIN + (y * GEMIMAGESIZE),\n                             GEMIMAGESIZE,\n                             GEMIMAGESIZE))\n            BOARDRECTS[x].append(r)\n\n    while True:\n        runGame()\n\n\ndef runGame():\n    # Plays through a single game. When the game is over, this function returns.\n\n    # initalize the board\n    gameBoard = getBlankBoard()\n    score = 0\n    fillBoardAndAnimate(gameBoard, [], score) # Drop the initial gems.\n\n    # initialize variables for the start of a new game\n    firstSelectedGem = None\n    lastMouseDownX = None\n    lastMouseDownY = None\n    gameIsOver = False\n    lastScoreDeduction = time.time()\n    clickContinueTextSurf = None\n\n    while True: # main game loop\n        clickedSpace = None\n        for event in pygame.event.get(): # event handling loop\n            if event.type == QUIT or (event.type == KEYUP and event.key == K_ESCAPE):\n                pygame.quit()\n                sys.exit()\n            elif event.type == KEYUP and event.key == K_BACKSPACE:\n                return # start a new game\n\n            elif event.type == MOUSEBUTTONUP:\n                if gameIsOver:\n                    return # after games ends, click to start a new game\n\n                if event.pos == (lastMouseDownX, lastMouseDownY):\n                    # This event is a mouse click, not the end of a mouse drag.\n                    clickedSpace = checkForGemClick(event.pos)\n                else:\n                    # this is the end of a mouse drag\n                    firstSelectedGem = checkForGemClick((lastMouseDownX, lastMouseDownY))\n                    clickedSpace = checkForGemClick(event.pos)\n                    if not firstSelectedGem or not clickedSpace:\n                        # if not part of a valid drag, deselect both\n                        firstSelectedGem = None\n                        clickedSpace = None\n            elif event.type == MOUSEBUTTONDOWN:\n                # this is the start of a mouse click or mouse drag\n                lastMouseDownX, lastMouseDownY = event.pos\n\n        if clickedSpace and not firstSelectedGem:\n            # This was the first gem clicked on.\n            firstSelectedGem = clickedSpace\n        elif clickedSpace and firstSelectedGem:\n            # Two gems have been clicked on and selected. Swap the gems.\n            firstSwappingGem, secondSwappingGem = getSwappingGems(gameBoard, firstSelectedGem, clickedSpace)\n            if firstSwappingGem == None and secondSwappingGem == None:\n                # If both are None, then the gems were not adjacent\n                firstSelectedGem = None # deselect the first gem\n                continue\n\n            # Show the swap animation on the screen.\n            boardCopy = getBoardCopyMinusGems(gameBoard, (firstSwappingGem, secondSwappingGem))\n            animateMovingGems(boardCopy, [firstSwappingGem, secondSwappingGem], [], score)\n\n            # Swap the gems in the board data structure.\n            gameBoard[firstSwappingGem[\'x\']][firstSwappingGem[\'y\']] = secondSwappingGem[\'imageNum\']\n            gameBoard[secondSwappingGem[\'x\']][secondSwappingGem[\'y\']] = firstSwappingGem[\'imageNum\']\n\n            # See if this is a matching move.\n            matchedGems = findMatchingGems(gameBoard)\n            if matchedGems == []:\n                # Was not a matching move; swap the gems back\n                GAMESOUNDS[\'bad swap\'].play()\n                animateMovingGems(boardCopy, [firstSwappingGem, secondSwappingGem], [], score)\n                gameBoard[firstSwappingGem[\'x\']][firstSwappingGem[\'y\']] = firstSwappingGem[\'imageNum\']\n                gameBoard[secondSwappingGem[\'x\']][secondSwappingGem[\'y\']] = secondSwappingGem[\'imageNum\']\n            else:\n                # This was a matching move.\n                scoreAdd = 0\n                while matchedGems != []:\n                    # Remove matched gems, then pull down the board.\n\n                    # points is a list of dicts that tells fillBoardAndAnimate()\n                    # where on the screen to display text to show how many\n                    # points the player got. points is a list because if\n                    # the playergets multiple matches, then multiple points text should appear.\n                    points = []\n                    for gemSet in matchedGems:\n                        scoreAdd += (10 + (len(gemSet) - 3) * 10)\n                        for gem in gemSet:\n                            gameBoard[gem[0]][gem[1]] = EMPTY_SPACE\n                        points.append({\'points\': scoreAdd,\n                                       \'x\': gem[0] * GEMIMAGESIZE + XMARGIN,\n                                       \'y\': gem[1] * GEMIMAGESIZE + YMARGIN})\n                    random.choice(GAMESOUNDS[\'match\']).play()\n                    score += scoreAdd\n\n                    # Drop the new gems.\n                    fillBoardAndAnimate(gameBoard, points, score)\n\n                    # Check if there are any new matches.\n                    matchedGems = findMatchingGems(gameBoard)\n            firstSelectedGem = None\n\n            if not canMakeMove(gameBoard):\n                gameIsOver = True\n\n        # Draw the board.\n        DISPLAYSURF.fill(BGCOLOR)\n        drawBoard(gameBoard)\n        if firstSelectedGem != None:\n            highlightSpace(firstSelectedGem[\'x\'], firstSelectedGem[\'y\'])\n        if gameIsOver:\n            if clickContinueTextSurf == None:\n                # Only render the text once. In future iterations, just\n                # use the Surface object already in clickContinueTextSurf\n                clickContinueTextSurf = BASICFONT.render(\'Final Score: %s (Click to continue)\' % (score), 1, GAMEOVERCOLOR, GAMEOVERBGCOLOR)\n                clickContinueTextRect = clickContinueTextSurf.get_rect()\n                clickContinueTextRect.center = int(WINDOWWIDTH \x2F 2), int(WINDOWHEIGHT \x2F 2)\n            DISPLAYSURF.blit(clickContinueTextSurf, clickContinueTextRect)\n        elif score \x3E 0 and time.time() - lastScoreDeduction \x3E DEDUCTSPEED:\n            # score drops over time\n            score -= 1\n            lastScoreDeduction = time.time()\n        drawScore(score)\n        pygame.display.update()\n        FPSCLOCK.tick(FPS)\n\n\ndef getSwappingGems(board, firstXY, secondXY):\n    # If the gems at the (X, Y) coordinates of the two gems are adjacent,\n    # then their \'direction\' keys are set to the appropriate direction\n    # value to be swapped with each other.\n    # Otherwise, (None, None) is returned.\n    firstGem = {\'imageNum\': board[firstXY[\'x\']][firstXY[\'y\']],\n                \'x\': firstXY[\'x\'],\n                \'y\': firstXY[\'y\']}\n    secondGem = {\'imageNum\': board[secondXY[\'x\']][secondXY[\'y\']],\n                 \'x\': secondXY[\'x\'],\n                 \'y\': secondXY[\'y\']}\n    highlightedGem = None\n    if firstGem[\'x\'] == secondGem[\'x\'] + 1 and firstGem[\'y\'] == secondGem[\'y\']:\n        firstGem[\'direction\'] = LEFT\n        secondGem[\'direction\'] = RIGHT\n    elif firstGem[\'x\'] == secondGem[\'x\'] - 1 and firstGem[\'y\'] == secondGem[\'y\']:\n        firstGem[\'direction\'] = RIGHT\n        secondGem[\'direction\'] = LEFT\n    elif firstGem[\'y\'] == secondGem[\'y\'] + 1 and firstGem[\'x\'] == secondGem[\'x\']:\n        firstGem[\'direction\'] = UP\n        secondGem[\'direction\'] = DOWN\n    elif firstGem[\'y\'] == secondGem[\'y\'] - 1 and firstGem[\'x\'] == secondGem[\'x\']:\n        firstGem[\'direction\'] = DOWN\n        secondGem[\'direction\'] = UP\n    else:\n        # These gems are not adjacent and can\'t be swapped.\n        return None, None\n    return firstGem, secondGem\n\n\ndef getBlankBoard():\n    # Create and return a blank board data structure.\n    board = []\n    for x in range(BOARDWIDTH):\n        board.append([EMPTY_SPACE] * BOARDHEIGHT)\n    return board\n\n\ndef canMakeMove(board):\n    # Return True if the board is in a state where a matching\n    # move can be made on it. Otherwise return False.\n\n    # The patterns in oneOffPatterns represent gems that are configured\n    # in a way where it only takes one move to make a triplet.\n    oneOffPatterns = (((0,1), (1,0), (2,0)),\n                      ((0,1), (1,1), (2,0)),\n                      ((0,0), (1,1), (2,0)),\n                      ((0,1), (1,0), (2,1)),\n                      ((0,0), (1,0), (2,1)),\n                      ((0,0), (1,1), (2,1)),\n                      ((0,0), (0,2), (0,3)),\n                      ((0,0), (0,1), (0,3)))\n\n    # The x and y variables iterate over each space on the board.\n    # If we use + to represent the currently iterated space on the\n    # board, then this pattern: ((0,1), (1,0), (2,0))refers to identical\n    # gems being set up like this:\n    #\n    #     +A\n    #     B\n    #     C\n    #\n    # That is, gem A is offset from the + by (0,1), gem B is offset\n    # by (1,0), and gem C is offset by (2,0). In this case, gem A can\n    # be swapped to the left to form a vertical three-in-a-row triplet.\n    #\n    # There are eight possible ways for the gems to be one move\n    # away from forming a triple, hence oneOffPattern has 8 patterns.\n\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            for pat in oneOffPatterns:\n                # check each possible pattern of \"match in next move\" to\n                # see if a possible move can be made.\n                if (getGemAt(board, x+pat[0][0], y+pat[0][1]) == \\\n                    getGemAt(board, x+pat[1][0], y+pat[1][1]) == \\\n                    getGemAt(board, x+pat[2][0], y+pat[2][1]) != None) or \\\n                   (getGemAt(board, x+pat[0][1], y+pat[0][0]) == \\\n                    getGemAt(board, x+pat[1][1], y+pat[1][0]) == \\\n                    getGemAt(board, x+pat[2][1], y+pat[2][0]) != None):\n                    return True # return True the first time you find a pattern\n    return False\n\n\ndef drawMovingGem(gem, progress):\n    # Draw a gem sliding in the direction that its \'direction\' key\n    # indicates. The progress parameter is a number from 0 (just\n    # starting) to 100 (slide complete).\n    movex = 0\n    movey = 0\n    progress *= 0.01\n\n    if gem[\'direction\'] == UP:\n        movey = -int(progress * GEMIMAGESIZE)\n    elif gem[\'direction\'] == DOWN:\n        movey = int(progress * GEMIMAGESIZE)\n    elif gem[\'direction\'] == RIGHT:\n        movex = int(progress * GEMIMAGESIZE)\n    elif gem[\'direction\'] == LEFT:\n        movex = -int(progress * GEMIMAGESIZE)\n\n    basex = gem[\'x\']\n    basey = gem[\'y\']\n    if basey == ROWABOVEBOARD:\n        basey = -1\n\n    pixelx = XMARGIN + (basex * GEMIMAGESIZE)\n    pixely = YMARGIN + (basey * GEMIMAGESIZE)\n    r = pygame.Rect( (pixelx + movex, pixely + movey, GEMIMAGESIZE, GEMIMAGESIZE) )\n    DISPLAYSURF.blit(GEMIMAGES[gem[\'imageNum\']], r)\n\n\ndef pullDownAllGems(board):\n    # pulls down gems on the board to the bottom to fill in any gaps\n    for x in range(BOARDWIDTH):\n        gemsInColumn = []\n        for y in range(BOARDHEIGHT):\n            if board[x][y] != EMPTY_SPACE:\n                gemsInColumn.append(board[x][y])\n        board[x] = ([EMPTY_SPACE] * (BOARDHEIGHT - len(gemsInColumn))) + gemsInColumn\n\n\ndef getGemAt(board, x, y):\n    if x \x3C 0 or y \x3C 0 or x \x3E= BOARDWIDTH or y \x3E= BOARDHEIGHT:\n        return None\n    else:\n        return board[x][y]\n\n\ndef getDropSlots(board):\n    # Creates a \"drop slot\" for each column and fills the slot with a\n    # number of gems that that column is lacking. This function assumes\n    # that the gems have been gravity dropped already.\n    boardCopy = copy.deepcopy(board)\n    pullDownAllGems(boardCopy)\n\n    dropSlots = []\n    for i in range(BOARDWIDTH):\n        dropSlots.append([])\n\n    # count the number of empty spaces in each column on the board\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT-1, -1, -1): # start from bottom, going up\n            if boardCopy[x][y] == EMPTY_SPACE:\n                possibleGems = list(range(len(GEMIMAGES)))\n                for offsetX, offsetY in ((0, -1), (1, 0), (0, 1), (-1, 0)):\n                    # Narrow down the possible gems we should put in the\n                    # blank space so we don\'t end up putting an two of\n                    # the same gems next to each other when they drop.\n                    neighborGem = getGemAt(boardCopy, x + offsetX, y + offsetY)\n                    if neighborGem != None and neighborGem in possibleGems:\n                        possibleGems.remove(neighborGem)\n\n                newGem = random.choice(possibleGems)\n                boardCopy[x][y] = newGem\n                dropSlots[x].append(newGem)\n    return dropSlots\n\n\ndef findMatchingGems(board):\n    gemsToRemove = [] # a list of lists of gems in matching triplets that should be removed\n    boardCopy = copy.deepcopy(board)\n\n    # loop through each space, checking for 3 adjacent identical gems\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            # look for horizontal matches\n            if getGemAt(boardCopy, x, y) == getGemAt(boardCopy, x + 1, y) == getGemAt(boardCopy, x + 2, y) and getGemAt(boardCopy, x, y) != EMPTY_SPACE:\n                targetGem = boardCopy[x][y]\n                offset = 0\n                removeSet = []\n                while getGemAt(boardCopy, x + offset, y) == targetGem:\n                    # keep checking if there\'s more than 3 gems in a row\n                    removeSet.append((x + offset, y))\n                    boardCopy[x + offset][y] = EMPTY_SPACE\n                    offset += 1\n                gemsToRemove.append(removeSet)\n\n            # look for vertical matches\n            if getGemAt(boardCopy, x, y) == getGemAt(boardCopy, x, y + 1) == getGemAt(boardCopy, x, y + 2) and getGemAt(boardCopy, x, y) != EMPTY_SPACE:\n                targetGem = boardCopy[x][y]\n                offset = 0\n                removeSet = []\n                while getGemAt(boardCopy, x, y + offset) == targetGem:\n                    # keep checking, in case there\'s more than 3 gems in a row\n                    removeSet.append((x, y + offset))\n                    boardCopy[x][y + offset] = EMPTY_SPACE\n                    offset += 1\n                gemsToRemove.append(removeSet)\n\n    return gemsToRemove\n\n\ndef highlightSpace(x, y):\n    pygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, BOARDRECTS[x][y], 4)\n\n\ndef getDroppingGems(board):\n    # Find all the gems that have an empty space below them\n    boardCopy = copy.deepcopy(board)\n    droppingGems = []\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT - 2, -1, -1):\n            if boardCopy[x][y + 1] == EMPTY_SPACE and boardCopy[x][y] != EMPTY_SPACE:\n                # This space drops if not empty but the space below it is\n                droppingGems.append( {\'imageNum\': boardCopy[x][y], \'x\': x, \'y\': y, \'direction\': DOWN} )\n                boardCopy[x][y] = EMPTY_SPACE\n    return droppingGems\n\n\ndef animateMovingGems(board, gems, pointsText, score):\n    # pointsText is a dictionary with keys \'x\', \'y\', and \'points\'\n    progress = 0 # progress at 0 represents beginning, 100 means finished.\n    while progress \x3C 100: # animation loop\n        DISPLAYSURF.fill(BGCOLOR)\n        drawBoard(board)\n        for gem in gems: # Draw each gem.\n            drawMovingGem(gem, progress)\n        drawScore(score)\n        for pointText in pointsText:\n            pointsSurf = BASICFONT.render(str(pointText[\'points\']), 1, SCORECOLOR)\n            pointsRect = pointsSurf.get_rect()\n            pointsRect.center = (pointText[\'x\'], pointText[\'y\'])\n            DISPLAYSURF.blit(pointsSurf, pointsRect)\n\n        pygame.display.update()\n        FPSCLOCK.tick(FPS)\n        progress += MOVERATE # progress the animation a little bit more for the next frame\n\n\ndef moveGems(board, movingGems):\n    # movingGems is a list of dicts with keys x, y, direction, imageNum\n    for gem in movingGems:\n        if gem[\'y\'] != ROWABOVEBOARD:\n            board[gem[\'x\']][gem[\'y\']] = EMPTY_SPACE\n            movex = 0\n            movey = 0\n            if gem[\'direction\'] == LEFT:\n                movex = -1\n            elif gem[\'direction\'] == RIGHT:\n                movex = 1\n            elif gem[\'direction\'] == DOWN:\n                movey = 1\n            elif gem[\'direction\'] == UP:\n                movey = -1\n            board[gem[\'x\'] + movex][gem[\'y\'] + movey] = gem[\'imageNum\']\n        else:\n            # gem is located above the board (where new gems come from)\n            board[gem[\'x\']][0] = gem[\'imageNum\'] # move to top row\n\n\ndef fillBoardAndAnimate(board, points, score):\n    dropSlots = getDropSlots(board)\n    while dropSlots != [[]] * BOARDWIDTH:\n        # do the dropping animation as long as there are more gems to drop\n        movingGems = getDroppingGems(board)\n        for x in range(len(dropSlots)):\n            if len(dropSlots[x]) != 0:\n                # cause the lowest gem in each slot to begin moving in the DOWN direction\n                movingGems.append({\'imageNum\': dropSlots[x][0], \'x\': x, \'y\': ROWABOVEBOARD, \'direction\': DOWN})\n\n        boardCopy = getBoardCopyMinusGems(board, movingGems)\n        animateMovingGems(boardCopy, movingGems, points, score)\n        moveGems(board, movingGems)\n\n        # Make the next row of gems from the drop slots\n        # the lowest by deleting the previous lowest gems.\n        for x in range(len(dropSlots)):\n            if len(dropSlots[x]) == 0:\n                continue\n            board[x][0] = dropSlots[x][0]\n            del dropSlots[x][0]\n\n\ndef checkForGemClick(pos):\n    # See if the mouse click was on the board\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            if BOARDRECTS[x][y].collidepoint(pos[0], pos[1]):\n                return {\'x\': x, \'y\': y}\n    return None # Click was not on the board.\n\n\ndef drawBoard(board):\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            pygame.draw.rect(DISPLAYSURF, GRIDCOLOR, BOARDRECTS[x][y], 1)\n            gemToDraw = board[x][y]\n            if gemToDraw != EMPTY_SPACE:\n                DISPLAYSURF.blit(GEMIMAGES[gemToDraw], BOARDRECTS[x][y])\n\n\ndef getBoardCopyMinusGems(board, gems):\n    # Creates and returns a copy of the passed board data structure,\n    # with the gems in the \"gems\" list removed from it.\n    #\n    # Gems is a list of dicts, with keys x, y, direction, imageNum\n\n    boardCopy = copy.deepcopy(board)\n\n    # Remove some of the gems from this board data structure copy.\n    for gem in gems:\n        if gem[\'y\'] != ROWABOVEBOARD:\n            boardCopy[gem[\'x\']][gem[\'y\']] = EMPTY_SPACE\n    return boardCopy\n\n\ndef drawScore(score):\n    scoreImg = BASICFONT.render(str(score), 1, SCORECOLOR)\n    scoreRect = scoreImg.get_rect()\n    scoreRect.bottomleft = (10, WINDOWHEIGHT - 6)\n    DISPLAYSURF.blit(scoreImg, scoreRect)\n\n\nif __name__ == \'__main__\':\n    main()\n",
    "hellopygameworld": "\nimport pygame, sys\nfrom pygame.locals import *\n\npygame.init()\nDISPLAYSURF = pygame.display.set_mode((400, 300))\npygame.display.set_caption(\'Hello World!\')\nwhile True: # main game loop\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n            sys.exit()\n    pygame.display.update()\n",
    "inkspill": "# Ink Spill (a Flood It clone)\n# http:\x2F\x2Finventwithpython.com\x2Fpygame\n# By Al Sweigart al@inventwithpython.com\n# Released under a \"Simplified BSD\" license\n\nimport random, sys, webbrowser, copy, pygame\nfrom pygame.locals import *\n\n# There are different box sizes, number of boxes, and\n# life depending on the \"board size\" setting selected.\nSMALLBOXSIZE  = 60 # size is in pixels\nMEDIUMBOXSIZE = 20\nLARGEBOXSIZE  = 11\n\nSMALLBOARDSIZE  = 6 # size is in boxes\nMEDIUMBOARDSIZE = 17\nLARGEBOARDSIZE  = 30\n\nSMALLMAXLIFE  = 10 # number of turns\nMEDIUMMAXLIFE = 30\nLARGEMAXLIFE  = 64\n\nFPS = 30\nWINDOWWIDTH = 640\nWINDOWHEIGHT = 480\nboxSize = MEDIUMBOXSIZE\nPALETTEGAPSIZE = 10\nPALETTESIZE = 45\nEASY = 0   # arbitrary but unique value\nMEDIUM = 1 # arbitrary but unique value\nHARD = 2   # arbitrary but unique value\n\ndifficulty = MEDIUM # game starts in \"medium\" mode\nmaxLife = MEDIUMMAXLIFE\nboardWidth = MEDIUMBOARDSIZE\nboardHeight = MEDIUMBOARDSIZE\n\n\n#            R    G    B\nWHITE    = (255, 255, 255)\nDARKGRAY = ( 70,  70,  70)\nBLACK    = (  0,   0,   0)\nRED      = (255,   0,   0)\nGREEN    = (  0, 255,   0)\nBLUE     = (  0,   0, 255)\nYELLOW   = (255, 255,   0)\nORANGE   = (255, 128,   0)\nPURPLE   = (255,   0, 255)\n\n# The first color in each scheme is the background color, the next six are the palette colors.\nCOLORSCHEMES = (((150, 200, 255), RED, GREEN, BLUE, YELLOW, ORANGE, PURPLE),\n                ((0, 155, 104),  (97, 215, 164),  (228, 0, 69),  (0, 125, 50),   (204, 246, 0),   (148, 0, 45),    (241, 109, 149)),\n                ((195, 179, 0),  (255, 239, 115), (255, 226, 0), (147, 3, 167),  (24, 38, 176),   (166, 147, 0),   (197, 97, 211)),\n                ((85, 0, 0),     (155, 39, 102),  (0, 201, 13),  (255, 118, 0),  (206, 0, 113),   (0, 130, 9),     (255, 180, 115)),\n                ((191, 159, 64), (183, 182, 208), (4, 31, 183),  (167, 184, 45), (122, 128, 212), (37, 204, 7),    (88, 155, 213)),\n                ((200, 33, 205), (116, 252, 185), (68, 56, 56),  (52, 238, 83),  (23, 149, 195),  (222, 157, 227), (212, 86, 185)))\nfor i in range(len(COLORSCHEMES)):\n    assert len(COLORSCHEMES[i]) == 7, \'Color scheme %s does not have exactly 7 colors.\' % (i)\nbgColor = COLORSCHEMES[0][0]\npaletteColors =  COLORSCHEMES[0][1:]\n\ndef main():\n    global FPSCLOCK, DISPLAYSURF, LOGOIMAGE, SPOTIMAGE, SETTINGSIMAGE, SETTINGSBUTTONIMAGE, RESETBUTTONIMAGE\n\n    pygame.init()\n    FPSCLOCK = pygame.time.Clock()\n    DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))\n\n    # Load images\n    LOGOIMAGE = pygame.image.load(\'inkspilllogo.png\')\n    SPOTIMAGE = pygame.image.load(\'inkspillspot.png\')\n    SETTINGSIMAGE = pygame.image.load(\'inkspillsettings.png\')\n    SETTINGSBUTTONIMAGE = pygame.image.load(\'inkspillsettingsbutton.png\')\n    RESETBUTTONIMAGE = pygame.image.load(\'inkspillresetbutton.png\')\n\n    pygame.display.set_caption(\'Ink Spill\')\n    mousex = 0\n    mousey = 0\n    mainBoard = generateRandomBoard(boardWidth, boardHeight, difficulty)\n    life = maxLife\n    lastPaletteClicked = None\n\n    while True: # main game loop\n        paletteClicked = None\n        resetGame = False\n\n        # Draw the screen.\n        DISPLAYSURF.fill(bgColor)\n        drawLogoAndButtons()\n        drawBoard(mainBoard)\n        drawLifeMeter(life)\n        drawPalettes()\n\n        checkForQuit()\n        for event in pygame.event.get(): # event handling loop\n            if event.type == MOUSEBUTTONUP:\n                mousex, mousey = event.pos\n                if pygame.Rect(WINDOWWIDTH - SETTINGSBUTTONIMAGE.get_width(),\n                               WINDOWHEIGHT - SETTINGSBUTTONIMAGE.get_height(),\n                               SETTINGSBUTTONIMAGE.get_width(),\n                               SETTINGSBUTTONIMAGE.get_height()).collidepoint(mousex, mousey):\n                    resetGame = showSettingsScreen() # clicked on Settings button\n                elif pygame.Rect(WINDOWWIDTH - RESETBUTTONIMAGE.get_width(),\n                                 WINDOWHEIGHT - SETTINGSBUTTONIMAGE.get_height() - RESETBUTTONIMAGE.get_height(),\n                                 RESETBUTTONIMAGE.get_width(),\n                                 RESETBUTTONIMAGE.get_height()).collidepoint(mousex, mousey):\n                    resetGame = True # clicked on Reset button\n                else:\n                    # check if a palette button was clicked\n                    paletteClicked = getColorOfPaletteAt(mousex, mousey)\n\n        if paletteClicked != None and paletteClicked != lastPaletteClicked:\n            # a palette button was clicked that is different from the\n            # last palette button clicked (this check prevents the player\n            # from accidentally clicking the same palette twice)\n            lastPaletteClicked = paletteClicked\n            floodAnimation(mainBoard, paletteClicked)\n            life -= 1\n\n            resetGame = False\n            if hasWon(mainBoard):\n                for i in range(4): # flash border 4 times\n                    flashBorderAnimation(WHITE, mainBoard)\n                resetGame = True\n                pygame.time.wait(2000) # pause so the player can bask in victory\n            elif life == 0:\n                # life is zero, so player has lost\n                drawLifeMeter(0)\n                pygame.display.update()\n                pygame.time.wait(400)\n                for i in range(4):\n                    flashBorderAnimation(BLACK, mainBoard)\n                resetGame = True\n                pygame.time.wait(2000) # pause so the player can suffer in their defeat\n\n        if resetGame:\n            # start a new game\n            mainBoard = generateRandomBoard(boardWidth, boardHeight, difficulty)\n            life = maxLife\n            lastPaletteClicked = None\n\n        pygame.display.update()\n        FPSCLOCK.tick(FPS)\n\n\ndef checkForQuit():\n    # Terminates the program if there are any QUIT or escape key events.\n    for event in pygame.event.get(QUIT): # get all the QUIT events\n        pygame.quit() # terminate if any QUIT events are present\n        sys.exit()\n    for event in pygame.event.get(KEYUP): # get all the KEYUP events\n        if event.key == K_ESCAPE:\n            pygame.quit() # terminate if the KEYUP event was for the Esc key\n            sys.exit()\n        pygame.event.post(event) # put the other KEYUP event objects back\n\n\ndef hasWon(board):\n    # if the entire board is the same color, player has won\n    for x in range(boardWidth):\n        for y in range(boardHeight):\n            if board[x][y] != board[0][0]:\n                return False # found a different color, player has not won\n    return True\n\n\ndef showSettingsScreen():\n    global difficulty, boxSize, boardWidth, boardHeight, maxLife, paletteColors, bgColor\n\n    # The pixel coordinates in this function were obtained by loading\n    # the inkspillsettings.png image into a graphics editor and reading\n    # the pixel coordinates from there. Handy trick.\n\n    origDifficulty = difficulty\n    origBoxSize = boxSize\n    screenNeedsRedraw = True\n\n    while True:\n        if screenNeedsRedraw:\n            DISPLAYSURF.fill(bgColor)\n            DISPLAYSURF.blit(SETTINGSIMAGE, (0,0))\n\n            # place the ink spot marker next to the selected difficulty\n            if difficulty == EASY:\n                DISPLAYSURF.blit(SPOTIMAGE, (30, 4))\n            if difficulty == MEDIUM:\n                DISPLAYSURF.blit(SPOTIMAGE, (8, 41))\n            if difficulty == HARD:\n                DISPLAYSURF.blit(SPOTIMAGE, (30, 76))\n\n            # place the ink spot marker next to the selected size\n            if boxSize == SMALLBOXSIZE:\n                DISPLAYSURF.blit(SPOTIMAGE, (22, 150))\n            if boxSize == MEDIUMBOXSIZE:\n                DISPLAYSURF.blit(SPOTIMAGE, (11, 185))\n            if boxSize == LARGEBOXSIZE:\n                DISPLAYSURF.blit(SPOTIMAGE, (24, 220))\n\n            for i in range(len(COLORSCHEMES)):\n                drawColorSchemeBoxes(500, i * 60 + 30, i)\n\n            pygame.display.update()\n\n        screenNeedsRedraw = False # by default, don\'t redraw the screen\n        for event in pygame.event.get(): # event handling loop\n            if event.type == QUIT:\n                pygame.quit()\n                sys.exit()\n            elif event.type == KEYUP:\n                if event.key == K_ESCAPE:\n                    # Esc key on settings screen goes back to game\n                    return not (origDifficulty == difficulty and origBoxSize == boxSize)\n            elif event.type == MOUSEBUTTONUP:\n                screenNeedsRedraw = True # screen should be redrawn\n                mousex, mousey = event.pos # syntactic sugar\n\n                # check for clicks on the difficulty buttons\n                if pygame.Rect(74, 16, 111, 30).collidepoint(mousex, mousey):\n                    difficulty = EASY\n                elif pygame.Rect(53, 50, 104, 29).collidepoint(mousex, mousey):\n                    difficulty = MEDIUM\n                elif pygame.Rect(72, 85, 65, 31).collidepoint(mousex, mousey):\n                    difficulty = HARD\n\n                # check for clicks on the size buttons\n                elif pygame.Rect(63, 156, 84, 31).collidepoint(mousex, mousey):\n                    # small board size setting:\n                    boxSize = SMALLBOXSIZE\n                    boardWidth = SMALLBOARDSIZE\n                    boardHeight = SMALLBOARDSIZE\n                    maxLife = SMALLMAXLIFE\n                elif pygame.Rect(52, 192, 106,32).collidepoint(mousex, mousey):\n                    # medium board size setting:\n                    boxSize = MEDIUMBOXSIZE\n                    boardWidth = MEDIUMBOARDSIZE\n                    boardHeight = MEDIUMBOARDSIZE\n                    maxLife = MEDIUMMAXLIFE\n                elif pygame.Rect(67, 228, 58, 37).collidepoint(mousex, mousey):\n                    # large board size setting:\n                    boxSize = LARGEBOXSIZE\n                    boardWidth = LARGEBOARDSIZE\n                    boardHeight = LARGEBOARDSIZE\n                    maxLife = LARGEMAXLIFE\n                elif pygame.Rect(14, 299, 371, 97).collidepoint(mousex, mousey):\n                    # clicked on the \"learn programming\" ad\n                    webbrowser.open(\'http:\x2F\x2Finventwithpython.com\') # opens a web browser\n                elif pygame.Rect(178, 418, 215, 34).collidepoint(mousex, mousey):\n                    # clicked on the \"back to game\" button\n                    return not (origDifficulty == difficulty and origBoxSize == boxSize)\n\n                for i in range(len(COLORSCHEMES)):\n                    # clicked on a color scheme button\n                    if pygame.Rect(500, 30 + i * 60, MEDIUMBOXSIZE * 3, MEDIUMBOXSIZE * 2).collidepoint(mousex, mousey):\n                        bgColor = COLORSCHEMES[i][0]\n                        paletteColors  = COLORSCHEMES[i][1:]\n\n\ndef drawColorSchemeBoxes(x, y, schemeNum):\n    # Draws the color scheme boxes that appear on the \"Settings\" screen.\n    for boxy in range(2):\n        for boxx in range(3):\n            pygame.draw.rect(DISPLAYSURF, COLORSCHEMES[schemeNum][3 * boxy + boxx + 1], (x + MEDIUMBOXSIZE * boxx, y + MEDIUMBOXSIZE * boxy, MEDIUMBOXSIZE, MEDIUMBOXSIZE))\n            if paletteColors == COLORSCHEMES[schemeNum][1:]:\n                # put the ink spot next to the selected color scheme\n                DISPLAYSURF.blit(SPOTIMAGE, (x - 50, y))\n\n\ndef flashBorderAnimation(color, board, animationSpeed=30):\n    origSurf = DISPLAYSURF.copy()\n    flashSurf = pygame.Surface(DISPLAYSURF.get_size())\n    flashSurf = flashSurf.convert_alpha()\n    for start, end, step in ((0, 256, 1), (255, 0, -1)):\n        # the first iteration on the outer loop will set the inner loop\n        # to have transparency go from 0 to 255, the second iteration will\n        # have it go from 255 to 0. This is the \"flash\".\n        for transparency in range(start, end, animationSpeed * step):\n            DISPLAYSURF.blit(origSurf, (0, 0))\n            r, g, b = color\n            flashSurf.fill((r, g, b, transparency))\n            DISPLAYSURF.blit(flashSurf, (0, 0))\n            drawBoard(board) # draw board ON TOP OF the transparency layer\n            pygame.display.update()\n            FPSCLOCK.tick(FPS)\n    DISPLAYSURF.blit(origSurf, (0, 0)) # redraw the original surface\n\n\ndef floodAnimation(board, paletteClicked, animationSpeed=25):\n    origBoard = copy.deepcopy(board)\n    floodFill(board, board[0][0], paletteClicked, 0, 0)\n\n    for transparency in range(0, 255, animationSpeed):\n        # The \"new\" board slowly become opaque over the original board.\n        drawBoard(origBoard)\n        drawBoard(board, transparency)\n        pygame.display.update()\n        FPSCLOCK.tick(FPS)\n\n\ndef generateRandomBoard(width, height, difficulty=MEDIUM):\n    # Creates a board data structure with random colors for each box.\n    board = []\n    for x in range(width):\n        column = []\n        for y in range(height):\n            column.append(random.randint(0, len(paletteColors) - 1))\n        board.append(column)\n\n    # Make board easier by setting some boxes to same color as a neighbor.\n\n    # Determine how many boxes to change.\n    if difficulty == EASY:\n        if boxSize == SMALLBOXSIZE:\n            boxesToChange = 100\n        else:\n            boxesToChange = 1500\n    elif difficulty == MEDIUM:\n        if boxSize == SMALLBOXSIZE:\n            boxesToChange = 5\n        else:\n            boxesToChange = 200\n    else:\n        boxesToChange = 0\n\n    # Change neighbor\'s colors:\n    for i in range(boxesToChange):\n        # Randomly choose a box whose color to copy\n        x = random.randint(1, width-2)\n        y = random.randint(1, height-2)\n\n        # Randomly choose neighbors to change.\n        direction = random.randint(0, 3)\n        if direction == 0: # change left and up neighbor\n            board[x-1][y] == board[x][y]\n            board[x][y-1] == board[x][y]\n        elif direction == 1: # change right and down neighbor\n            board[x+1][y] == board[x][y]\n            board[x][y+1] == board[x][y]\n        elif direction == 2: # change right and up neighbor\n            board[x][y-1] == board[x][y]\n            board[x+1][y] == board[x][y]\n        else: # change left and down neighbor\n            board[x][y+1] == board[x][y]\n            board[x-1][y] == board[x][y]\n    return board\n\n\ndef drawLogoAndButtons():\n    # draw the Ink Spill logo and Settings and Reset buttons.\n    DISPLAYSURF.blit(LOGOIMAGE, (WINDOWWIDTH - LOGOIMAGE.get_width(), 0))\n    DISPLAYSURF.blit(SETTINGSBUTTONIMAGE, (WINDOWWIDTH - SETTINGSBUTTONIMAGE.get_width(), WINDOWHEIGHT - SETTINGSBUTTONIMAGE.get_height()))\n    DISPLAYSURF.blit(RESETBUTTONIMAGE, (WINDOWWIDTH - RESETBUTTONIMAGE.get_width(), WINDOWHEIGHT - SETTINGSBUTTONIMAGE.get_height() - RESETBUTTONIMAGE.get_height()))\n\n\ndef drawBoard(board, transparency=255):\n    # The colored squares are drawn to a temporary surface which is then\n    # drawn to the DISPLAYSURF surface. This is done so we can draw the\n    # squares with transparency on top of DISPLAYSURF as it currently is.\n    tempSurf = pygame.Surface(DISPLAYSURF.get_size())\n    tempSurf = tempSurf.convert_alpha()\n    tempSurf.fill((0, 0, 0, 0))\n\n    for x in range(boardWidth):\n        for y in range(boardHeight):\n            left, top = leftTopPixelCoordOfBox(x, y)\n            r, g, b = paletteColors[board[x][y]]\n            pygame.draw.rect(tempSurf, (r, g, b, transparency), (left, top, boxSize, boxSize))\n    left, top = leftTopPixelCoordOfBox(0, 0)\n    pygame.draw.rect(tempSurf, BLACK, (left-1, top-1, boxSize * boardWidth + 1, boxSize * boardHeight + 1), 1)\n    DISPLAYSURF.blit(tempSurf, (0, 0))\n\n\ndef drawPalettes():\n    # Draws the six color palettes at the bottom of the screen.\n    numColors = len(paletteColors)\n    xmargin = int((WINDOWWIDTH - ((PALETTESIZE * numColors) + (PALETTEGAPSIZE * (numColors - 1)))) \x2F 2)\n    for i in range(numColors):\n        left = xmargin + (i * PALETTESIZE) + (i * PALETTEGAPSIZE)\n        top = WINDOWHEIGHT - PALETTESIZE - 10\n        pygame.draw.rect(DISPLAYSURF, paletteColors[i], (left, top, PALETTESIZE, PALETTESIZE))\n        pygame.draw.rect(DISPLAYSURF, bgColor,   (left + 2, top + 2, PALETTESIZE - 4, PALETTESIZE - 4), 2)\n\n\ndef drawLifeMeter(currentLife):\n    lifeBoxSize = int((WINDOWHEIGHT - 40) \x2F maxLife)\n\n    # Draw background color of life meter.\n    pygame.draw.rect(DISPLAYSURF, bgColor, (20, 20, 20, 20 + (maxLife * lifeBoxSize)))\n\n    for i in range(maxLife):\n        if currentLife \x3E= (maxLife - i): # draw a solid red box\n            pygame.draw.rect(DISPLAYSURF, RED, (20, 20 + (i * lifeBoxSize), 20, lifeBoxSize))\n        pygame.draw.rect(DISPLAYSURF, WHITE, (20, 20 + (i * lifeBoxSize), 20, lifeBoxSize), 1) # draw white outline\n\n\ndef getColorOfPaletteAt(x, y):\n    # Returns the index of the color in paletteColors that the x and y parameters\n    # are over. Returns None if x and y are not over any palette.\n    numColors = len(paletteColors)\n    xmargin = int((WINDOWWIDTH - ((PALETTESIZE * numColors) + (PALETTEGAPSIZE * (numColors - 1)))) \x2F 2)\n    top = WINDOWHEIGHT - PALETTESIZE - 10\n    for i in range(numColors):\n        # Find out if the mouse click is inside any of the palettes.\n        left = xmargin + (i * PALETTESIZE) + (i * PALETTEGAPSIZE)\n        r = pygame.Rect(left, top, PALETTESIZE, PALETTESIZE)\n        if r.collidepoint(x, y):\n            return i\n    return None # no palette exists at these x, y coordinates\n\n\ndef floodFill(board, oldColor, newColor, x, y):\n    # This is the flood fill algorithm.\n    if oldColor == newColor or board[x][y] != oldColor:\n        return\n\n    board[x][y] = newColor # change the color of the current box\n\n    # Make the recursive call for any neighboring boxes:\n    if x \x3E 0:\n        floodFill(board, oldColor, newColor, x - 1, y) # on box to the left\n    if x \x3C boardWidth - 1:\n        floodFill(board, oldColor, newColor, x + 1, y) # on box to the right\n    if y \x3E 0:\n        floodFill(board, oldColor, newColor, x, y - 1) # on box to up\n    if y \x3C boardHeight - 1:\n        floodFill(board, oldColor, newColor, x, y + 1) # on box to down\n\n\ndef leftTopPixelCoordOfBox(boxx, boxy):\n    # Returns the x and y of the left-topmost pixel of the xth \& yth box.\n    xmargin = int((WINDOWWIDTH - (boardWidth * boxSize)) \x2F 2)\n    ymargin = int((WINDOWHEIGHT - (boardHeight * boxSize)) \x2F 2)\n    return (boxx * boxSize + xmargin, boxy * boxSize + ymargin)\n\n\nif __name__ == \'__main__\':\n    main()\n",
    "memorypuzzle": "# Memory Puzzle\n# By Al Sweigart al@inventwithpython.com\n# http:\x2F\x2Finventwithpython.com\x2Fpygame\n# Released under a \"Simplified BSD\" license\n\nimport random, pygame, sys\nfrom pygame.locals import *\n\nFPS = 30 # frames per second, the general speed of the program\nWINDOWWIDTH = 640 # size of window\'s width in pixels\nWINDOWHEIGHT = 480 # size of windows\' height in pixels\nREVEALSPEED = 8 # speed boxes\' sliding reveals and covers\nBOXSIZE = 40 # size of box height \& width in pixels\nGAPSIZE = 10 # size of gap between boxes in pixels\nBOARDWIDTH = 10 # number of columns of icons\nBOARDHEIGHT = 7 # number of rows of icons\nassert (BOARDWIDTH * BOARDHEIGHT) % 2 == 0, \'Board needs to have an even number of boxes for pairs of matches.\'\nXMARGIN = int((WINDOWWIDTH - (BOARDWIDTH * (BOXSIZE + GAPSIZE))) \x2F 2)\nYMARGIN = int((WINDOWHEIGHT - (BOARDHEIGHT * (BOXSIZE + GAPSIZE))) \x2F 2)\n\n#            R    G    B\nGRAY     = (100, 100, 100)\nNAVYBLUE = ( 60,  60, 100)\nWHITE    = (255, 255, 255)\nRED      = (255,   0,   0)\nGREEN    = (  0, 255,   0)\nBLUE     = (  0,   0, 255)\nYELLOW   = (255, 255,   0)\nORANGE   = (255, 128,   0)\nPURPLE   = (255,   0, 255)\nCYAN     = (  0, 255, 255)\n\nBGCOLOR = NAVYBLUE\nLIGHTBGCOLOR = GRAY\nBOXCOLOR = WHITE\nHIGHLIGHTCOLOR = BLUE\n\nDONUT = \'donut\'\nSQUARE = \'square\'\nDIAMOND = \'diamond\'\nLINES = \'lines\'\nOVAL = \'oval\'\n\nALLCOLORS = (RED, GREEN, BLUE, YELLOW, ORANGE, PURPLE, CYAN)\nALLSHAPES = (DONUT, SQUARE, DIAMOND, LINES, OVAL)\nassert len(ALLCOLORS) * len(ALLSHAPES) * 2 \x3E= BOARDWIDTH * BOARDHEIGHT, \"Board is too big for the number of shapes\x2Fcolors defined.\"\n\ndef main():\n    global FPSCLOCK, DISPLAYSURF\n    pygame.init()\n    FPSCLOCK = pygame.time.Clock()\n    DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))\n\n    mousex = 0 # used to store x coordinate of mouse event\n    mousey = 0 # used to store y coordinate of mouse event\n    pygame.display.set_caption(\'Memory Game\')\n\n    mainBoard = getRandomizedBoard()\n    revealedBoxes = generateRevealedBoxesData(False)\n\n    firstSelection = None # stores the (x, y) of the first box clicked.\n\n    DISPLAYSURF.fill(BGCOLOR)\n    startGameAnimation(mainBoard)\n\n    while True: # main game loop\n        mouseClicked = False\n\n        DISPLAYSURF.fill(BGCOLOR) # drawing the window\n        drawBoard(mainBoard, revealedBoxes)\n\n        for event in pygame.event.get(): # event handling loop\n            if event.type == QUIT or (event.type == KEYUP and event.key == K_ESCAPE):\n                pygame.quit()\n                sys.exit()\n            elif event.type == MOUSEMOTION:\n                mousex, mousey = event.pos\n            elif event.type == MOUSEBUTTONUP:\n                mousex, mousey = event.pos\n                mouseClicked = True\n\n        boxx, boxy = getBoxAtPixel(mousex, mousey)\n        if boxx != None and boxy != None:\n            # The mouse is currently over a box.\n            if not revealedBoxes[boxx][boxy]:\n                drawHighlightBox(boxx, boxy)\n            if not revealedBoxes[boxx][boxy] and mouseClicked:\n                revealBoxesAnimation(mainBoard, [(boxx, boxy)])\n                revealedBoxes[boxx][boxy] = True # set the box as \"revealed\"\n                if firstSelection == None: # the current box was the first box clicked\n                    firstSelection = (boxx, boxy)\n                else: # the current box was the second box clicked\n                    # Check if there is a match between the two icons.\n                    icon1shape, icon1color = getShapeAndColor(mainBoard, firstSelection[0], firstSelection[1])\n                    icon2shape, icon2color = getShapeAndColor(mainBoard, boxx, boxy)\n\n                    if icon1shape != icon2shape or icon1color != icon2color:\n                        # Icons don\'t match. Re-cover up both selections.\n                        pygame.time.wait(1000) # 1000 milliseconds = 1 sec\n                        coverBoxesAnimation(mainBoard, [(firstSelection[0], firstSelection[1]), (boxx, boxy)])\n                        revealedBoxes[firstSelection[0]][firstSelection[1]] = False\n                        revealedBoxes[boxx][boxy] = False\n                    elif hasWon(revealedBoxes): # check if all pairs found\n                        gameWonAnimation(mainBoard)\n                        pygame.time.wait(2000)\n\n                        # Reset the board\n                        mainBoard = getRandomizedBoard()\n                        revealedBoxes = generateRevealedBoxesData(False)\n\n                        # Show the fully unrevealed board for a second.\n                        drawBoard(mainBoard, revealedBoxes)\n                        pygame.display.update()\n                        pygame.time.wait(1000)\n\n                        # Replay the start game animation.\n                        startGameAnimation(mainBoard)\n                    firstSelection = None # reset firstSelection variable\n\n        # Redraw the screen and wait a clock tick.\n        pygame.display.update()\n        FPSCLOCK.tick(FPS)\n\n\ndef generateRevealedBoxesData(val):\n    revealedBoxes = []\n    for i in range(BOARDWIDTH):\n        revealedBoxes.append([val] * BOARDHEIGHT)\n    return revealedBoxes\n\n\ndef getRandomizedBoard():\n    # Get a list of every possible shape in every possible color.\n    icons = []\n    for color in ALLCOLORS:\n        for shape in ALLSHAPES:\n            icons.append( (shape, color) )\n\n    random.shuffle(icons) # randomize the order of the icons list\n    numIconsUsed = int(BOARDWIDTH * BOARDHEIGHT \x2F 2) # calculate how many icons are needed\n    icons = icons[:numIconsUsed] * 2 # make two of each\n    random.shuffle(icons)\n\n    # Create the board data structure, with randomly placed icons.\n    board = []\n    for x in range(BOARDWIDTH):\n        column = []\n        for y in range(BOARDHEIGHT):\n            column.append(icons[0])\n            del icons[0] # remove the icons as we assign them\n        board.append(column)\n    return board\n\n\ndef splitIntoGroupsOf(groupSize, theList):\n    # splits a list into a list of lists, where the inner lists have at\n    # most groupSize number of items.\n    result = []\n    for i in range(0, len(theList), groupSize):\n        result.append(theList[i:i + groupSize])\n    return result\n\n\ndef leftTopCoordsOfBox(boxx, boxy):\n    # Convert board coordinates to pixel coordinates\n    left = boxx * (BOXSIZE + GAPSIZE) + XMARGIN\n    top = boxy * (BOXSIZE + GAPSIZE) + YMARGIN\n    return (left, top)\n\n\ndef getBoxAtPixel(x, y):\n    for boxx in range(BOARDWIDTH):\n        for boxy in range(BOARDHEIGHT):\n            left, top = leftTopCoordsOfBox(boxx, boxy)\n            boxRect = pygame.Rect(left, top, BOXSIZE, BOXSIZE)\n            if boxRect.collidepoint(x, y):\n                return (boxx, boxy)\n    return (None, None)\n\n\ndef drawIcon(shape, color, boxx, boxy):\n    quarter = int(BOXSIZE * 0.25) # syntactic sugar\n    half =    int(BOXSIZE * 0.5)  # syntactic sugar\n\n    left, top = leftTopCoordsOfBox(boxx, boxy) # get pixel coords from board coords\n    # Draw the shapes\n    if shape == DONUT:\n        pygame.draw.circle(DISPLAYSURF, color, (left + half, top + half), half - 5)\n        pygame.draw.circle(DISPLAYSURF, BGCOLOR, (left + half, top + half), quarter - 5)\n    elif shape == SQUARE:\n        pygame.draw.rect(DISPLAYSURF, color, (left + quarter, top + quarter, BOXSIZE - half, BOXSIZE - half))\n    elif shape == DIAMOND:\n        pygame.draw.polygon(DISPLAYSURF, color, ((left + half, top), (left + BOXSIZE - 1, top + half), (left + half, top + BOXSIZE - 1), (left, top + half)))\n    elif shape == LINES:\n        for i in range(0, BOXSIZE, 4):\n            pygame.draw.line(DISPLAYSURF, color, (left, top + i), (left + i, top))\n            pygame.draw.line(DISPLAYSURF, color, (left + i, top + BOXSIZE - 1), (left + BOXSIZE - 1, top + i))\n    elif shape == OVAL:\n        pygame.draw.ellipse(DISPLAYSURF, color, (left, top + quarter, BOXSIZE, half))\n\n\ndef getShapeAndColor(board, boxx, boxy):\n    # shape value for x, y spot is stored in board[x][y][0]\n    # color value for x, y spot is stored in board[x][y][1]\n    return board[boxx][boxy][0], board[boxx][boxy][1]\n\n\ndef drawBoxCovers(board, boxes, coverage):\n    # Draws boxes being covered\x2Frevealed. \"boxes\" is a list\n    # of two-item lists, which have the x \& y spot of the box.\n    for box in boxes:\n        left, top = leftTopCoordsOfBox(box[0], box[1])\n        pygame.draw.rect(DISPLAYSURF, BGCOLOR, (left, top, BOXSIZE, BOXSIZE))\n        shape, color = getShapeAndColor(board, box[0], box[1])\n        drawIcon(shape, color, box[0], box[1])\n        if coverage \x3E 0: # only draw the cover if there is an coverage\n            pygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, coverage, BOXSIZE))\n    pygame.display.update()\n    FPSCLOCK.tick(FPS)\n\n\ndef revealBoxesAnimation(board, boxesToReveal):\n    # Do the \"box reveal\" animation.\n    for coverage in range(BOXSIZE, (-REVEALSPEED) - 1, -REVEALSPEED):\n        drawBoxCovers(board, boxesToReveal, coverage)\n\n\ndef coverBoxesAnimation(board, boxesToCover):\n    # Do the \"box cover\" animation.\n    for coverage in range(0, BOXSIZE + REVEALSPEED, REVEALSPEED):\n        drawBoxCovers(board, boxesToCover, coverage)\n\n\ndef drawBoard(board, revealed):\n    # Draws all of the boxes in their covered or revealed state.\n    for boxx in range(BOARDWIDTH):\n        for boxy in range(BOARDHEIGHT):\n            left, top = leftTopCoordsOfBox(boxx, boxy)\n            if not revealed[boxx][boxy]:\n                # Draw a covered box.\n                pygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, BOXSIZE, BOXSIZE))\n            else:\n                # Draw the (revealed) icon.\n                shape, color = getShapeAndColor(board, boxx, boxy)\n                drawIcon(shape, color, boxx, boxy)\n\n\ndef drawHighlightBox(boxx, boxy):\n    left, top = leftTopCoordsOfBox(boxx, boxy)\n    pygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, (left - 5, top - 5, BOXSIZE + 10, BOXSIZE + 10), 4)\n\n\ndef startGameAnimation(board):\n    # Randomly reveal the boxes 8 at a time.\n    coveredBoxes = generateRevealedBoxesData(False)\n    boxes = []\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            boxes.append( (x, y) )\n    random.shuffle(boxes)\n    boxGroups = splitIntoGroupsOf(8, boxes)\n\n    drawBoard(board, coveredBoxes)\n    for boxGroup in boxGroups:\n        revealBoxesAnimation(board, boxGroup)\n        coverBoxesAnimation(board, boxGroup)\n\n\ndef gameWonAnimation(board):\n    # flash the background color when the player has won\n    coveredBoxes = generateRevealedBoxesData(True)\n    color1 = LIGHTBGCOLOR\n    color2 = BGCOLOR\n\n    for i in range(13):\n        color1, color2 = color2, color1 # swap colors\n        DISPLAYSURF.fill(color1)\n        drawBoard(board, coveredBoxes)\n        pygame.display.update()\n        pygame.time.wait(300)\n\n\ndef hasWon(revealedBoxes):\n    # Returns True if all the boxes have been revealed, otherwise False\n    for i in revealedBoxes:\n        if False in i:\n            return False # return False if any boxes are covered.\n    return True\n\n\nif __name__ == \'__main__\':\n    main()",
    "simulate": "# Simulate (a Simon clone)\n# By Al Sweigart al@inventwithpython.com\n# http:\x2F\x2Finventwithpython.com\x2Fpygame\n# Released under a \"Simplified BSD\" license\n\nimport random, sys, time, pygame\nfrom pygame.locals import *\n\nFPS = 30\nWINDOWWIDTH = 640\nWINDOWHEIGHT = 480\nFLASHSPEED = 500 # in milliseconds\nFLASHDELAY = 200 # in milliseconds\nBUTTONSIZE = 200\nBUTTONGAPSIZE = 20\nTIMEOUT = 4 # seconds before game over if no button is pushed.\n\n#                R    G    B\nWHITE        = (255, 255, 255)\nBLACK        = (  0,   0,   0)\nBRIGHTRED    = (255,   0,   0)\nRED          = (155,   0,   0)\nBRIGHTGREEN  = (  0, 255,   0)\nGREEN        = (  0, 155,   0)\nBRIGHTBLUE   = (  0,   0, 255)\nBLUE         = (  0,   0, 155)\nBRIGHTYELLOW = (255, 255,   0)\nYELLOW       = (155, 155,   0)\nDARKGRAY     = ( 40,  40,  40)\nbgColor = BLACK\n\nXMARGIN = int((WINDOWWIDTH - (2 * BUTTONSIZE) - BUTTONGAPSIZE) \x2F 2)\nYMARGIN = int((WINDOWHEIGHT - (2 * BUTTONSIZE) - BUTTONGAPSIZE) \x2F 2)\n\n# Rect objects for each of the four buttons\nYELLOWRECT = pygame.Rect(XMARGIN, YMARGIN, BUTTONSIZE, BUTTONSIZE)\nBLUERECT   = pygame.Rect(XMARGIN + BUTTONSIZE + BUTTONGAPSIZE, YMARGIN, BUTTONSIZE, BUTTONSIZE)\nREDRECT    = pygame.Rect(XMARGIN, YMARGIN + BUTTONSIZE + BUTTONGAPSIZE, BUTTONSIZE, BUTTONSIZE)\nGREENRECT  = pygame.Rect(XMARGIN + BUTTONSIZE + BUTTONGAPSIZE, YMARGIN + BUTTONSIZE + BUTTONGAPSIZE, BUTTONSIZE, BUTTONSIZE)\n\ndef main():\n    global FPSCLOCK, DISPLAYSURF, BASICFONT, BEEP1, BEEP2, BEEP3, BEEP4\n\n    pygame.init()\n    FPSCLOCK = pygame.time.Clock()\n    DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))\n    pygame.display.set_caption(\'Simulate\')\n\n    BASICFONT = pygame.font.Font(\'freesansbold.ttf\', 16)\n    infoSurf = BASICFONT.render(\'Match the pattern by clicking on the button or using the Q, W, A, S keys.\', 1, DARKGRAY)\n    infoRect = infoSurf.get_rect()\n    infoRect.topleft = (10, WINDOWHEIGHT - 25)\n\n    # load the sound files\n    BEEP1 = pygame.mixer.Sound(\'beep1.ogg\')\n    BEEP2 = pygame.mixer.Sound(\'beep2.ogg\')\n    BEEP3 = pygame.mixer.Sound(\'beep3.ogg\')\n    BEEP4 = pygame.mixer.Sound(\'beep4.ogg\')\n\n    # Initialize some variables for a new game\n    pattern = [] # stores the pattern of colors\n    currentStep = 0 # the color the player must push next\n    lastClickTime = 0 # timestamp of the player\'s last button push\n    score = 0\n    # when False, the pattern is playing. when True, waiting for the player to click a colored button:\n    waitingForInput = False\n\n    while True: # main game loop\n        clickedButton = None # button that was clicked (set to YELLOW, RED, GREEN, or BLUE)\n        DISPLAYSURF.fill(bgColor)\n        drawButtons()\n\n        scoreSurf = BASICFONT.render(\'Score: \' + str(score), 1, WHITE)\n        scoreRect = scoreSurf.get_rect()\n        scoreRect.topleft = (WINDOWWIDTH - 100, 10)\n        DISPLAYSURF.blit(scoreSurf, scoreRect)\n\n        DISPLAYSURF.blit(infoSurf, infoRect)\n\n        checkForQuit()\n        for event in pygame.event.get(): # event handling loop\n            if event.type == MOUSEBUTTONUP:\n                mousex, mousey = event.pos\n                clickedButton = getButtonClicked(mousex, mousey)\n            elif event.type == KEYDOWN:\n                if event.key == K_q:\n                    clickedButton = YELLOW\n                elif event.key == K_w:\n                    clickedButton = BLUE\n                elif event.key == K_a:\n                    clickedButton = RED\n                elif event.key == K_s:\n                    clickedButton = GREEN\n\n\n\n        if not waitingForInput:\n            # play the pattern\n            pygame.display.update()\n            pygame.time.wait(1000)\n            pattern.append(random.choice((YELLOW, BLUE, RED, GREEN)))\n            for button in pattern:\n                flashButtonAnimation(button)\n                pygame.time.wait(FLASHDELAY)\n            waitingForInput = True\n        else:\n            # wait for the player to enter buttons\n            if clickedButton and clickedButton == pattern[currentStep]:\n                # pushed the correct button\n                flashButtonAnimation(clickedButton)\n                currentStep += 1\n                lastClickTime = time.time()\n\n                if currentStep == len(pattern):\n                    # pushed the last button in the pattern\n                    changeBackgroundAnimation()\n                    score += 1\n                    waitingForInput = False\n                    currentStep = 0 # reset back to first step\n\n            elif (clickedButton and clickedButton != pattern[currentStep]) or (currentStep != 0 and time.time() - TIMEOUT \x3E lastClickTime):\n                # pushed the incorrect button, or has timed out\n                gameOverAnimation()\n                # reset the variables for a new game:\n                pattern = []\n                currentStep = 0\n                waitingForInput = False\n                score = 0\n                pygame.time.wait(1000)\n                changeBackgroundAnimation()\n\n        pygame.display.update()\n        FPSCLOCK.tick(FPS)\n\n\ndef terminate():\n    pygame.quit()\n    sys.exit()\n\n\ndef checkForQuit():\n    for event in pygame.event.get(QUIT): # get all the QUIT events\n        terminate() # terminate if any QUIT events are present\n    for event in pygame.event.get(KEYUP): # get all the KEYUP events\n        if event.key == K_ESCAPE:\n            terminate() # terminate if the KEYUP event was for the Esc key\n        pygame.event.post(event) # put the other KEYUP event objects back\n\n\ndef flashButtonAnimation(color, animationSpeed=50):\n    if color == YELLOW:\n        sound = BEEP1\n        flashColor = BRIGHTYELLOW\n        rectangle = YELLOWRECT\n    elif color == BLUE:\n        sound = BEEP2\n        flashColor = BRIGHTBLUE\n        rectangle = BLUERECT\n    elif color == RED:\n        sound = BEEP3\n        flashColor = BRIGHTRED\n        rectangle = REDRECT\n    elif color == GREEN:\n        sound = BEEP4\n        flashColor = BRIGHTGREEN\n        rectangle = GREENRECT\n\n    origSurf = DISPLAYSURF.copy()\n    flashSurf = pygame.Surface((BUTTONSIZE, BUTTONSIZE))\n    flashSurf = flashSurf.convert_alpha()\n    r, g, b = flashColor\n    sound.play()\n    for start, end, step in ((0, 255, 1), (255, 0, -1)): # animation loop\n        for alpha in range(start, end, animationSpeed * step):\n            checkForQuit()\n            DISPLAYSURF.blit(origSurf, (0, 0))\n            flashSurf.fill((r, g, b, alpha))\n            DISPLAYSURF.blit(flashSurf, rectangle.topleft)\n            pygame.display.update()\n            FPSCLOCK.tick(FPS)\n    DISPLAYSURF.blit(origSurf, (0, 0))\n\n\ndef drawButtons():\n    pygame.draw.rect(DISPLAYSURF, YELLOW, YELLOWRECT)\n    pygame.draw.rect(DISPLAYSURF, BLUE,   BLUERECT)\n    pygame.draw.rect(DISPLAYSURF, RED,    REDRECT)\n    pygame.draw.rect(DISPLAYSURF, GREEN,  GREENRECT)\n\n\ndef changeBackgroundAnimation(animationSpeed=40):\n    global bgColor\n    newBgColor = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))\n\n    newBgSurf = pygame.Surface((WINDOWWIDTH, WINDOWHEIGHT))\n    newBgSurf = newBgSurf.convert_alpha()\n    r, g, b = newBgColor\n    for alpha in range(0, 255, animationSpeed): # animation loop\n        checkForQuit()\n        DISPLAYSURF.fill(bgColor)\n\n        newBgSurf.fill((r, g, b, alpha))\n        DISPLAYSURF.blit(newBgSurf, (0, 0))\n\n        drawButtons() # redraw the buttons on top of the tint\n\n        pygame.display.update()\n        FPSCLOCK.tick(FPS)\n    bgColor = newBgColor\n\n\ndef gameOverAnimation(color=WHITE, animationSpeed=50):\n    # play all beeps at once, then flash the background\n    origSurf = DISPLAYSURF.copy()\n    flashSurf = pygame.Surface(DISPLAYSURF.get_size())\n    flashSurf = flashSurf.convert_alpha()\n    BEEP1.play() # play all four beeps at the same time, roughly.\n    BEEP2.play()\n    BEEP3.play()\n    BEEP4.play()\n    r, g, b = color\n    for i in range(3): # do the flash 3 times\n        for start, end, step in ((0, 255, 1), (255, 0, -1)):\n            # The first iteration in this loop sets the following for loop\n            # to go from 0 to 255, the second from 255 to 0.\n            for alpha in range(start, end, animationSpeed * step): # animation loop\n                # alpha means transparency. 255 is opaque, 0 is invisible\n                checkForQuit()\n                flashSurf.fill((r, g, b, alpha))\n                DISPLAYSURF.blit(origSurf, (0, 0))\n                DISPLAYSURF.blit(flashSurf, (0, 0))\n                drawButtons()\n                pygame.display.update()\n                FPSCLOCK.tick(FPS)\n\n\n\ndef getButtonClicked(x, y):\n    if YELLOWRECT.collidepoint( (x, y) ):\n        return YELLOW\n    elif BLUERECT.collidepoint( (x, y) ):\n        return BLUE\n    elif REDRECT.collidepoint( (x, y) ):\n        return RED\n    elif GREENRECT.collidepoint( (x, y) ):\n        return GREEN\n    return None\n\n\nif __name__ == \'__main__\':\n    main()\n",
    "slidepuzzle": "# Slide Puzzle\n# By Al Sweigart al@inventwithpython.com\n# http:\x2F\x2Finventwithpython.com\x2Fpygame\n# Released under a \"Simplified BSD\" license\n\nimport pygame, sys, random\nfrom pygame.locals import *\n\n# Create the constants (go ahead and experiment with different values)\nBOARDWIDTH = 4  # number of columns in the board\nBOARDHEIGHT = 4 # number of rows in the board\nTILESIZE = 80\nWINDOWWIDTH = 640\nWINDOWHEIGHT = 480\nFPS = 30\nBLANK = None\n\n#                 R    G    B\nBLACK =         (  0,   0,   0)\nWHITE =         (255, 255, 255)\nBRIGHTBLUE =    (  0,  50, 255)\nDARKTURQUOISE = (  3,  54,  73)\nGREEN =         (  0, 204,   0)\n\nBGCOLOR = DARKTURQUOISE\nTILECOLOR = GREEN\nTEXTCOLOR = WHITE\nBORDERCOLOR = BRIGHTBLUE\nBASICFONTSIZE = 20\n\nBUTTONCOLOR = WHITE\nBUTTONTEXTCOLOR = BLACK\nMESSAGECOLOR = WHITE\n\nXMARGIN = int((WINDOWWIDTH - (TILESIZE * BOARDWIDTH + (BOARDWIDTH - 1))) \x2F 2)\nYMARGIN = int((WINDOWHEIGHT - (TILESIZE * BOARDHEIGHT + (BOARDHEIGHT - 1))) \x2F 2)\n\nUP = \'up\'\nDOWN = \'down\'\nLEFT = \'left\'\nRIGHT = \'right\'\n\ndef main():\n    global FPSCLOCK, DISPLAYSURF, BASICFONT, RESET_SURF, RESET_RECT, NEW_SURF, NEW_RECT, SOLVE_SURF, SOLVE_RECT\n\n    pygame.init()\n    FPSCLOCK = pygame.time.Clock()\n    DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))\n    pygame.display.set_caption(\'Slide Puzzle\')\n    BASICFONT = pygame.font.Font(\'freesansbold.ttf\', BASICFONTSIZE)\n\n    # Store the option buttons and their rectangles in OPTIONS.\n    RESET_SURF, RESET_RECT = makeText(\'Reset\',    TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120, WINDOWHEIGHT - 90)\n    NEW_SURF,   NEW_RECT   = makeText(\'New Game\', TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120, WINDOWHEIGHT - 60)\n    SOLVE_SURF, SOLVE_RECT = makeText(\'Solve\',    TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120, WINDOWHEIGHT - 30)\n\n    mainBoard, solutionSeq = generateNewPuzzle(80)\n    SOLVEDBOARD = getStartingBoard() # a solved board is the same as the board in a start state.\n    allMoves = [] # list of moves made from the solved configuration\n\n    while True: # main game loop\n        slideTo = None # the direction, if any, a tile should slide\n        msg = \'Click tile or press arrow keys to slide.\' # contains the message to show in the upper left corner.\n        if mainBoard == SOLVEDBOARD:\n            msg = \'Solved!\'\n\n        drawBoard(mainBoard, msg)\n\n        checkForQuit()\n        for event in pygame.event.get(): # event handling loop\n            if event.type == MOUSEBUTTONUP:\n                spotx, spoty = getSpotClicked(mainBoard, event.pos[0], event.pos[1])\n\n                if (spotx, spoty) == (None, None):\n                    # check if the user clicked on an option button\n                    if RESET_RECT.collidepoint(event.pos):\n                        resetAnimation(mainBoard, allMoves) # clicked on Reset button\n                        allMoves = []\n                    elif NEW_RECT.collidepoint(event.pos):\n                        mainBoard, solutionSeq = generateNewPuzzle(80) # clicked on New Game button\n                        allMoves = []\n                    elif SOLVE_RECT.collidepoint(event.pos):\n                        resetAnimation(mainBoard, solutionSeq + allMoves) # clicked on Solve button\n                        allMoves = []\n                else:\n                    # check if the clicked tile was next to the blank spot\n\n                    blankx, blanky = getBlankPosition(mainBoard)\n                    if spotx == blankx + 1 and spoty == blanky:\n                        slideTo = LEFT\n                    elif spotx == blankx - 1 and spoty == blanky:\n                        slideTo = RIGHT\n                    elif spotx == blankx and spoty == blanky + 1:\n                        slideTo = UP\n                    elif spotx == blankx and spoty == blanky - 1:\n                        slideTo = DOWN\n\n            elif event.type == KEYUP:\n                # check if the user pressed a key to slide a tile\n                if event.key in (K_LEFT, K_a) and isValidMove(mainBoard, LEFT):\n                    slideTo = LEFT\n                elif event.key in (K_RIGHT, K_d) and isValidMove(mainBoard, RIGHT):\n                    slideTo = RIGHT\n                elif event.key in (K_UP, K_w) and isValidMove(mainBoard, UP):\n                    slideTo = UP\n                elif event.key in (K_DOWN, K_s) and isValidMove(mainBoard, DOWN):\n                    slideTo = DOWN\n\n        if slideTo:\n            slideAnimation(mainBoard, slideTo, \'Click tile or press arrow keys to slide.\', 8) # show slide on screen\n            makeMove(mainBoard, slideTo)\n            allMoves.append(slideTo) # record the slide\n        pygame.display.update()\n        FPSCLOCK.tick(FPS)\n\n\ndef terminate():\n    pygame.quit()\n    sys.exit()\n\n\ndef checkForQuit():\n    for event in pygame.event.get(QUIT): # get all the QUIT events\n        terminate() # terminate if any QUIT events are present\n    for event in pygame.event.get(KEYUP): # get all the KEYUP events\n        if event.key == K_ESCAPE:\n            terminate() # terminate if the KEYUP event was for the Esc key\n        pygame.event.post(event) # put the other KEYUP event objects back\n\n\ndef getStartingBoard():\n    # Return a board data structure with tiles in the solved state.\n    # For example, if BOARDWIDTH and BOARDHEIGHT are both 3, this function\n    # returns [[1, 4, 7], [2, 5, 8], [3, 6, BLANK]]\n    counter = 1\n    board = []\n    for x in range(BOARDWIDTH):\n        column = []\n        for y in range(BOARDHEIGHT):\n            column.append(counter)\n            counter += BOARDWIDTH\n        board.append(column)\n        counter -= BOARDWIDTH * (BOARDHEIGHT - 1) + BOARDWIDTH - 1\n\n    board[BOARDWIDTH-1][BOARDHEIGHT-1] = BLANK\n    return board\n\n\ndef getBlankPosition(board):\n    # Return the x and y of board coordinates of the blank space.\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            if board[x][y] == BLANK:\n                return (x, y)\n\n\ndef makeMove(board, move):\n    # This function does not check if the move is valid.\n    blankx, blanky = getBlankPosition(board)\n\n    if move == UP:\n        board[blankx][blanky], board[blankx][blanky + 1] = board[blankx][blanky + 1], board[blankx][blanky]\n    elif move == DOWN:\n        board[blankx][blanky], board[blankx][blanky - 1] = board[blankx][blanky - 1], board[blankx][blanky]\n    elif move == LEFT:\n        board[blankx][blanky], board[blankx + 1][blanky] = board[blankx + 1][blanky], board[blankx][blanky]\n    elif move == RIGHT:\n        board[blankx][blanky], board[blankx - 1][blanky] = board[blankx - 1][blanky], board[blankx][blanky]\n\n\ndef isValidMove(board, move):\n    blankx, blanky = getBlankPosition(board)\n    return (move == UP and blanky != len(board[0]) - 1) or \\\n           (move == DOWN and blanky != 0) or \\\n           (move == LEFT and blankx != len(board) - 1) or \\\n           (move == RIGHT and blankx != 0)\n\n\ndef getRandomMove(board, lastMove=None):\n    # start with a full list of all four moves\n    validMoves = [UP, DOWN, LEFT, RIGHT]\n\n    # remove moves from the list as they are disqualified\n    if lastMove == UP or not isValidMove(board, DOWN):\n        validMoves.remove(DOWN)\n    if lastMove == DOWN or not isValidMove(board, UP):\n        validMoves.remove(UP)\n    if lastMove == LEFT or not isValidMove(board, RIGHT):\n        validMoves.remove(RIGHT)\n    if lastMove == RIGHT or not isValidMove(board, LEFT):\n        validMoves.remove(LEFT)\n\n    # return a random move from the list of remaining moves\n    return random.choice(validMoves)\n\n\ndef getLeftTopOfTile(tileX, tileY):\n    left = XMARGIN + (tileX * TILESIZE) + (tileX - 1)\n    top = YMARGIN + (tileY * TILESIZE) + (tileY - 1)\n    return (left, top)\n\n\ndef getSpotClicked(board, x, y):\n    # from the x \& y pixel coordinates, get the x \& y board coordinates\n    for tileX in range(len(board)):\n        for tileY in range(len(board[0])):\n            left, top = getLeftTopOfTile(tileX, tileY)\n            tileRect = pygame.Rect(left, top, TILESIZE, TILESIZE)\n            if tileRect.collidepoint(x, y):\n                return (tileX, tileY)\n    return (None, None)\n\n\ndef drawTile(tilex, tiley, number, adjx=0, adjy=0):\n    # draw a tile at board coordinates tilex and tiley, optionally a few\n    # pixels over (determined by adjx and adjy)\n    left, top = getLeftTopOfTile(tilex, tiley)\n    pygame.draw.rect(DISPLAYSURF, TILECOLOR, (left + adjx, top + adjy, TILESIZE, TILESIZE))\n    textSurf = BASICFONT.render(str(number), True, TEXTCOLOR)\n    textRect = textSurf.get_rect()\n    textRect.center = left + int(TILESIZE \x2F 2) + adjx, top + int(TILESIZE \x2F 2) + adjy\n    DISPLAYSURF.blit(textSurf, textRect)\n\n\ndef makeText(text, color, bgcolor, top, left):\n    # create the Surface and Rect objects for some text.\n    textSurf = BASICFONT.render(text, True, color, bgcolor)\n    textRect = textSurf.get_rect()\n    textRect.topleft = (top, left)\n    return (textSurf, textRect)\n\n\ndef drawBoard(board, message):\n    DISPLAYSURF.fill(BGCOLOR)\n    if message:\n        textSurf, textRect = makeText(message, MESSAGECOLOR, BGCOLOR, 5, 5)\n        DISPLAYSURF.blit(textSurf, textRect)\n\n    for tilex in range(len(board)):\n        for tiley in range(len(board[0])):\n            if board[tilex][tiley]:\n                drawTile(tilex, tiley, board[tilex][tiley])\n\n    left, top = getLeftTopOfTile(0, 0)\n    width = BOARDWIDTH * TILESIZE\n    height = BOARDHEIGHT * TILESIZE\n    pygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (left - 5, top - 5, width + 11, height + 11), 4)\n\n    DISPLAYSURF.blit(RESET_SURF, RESET_RECT)\n    DISPLAYSURF.blit(NEW_SURF, NEW_RECT)\n    DISPLAYSURF.blit(SOLVE_SURF, SOLVE_RECT)\n\n\ndef slideAnimation(board, direction, message, animationSpeed):\n    # Note: This function does not check if the move is valid.\n\n    blankx, blanky = getBlankPosition(board)\n    if direction == UP:\n        movex = blankx\n        movey = blanky + 1\n    elif direction == DOWN:\n        movex = blankx\n        movey = blanky - 1\n    elif direction == LEFT:\n        movex = blankx + 1\n        movey = blanky\n    elif direction == RIGHT:\n        movex = blankx - 1\n        movey = blanky\n\n    # prepare the base surface\n    drawBoard(board, message)\n    baseSurf = DISPLAYSURF.copy()\n    # draw a blank space over the moving tile on the baseSurf Surface.\n    moveLeft, moveTop = getLeftTopOfTile(movex, movey)\n    pygame.draw.rect(baseSurf, BGCOLOR, (moveLeft, moveTop, TILESIZE, TILESIZE))\n\n    for i in range(0, TILESIZE, animationSpeed):\n        # animate the tile sliding over\n        checkForQuit()\n        DISPLAYSURF.blit(baseSurf, (0, 0))\n        if direction == UP:\n            drawTile(movex, movey, board[movex][movey], 0, -i)\n        if direction == DOWN:\n            drawTile(movex, movey, board[movex][movey], 0, i)\n        if direction == LEFT:\n            drawTile(movex, movey, board[movex][movey], -i, 0)\n        if direction == RIGHT:\n            drawTile(movex, movey, board[movex][movey], i, 0)\n\n        pygame.display.update()\n        FPSCLOCK.tick(FPS)\n\n\ndef generateNewPuzzle(numSlides):\n    # From a starting configuration, make numSlides number of moves (and\n    # animate these moves).\n    sequence = []\n    board = getStartingBoard()\n    drawBoard(board, \'\')\n    pygame.display.update()\n    pygame.time.wait(500) # pause 500 milliseconds for effect\n    lastMove = None\n    for i in range(numSlides):\n        move = getRandomMove(board, lastMove)\n        slideAnimation(board, move, \'Generating new puzzle...\', animationSpeed=int(TILESIZE \x2F 3))\n        makeMove(board, move)\n        sequence.append(move)\n        lastMove = move\n    return (board, sequence)\n\n\ndef resetAnimation(board, allMoves):\n    # make all of the moves in allMoves in reverse.\n    revAllMoves = allMoves[:] # gets a copy of the list\n    revAllMoves.reverse()\n\n    for move in revAllMoves:\n        if move == UP:\n            oppositeMove = DOWN\n        elif move == DOWN:\n            oppositeMove = UP\n        elif move == RIGHT:\n            oppositeMove = LEFT\n        elif move == LEFT:\n            oppositeMove = RIGHT\n        slideAnimation(board, oppositeMove, \'\', animationSpeed=int(TILESIZE \x2F 2))\n        makeMove(board, oppositeMove)\n\n\nif __name__ == \'__main__\':\n    main()",
    "squirrel": "# Squirrel Eat Squirrel (a 2D Katamari Damacy clone)\n# By Al Sweigart al@inventwithpython.com\n# http:\x2F\x2Finventwithpython.com\x2Fpygame\n# Released under a \"Simplified BSD\" license\n\nimport random, sys, time, math, pygame\nfrom pygame.locals import *\n\nFPS = 30 # frames per second to update the screen\nWINWIDTH = 640 # width of the program\'s window, in pixels\nWINHEIGHT = 480 # height in pixels\nHALF_WINWIDTH = int(WINWIDTH \x2F 2)\nHALF_WINHEIGHT = int(WINHEIGHT \x2F 2)\n\nGRASSCOLOR = (24, 255, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\n\nCAMERASLACK = 90     # how far from the center the squirrel moves before moving the camera\nMOVERATE = 9         # how fast the player moves\nBOUNCERATE = 6       # how fast the player bounces (large is slower)\nBOUNCEHEIGHT = 30    # how high the player bounces\nSTARTSIZE = 25       # how big the player starts off\nWINSIZE = 300        # how big the player needs to be to win\nINVULNTIME = 2       # how long the player is invulnerable after being hit in seconds\nGAMEOVERTIME = 4     # how long the \"game over\" text stays on the screen in seconds\nMAXHEALTH = 3        # how much health the player starts with\n\nNUMGRASS = 80        # number of grass objects in the active area\nNUMSQUIRRELS = 30    # number of squirrels in the active area\nSQUIRRELMINSPEED = 3 # slowest squirrel speed\nSQUIRRELMAXSPEED = 7 # fastest squirrel speed\nDIRCHANGEFREQ = 2    # % chance of direction change per frame\nLEFT = \'left\'\nRIGHT = \'right\'\n\n\"\"\"\nThis program has three data structures to represent the player, enemy squirrels, and grass background objects. The data structures are dictionaries with the following keys:\n\nKeys used by all three data structures:\n    \'x\' - the left edge coordinate of the object in the game world (not a pixel coordinate on the screen)\n    \'y\' - the top edge coordinate of the object in the game world (not a pixel coordinate on the screen)\n    \'rect\' - the pygame.Rect object representing where on the screen the object is located.\nPlayer data structure keys:\n    \'surface\' - the pygame.Surface object that stores the image of the squirrel which will be drawn to the screen.\n    \'facing\' - either set to LEFT or RIGHT, stores which direction the player is facing.\n    \'size\' - the width and height of the player in pixels. (The width \& height are always the same.)\n    \'bounce\' - represents at what point in a bounce the player is in. 0 means standing (no bounce), up to BOUNCERATE (the completion of the bounce)\n    \'health\' - an integer showing how many more times the player can be hit by a larger squirrel before dying.\nEnemy Squirrel data structure keys:\n    \'surface\' - the pygame.Surface object that stores the image of the squirrel which will be drawn to the screen.\n    \'movex\' - how many pixels per frame the squirrel moves horizontally. A negative integer is moving to the left, a positive to the right.\n    \'movey\' - how many pixels per frame the squirrel moves vertically. A negative integer is moving up, a positive moving down.\n    \'width\' - the width of the squirrel\'s image, in pixels\n    \'height\' - the height of the squirrel\'s image, in pixels\n    \'bounce\' - represents at what point in a bounce the player is in. 0 means standing (no bounce), up to BOUNCERATE (the completion of the bounce)\n    \'bouncerate\' - how quickly the squirrel bounces. A lower number means a quicker bounce.\n    \'bounceheight\' - how high (in pixels) the squirrel bounces\nGrass data structure keys:\n    \'grassImage\' - an integer that refers to the index of the pygame.Surface object in GRASSIMAGES used for this grass object\n\"\"\"\n\ndef main():\n    global FPSCLOCK, DISPLAYSURF, BASICFONT, L_SQUIR_IMG, R_SQUIR_IMG, GRASSIMAGES\n\n    pygame.init()\n    FPSCLOCK = pygame.time.Clock()\n    pygame.display.set_icon(pygame.image.load(\'gameicon.png\'))\n    DISPLAYSURF = pygame.display.set_mode((WINWIDTH, WINHEIGHT))\n    pygame.display.set_caption(\'Squirrel Eat Squirrel\')\n    BASICFONT = pygame.font.Font(\'freesansbold.ttf\', 32)\n\n    # load the image files\n    L_SQUIR_IMG = pygame.image.load(\'squirrel.png\')\n    R_SQUIR_IMG = pygame.transform.flip(L_SQUIR_IMG, True, False)\n    GRASSIMAGES = []\n    for i in range(1, 5):\n        GRASSIMAGES.append(pygame.image.load(\'grass%s.png\' % i))\n\n    while True:\n        runGame()\n\n\ndef runGame():\n    # set up variables for the start of a new game\n    invulnerableMode = False  # if the player is invulnerable\n    invulnerableStartTime = 0 # time the player became invulnerable\n    gameOverMode = False      # if the player has lost\n    gameOverStartTime = 0     # time the player lost\n    winMode = False           # if the player has won\n\n    # create the surfaces to hold game text\n    gameOverSurf = BASICFONT.render(\'Game Over\', True, WHITE)\n    gameOverRect = gameOverSurf.get_rect()\n    gameOverRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT)\n\n    winSurf = BASICFONT.render(\'You have achieved OMEGA SQUIRREL!\', True, WHITE)\n    winRect = winSurf.get_rect()\n    winRect.center = (HALF_WINWIDTH, HALF_WINHEIGHT)\n\n    winSurf2 = BASICFONT.render(\'(Press \"r\" to restart.)\', True, WHITE)\n    winRect2 = winSurf2.get_rect()\n    winRect2.center = (HALF_WINWIDTH, HALF_WINHEIGHT + 30)\n\n    # camerax and cameray are the top left of where the camera view is\n    camerax = 0\n    cameray = 0\n\n    grassObjs = []    # stores all the grass objects in the game\n    squirrelObjs = [] # stores all the non-player squirrel objects\n    # stores the player object:\n    playerObj = {\'surface\': pygame.transform.scale(L_SQUIR_IMG, (STARTSIZE, STARTSIZE)),\n                 \'facing\': LEFT,\n                 \'size\': STARTSIZE,\n                 \'x\': HALF_WINWIDTH,\n                 \'y\': HALF_WINHEIGHT,\n                 \'bounce\':0,\n                 \'health\': MAXHEALTH}\n\n    moveLeft  = False\n    moveRight = False\n    moveUp    = False\n    moveDown  = False\n\n    # start off with some random grass images on the screen\n    for i in range(10):\n        grassObjs.append(makeNewGrass(camerax, cameray))\n        grassObjs[i][\'x\'] = random.randint(0, WINWIDTH)\n        grassObjs[i][\'y\'] = random.randint(0, WINHEIGHT)\n\n    while True: # main game loop\n        # Check if we should turn off invulnerability\n        if invulnerableMode and time.time() - invulnerableStartTime \x3E INVULNTIME:\n            invulnerableMode = False\n\n        # move all the squirrels\n        for sObj in squirrelObjs:\n            # move the squirrel, and adjust for their bounce\n            sObj[\'x\'] += sObj[\'movex\']\n            sObj[\'y\'] += sObj[\'movey\']\n            sObj[\'bounce\'] += 1\n            if sObj[\'bounce\'] \x3E sObj[\'bouncerate\']:\n                sObj[\'bounce\'] = 0 # reset bounce amount\n\n            # random chance they change direction\n            if random.randint(0, 99) \x3C DIRCHANGEFREQ:\n                sObj[\'movex\'] = getRandomVelocity()\n                sObj[\'movey\'] = getRandomVelocity()\n                if sObj[\'movex\'] \x3E 0: # faces right\n                    sObj[\'surface\'] = pygame.transform.scale(R_SQUIR_IMG, (sObj[\'width\'], sObj[\'height\']))\n                else: # faces left\n                    sObj[\'surface\'] = pygame.transform.scale(L_SQUIR_IMG, (sObj[\'width\'], sObj[\'height\']))\n\n\n        # go through all the objects and see if any need to be deleted.\n        for i in range(len(grassObjs) - 1, -1, -1):\n            if isOutsideActiveArea(camerax, cameray, grassObjs[i]):\n                del grassObjs[i]\n        for i in range(len(squirrelObjs) - 1, -1, -1):\n            if isOutsideActiveArea(camerax, cameray, squirrelObjs[i]):\n                del squirrelObjs[i]\n\n        # add more grass \& squirrels if we don\'t have enough.\n        while len(grassObjs) \x3C NUMGRASS:\n            grassObjs.append(makeNewGrass(camerax, cameray))\n        while len(squirrelObjs) \x3C NUMSQUIRRELS:\n            squirrelObjs.append(makeNewSquirrel(camerax, cameray))\n\n        # adjust camerax and cameray if beyond the \"camera slack\"\n        playerCenterx = playerObj[\'x\'] + int(playerObj[\'size\'] \x2F 2)\n        playerCentery = playerObj[\'y\'] + int(playerObj[\'size\'] \x2F 2)\n        if (camerax + HALF_WINWIDTH) - playerCenterx \x3E CAMERASLACK:\n            camerax = playerCenterx + CAMERASLACK - HALF_WINWIDTH\n        elif playerCenterx - (camerax + HALF_WINWIDTH) \x3E CAMERASLACK:\n            camerax = playerCenterx - CAMERASLACK - HALF_WINWIDTH\n        if (cameray + HALF_WINHEIGHT) - playerCentery \x3E CAMERASLACK:\n            cameray = playerCentery + CAMERASLACK - HALF_WINHEIGHT\n        elif playerCentery - (cameray + HALF_WINHEIGHT) \x3E CAMERASLACK:\n            cameray = playerCentery - CAMERASLACK - HALF_WINHEIGHT\n\n        # draw the green background\n        DISPLAYSURF.fill(GRASSCOLOR)\n\n        # draw all the grass objects on the screen\n        for gObj in grassObjs:\n            gRect = pygame.Rect( (gObj[\'x\'] - camerax,\n                                  gObj[\'y\'] - cameray,\n                                  gObj[\'width\'],\n                                  gObj[\'height\']) )\n            DISPLAYSURF.blit(GRASSIMAGES[gObj[\'grassImage\']], gRect)\n\n\n        # draw the other squirrels\n        for sObj in squirrelObjs:\n            sObj[\'rect\'] = pygame.Rect( (sObj[\'x\'] - camerax,\n                                         sObj[\'y\'] - cameray - getBounceAmount(sObj[\'bounce\'], sObj[\'bouncerate\'], sObj[\'bounceheight\']),\n                                         sObj[\'width\'],\n                                         sObj[\'height\']) )\n            DISPLAYSURF.blit(sObj[\'surface\'], sObj[\'rect\'])\n\n\n        # draw the player squirrel\n        flashIsOn = round(time.time(), 1) * 10 % 2 == 1\n        if not gameOverMode and not (invulnerableMode and flashIsOn):\n            playerObj[\'rect\'] = pygame.Rect( (playerObj[\'x\'] - camerax,\n                                              playerObj[\'y\'] - cameray - getBounceAmount(playerObj[\'bounce\'], BOUNCERATE, BOUNCEHEIGHT),\n                                              playerObj[\'size\'],\n                                              playerObj[\'size\']) )\n            DISPLAYSURF.blit(playerObj[\'surface\'], playerObj[\'rect\'])\n\n\n        # draw the health meter\n        drawHealthMeter(playerObj[\'health\'])\n\n        for event in pygame.event.get(): # event handling loop\n            if event.type == QUIT:\n                terminate()\n\n            elif event.type == KEYDOWN:\n                if event.key in (K_UP, K_w):\n                    moveDown = False\n                    moveUp = True\n                elif event.key in (K_DOWN, K_s):\n                    moveUp = False\n                    moveDown = True\n                elif event.key in (K_LEFT, K_a):\n                    moveRight = False\n                    moveLeft = True\n                    if playerObj[\'facing\'] != LEFT: # change player image\n                        playerObj[\'surface\'] = pygame.transform.scale(L_SQUIR_IMG, (playerObj[\'size\'], playerObj[\'size\']))\n                    playerObj[\'facing\'] = LEFT\n                elif event.key in (K_RIGHT, K_d):\n                    moveLeft = False\n                    moveRight = True\n                    if playerObj[\'facing\'] != RIGHT: # change player image\n                        playerObj[\'surface\'] = pygame.transform.scale(R_SQUIR_IMG, (playerObj[\'size\'], playerObj[\'size\']))\n                    playerObj[\'facing\'] = RIGHT\n                elif winMode and event.key == K_r:\n                    return\n\n            elif event.type == KEYUP:\n                # stop moving the player\'s squirrel\n                if event.key in (K_LEFT, K_a):\n                    moveLeft = False\n                elif event.key in (K_RIGHT, K_d):\n                    moveRight = False\n                elif event.key in (K_UP, K_w):\n                    moveUp = False\n                elif event.key in (K_DOWN, K_s):\n                    moveDown = False\n\n                elif event.key == K_ESCAPE:\n                    terminate()\n\n        if not gameOverMode:\n            # actually move the player\n            if moveLeft:\n                playerObj[\'x\'] -= MOVERATE\n            if moveRight:\n                playerObj[\'x\'] += MOVERATE\n            if moveUp:\n                playerObj[\'y\'] -= MOVERATE\n            if moveDown:\n                playerObj[\'y\'] += MOVERATE\n\n            if (moveLeft or moveRight or moveUp or moveDown) or playerObj[\'bounce\'] != 0:\n                playerObj[\'bounce\'] += 1\n\n            if playerObj[\'bounce\'] \x3E BOUNCERATE:\n                playerObj[\'bounce\'] = 0 # reset bounce amount\n\n            # check if the player has collided with any squirrels\n            for i in range(len(squirrelObjs)-1, -1, -1):\n                sqObj = squirrelObjs[i]\n                if \'rect\' in sqObj and playerObj[\'rect\'].colliderect(sqObj[\'rect\']):\n                    # a player\x2Fsquirrel collision has occurred\n\n                    if sqObj[\'width\'] * sqObj[\'height\'] \x3C= playerObj[\'size\']**2:\n                        # player is larger and eats the squirrel\n                        playerObj[\'size\'] += int( (sqObj[\'width\'] * sqObj[\'height\'])**0.2 ) + 1\n                        del squirrelObjs[i]\n\n                        if playerObj[\'facing\'] == LEFT:\n                            playerObj[\'surface\'] = pygame.transform.scale(L_SQUIR_IMG, (playerObj[\'size\'], playerObj[\'size\']))\n                        if playerObj[\'facing\'] == RIGHT:\n                            playerObj[\'surface\'] = pygame.transform.scale(R_SQUIR_IMG, (playerObj[\'size\'], playerObj[\'size\']))\n\n                        if playerObj[\'size\'] \x3E WINSIZE:\n                            winMode = True # turn on \"win mode\"\n\n                    elif not invulnerableMode:\n                        # player is smaller and takes damage\n                        invulnerableMode = True\n                        invulnerableStartTime = time.time()\n                        playerObj[\'health\'] -= 1\n                        if playerObj[\'health\'] == 0:\n                            gameOverMode = True # turn on \"game over mode\"\n                            gameOverStartTime = time.time()\n        else:\n            # game is over, show \"game over\" text\n            DISPLAYSURF.blit(gameOverSurf, gameOverRect)\n            if time.time() - gameOverStartTime \x3E GAMEOVERTIME:\n                return # end the current game\n\n        # check if the player has won.\n        if winMode:\n            DISPLAYSURF.blit(winSurf, winRect)\n            DISPLAYSURF.blit(winSurf2, winRect2)\n\n        pygame.display.update()\n        FPSCLOCK.tick(FPS)\n\n\n\n\ndef drawHealthMeter(currentHealth):\n    for i in range(currentHealth): # draw red health bars\n        pygame.draw.rect(DISPLAYSURF, RED,   (15, 5 + (10 * MAXHEALTH) - i * 10, 20, 10))\n    for i in range(MAXHEALTH): # draw the white outlines\n        pygame.draw.rect(DISPLAYSURF, WHITE, (15, 5 + (10 * MAXHEALTH) - i * 10, 20, 10), 1)\n\n\ndef terminate():\n    pygame.quit()\n    sys.exit()\n\n\ndef getBounceAmount(currentBounce, bounceRate, bounceHeight):\n    # Returns the number of pixels to offset based on the bounce.\n    # Larger bounceRate means a slower bounce.\n    # Larger bounceHeight means a higher bounce.\n    # currentBounce will always be less than bounceRate\n    return int(math.sin( (math.pi \x2F float(bounceRate)) * currentBounce ) * bounceHeight)\n\ndef getRandomVelocity():\n    speed = random.randint(SQUIRRELMINSPEED, SQUIRRELMAXSPEED)\n    if random.randint(0, 1) == 0:\n        return speed\n    else:\n        return -speed\n\n\ndef getRandomOffCameraPos(camerax, cameray, objWidth, objHeight):\n    # create a Rect of the camera view\n    cameraRect = pygame.Rect(camerax, cameray, WINWIDTH, WINHEIGHT)\n    while True:\n        x = random.randint(camerax - WINWIDTH, camerax + (2 * WINWIDTH))\n        y = random.randint(cameray - WINHEIGHT, cameray + (2 * WINHEIGHT))\n        # create a Rect object with the random coordinates and use colliderect()\n        # to make sure the right edge isn\'t in the camera view.\n        objRect = pygame.Rect(x, y, objWidth, objHeight)\n        if not objRect.colliderect(cameraRect):\n            return x, y\n\n\ndef makeNewSquirrel(camerax, cameray):\n    sq = {}\n    generalSize = random.randint(5, 25)\n    multiplier = random.randint(1, 3)\n    sq[\'width\']  = (generalSize + random.randint(0, 10)) * multiplier\n    sq[\'height\'] = (generalSize + random.randint(0, 10)) * multiplier\n    sq[\'x\'], sq[\'y\'] = getRandomOffCameraPos(camerax, cameray, sq[\'width\'], sq[\'height\'])\n    sq[\'movex\'] = getRandomVelocity()\n    sq[\'movey\'] = getRandomVelocity()\n    if sq[\'movex\'] \x3C 0: # squirrel is facing left\n        sq[\'surface\'] = pygame.transform.scale(L_SQUIR_IMG, (sq[\'width\'], sq[\'height\']))\n    else: # squirrel is facing right\n        sq[\'surface\'] = pygame.transform.scale(R_SQUIR_IMG, (sq[\'width\'], sq[\'height\']))\n    sq[\'bounce\'] = 0\n    sq[\'bouncerate\'] = random.randint(10, 18)\n    sq[\'bounceheight\'] = random.randint(10, 50)\n    return sq\n\n\ndef makeNewGrass(camerax, cameray):\n    gr = {}\n    gr[\'grassImage\'] = random.randint(0, len(GRASSIMAGES) - 1)\n    gr[\'width\']  = GRASSIMAGES[0].get_width()\n    gr[\'height\'] = GRASSIMAGES[0].get_height()\n    gr[\'x\'], gr[\'y\'] = getRandomOffCameraPos(camerax, cameray, gr[\'width\'], gr[\'height\'])\n    gr[\'rect\'] = pygame.Rect( (gr[\'x\'], gr[\'y\'], gr[\'width\'], gr[\'height\']) )\n    return gr\n\n\ndef isOutsideActiveArea(camerax, cameray, obj):\n    # Return False if camerax and cameray are more than\n    # a half-window length beyond the edge of the window.\n    boundsLeftEdge = camerax - WINWIDTH\n    boundsTopEdge = cameray - WINHEIGHT\n    boundsRect = pygame.Rect(boundsLeftEdge, boundsTopEdge, WINWIDTH * 3, WINHEIGHT * 3)\n    objRect = pygame.Rect(obj[\'x\'], obj[\'y\'], obj[\'width\'], obj[\'height\'])\n    return not boundsRect.colliderect(objRect)\n\n\nif __name__ == \'__main__\':\n    main()",
    "tetromino": "# Tetromino (a Tetris clone)\n# By Al Sweigart al@inventwithpython.com\n# http:\x2F\x2Finventwithpython.com\x2Fpygame\n# Released under a \"Simplified BSD\" license\n\nimport random, time, pygame, sys\nfrom pygame.locals import *\n\nFPS = 25\nWINDOWWIDTH = 640\nWINDOWHEIGHT = 480\nBOXSIZE = 20\nBOARDWIDTH = 10\nBOARDHEIGHT = 20\nBLANK = \'.\'\n\nMOVESIDEWAYSFREQ = 0.15\nMOVEDOWNFREQ = 0.1\n\nXMARGIN = int((WINDOWWIDTH - BOARDWIDTH * BOXSIZE) \x2F 2)\nTOPMARGIN = WINDOWHEIGHT - (BOARDHEIGHT * BOXSIZE) - 5\n\n#               R    G    B\nWHITE       = (255, 255, 255)\nGRAY        = (185, 185, 185)\nBLACK       = (  0,   0,   0)\nRED         = (155,   0,   0)\nLIGHTRED    = (175,  20,  20)\nGREEN       = (  0, 155,   0)\nLIGHTGREEN  = ( 20, 175,  20)\nBLUE        = (  0,   0, 155)\nLIGHTBLUE   = ( 20,  20, 175)\nYELLOW      = (155, 155,   0)\nLIGHTYELLOW = (175, 175,  20)\n\nBORDERCOLOR = BLUE\nBGCOLOR = BLACK\nTEXTCOLOR = WHITE\nTEXTSHADOWCOLOR = GRAY\nCOLORS      = (     BLUE,      GREEN,      RED,      YELLOW)\nLIGHTCOLORS = (LIGHTBLUE, LIGHTGREEN, LIGHTRED, LIGHTYELLOW)\nassert len(COLORS) == len(LIGHTCOLORS) # each color must have light color\n\nTEMPLATEWIDTH = 5\nTEMPLATEHEIGHT = 5\n\nS_SHAPE_TEMPLATE = [[\'.....\',\n                     \'.....\',\n                     \'..OO.\',\n                     \'.OO..\',\n                     \'.....\'],\n                    [\'.....\',\n                     \'..O..\',\n                     \'..OO.\',\n                     \'...O.\',\n                     \'.....\']]\n\nZ_SHAPE_TEMPLATE = [[\'.....\',\n                     \'.....\',\n                     \'.OO..\',\n                     \'..OO.\',\n                     \'.....\'],\n                    [\'.....\',\n                     \'..O..\',\n                     \'.OO..\',\n                     \'.O...\',\n                     \'.....\']]\n\nI_SHAPE_TEMPLATE = [[\'..O..\',\n                     \'..O..\',\n                     \'..O..\',\n                     \'..O..\',\n                     \'.....\'],\n                    [\'.....\',\n                     \'.....\',\n                     \'OOOO.\',\n                     \'.....\',\n                     \'.....\']]\n\nO_SHAPE_TEMPLATE = [[\'.....\',\n                     \'.....\',\n                     \'.OO..\',\n                     \'.OO..\',\n                     \'.....\']]\n\nJ_SHAPE_TEMPLATE = [[\'.....\',\n                     \'.O...\',\n                     \'.OOO.\',\n                     \'.....\',\n                     \'.....\'],\n                    [\'.....\',\n                     \'..OO.\',\n                     \'..O..\',\n                     \'..O..\',\n                     \'.....\'],\n                    [\'.....\',\n                     \'.....\',\n                     \'.OOO.\',\n                     \'...O.\',\n                     \'.....\'],\n                    [\'.....\',\n                     \'..O..\',\n                     \'..O..\',\n                     \'.OO..\',\n                     \'.....\']]\n\nL_SHAPE_TEMPLATE = [[\'.....\',\n                     \'...O.\',\n                     \'.OOO.\',\n                     \'.....\',\n                     \'.....\'],\n                    [\'.....\',\n                     \'..O..\',\n                     \'..O..\',\n                     \'..OO.\',\n                     \'.....\'],\n                    [\'.....\',\n                     \'.....\',\n                     \'.OOO.\',\n                     \'.O...\',\n                     \'.....\'],\n                    [\'.....\',\n                     \'.OO..\',\n                     \'..O..\',\n                     \'..O..\',\n                     \'.....\']]\n\nT_SHAPE_TEMPLATE = [[\'.....\',\n                     \'..O..\',\n                     \'.OOO.\',\n                     \'.....\',\n                     \'.....\'],\n                    [\'.....\',\n                     \'..O..\',\n                     \'..OO.\',\n                     \'..O..\',\n                     \'.....\'],\n                    [\'.....\',\n                     \'.....\',\n                     \'.OOO.\',\n                     \'..O..\',\n                     \'.....\'],\n                    [\'.....\',\n                     \'..O..\',\n                     \'.OO..\',\n                     \'..O..\',\n                     \'.....\']]\n\nPIECES = {\'S\': S_SHAPE_TEMPLATE,\n          \'Z\': Z_SHAPE_TEMPLATE,\n          \'J\': J_SHAPE_TEMPLATE,\n          \'L\': L_SHAPE_TEMPLATE,\n          \'I\': I_SHAPE_TEMPLATE,\n          \'O\': O_SHAPE_TEMPLATE,\n          \'T\': T_SHAPE_TEMPLATE}\n\n\ndef main():\n    global FPSCLOCK, DISPLAYSURF, BASICFONT, BIGFONT\n    pygame.init()\n    FPSCLOCK = pygame.time.Clock()\n    DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))\n    BASICFONT = pygame.font.Font(\'freesansbold.ttf\', 18)\n    BIGFONT = pygame.font.Font(\'freesansbold.ttf\', 100)\n    pygame.display.set_caption(\'Tetromino\')\n\n    showTextScreen(\'Tetromino\')\n    while True: # game loop\n        if random.randint(0, 1) == 0:\n            pygame.mixer.music.load(\'tetrisb.mid\')\n        else:\n            pygame.mixer.music.load(\'tetrisc.mid\')\n        pygame.mixer.music.play(-1, 0.0)\n        runGame()\n        pygame.mixer.music.stop()\n        showTextScreen(\'Game Over\')\n\n\ndef runGame():\n    # setup variables for the start of the game\n    board = getBlankBoard()\n    lastMoveDownTime = time.time()\n    lastMoveSidewaysTime = time.time()\n    lastFallTime = time.time()\n    movingDown = False # note: there is no movingUp variable\n    movingLeft = False\n    movingRight = False\n    score = 0\n    level, fallFreq = calculateLevelAndFallFreq(score)\n\n    fallingPiece = getNewPiece()\n    nextPiece = getNewPiece()\n\n    while True: # game loop\n        if fallingPiece == None:\n            # No falling piece in play, so start a new piece at the top\n            fallingPiece = nextPiece\n            nextPiece = getNewPiece()\n            lastFallTime = time.time() # reset lastFallTime\n\n            if not isValidPosition(board, fallingPiece):\n                return # can\'t fit a new piece on the board, so game over\n\n        checkForQuit()\n        for event in pygame.event.get(): # event handling loop\n            if event.type == KEYUP:\n                if (event.key == K_p):\n                    # Pausing the game\n                    DISPLAYSURF.fill(BGCOLOR)\n                    pygame.mixer.music.stop()\n                    showTextScreen(\'Paused\') # pause until a key press\n                    pygame.mixer.music.play(-1, 0.0)\n                    lastFallTime = time.time()\n                    lastMoveDownTime = time.time()\n                    lastMoveSidewaysTime = time.time()\n                elif (event.key == K_LEFT or event.key == K_a):\n                    movingLeft = False\n                elif (event.key == K_RIGHT or event.key == K_d):\n                    movingRight = False\n                elif (event.key == K_DOWN or event.key == K_s):\n                    movingDown = False\n\n            elif event.type == KEYDOWN:\n                # moving the piece sideways\n                if (event.key == K_LEFT or event.key == K_a) and isValidPosition(board, fallingPiece, adjX=-1):\n                    fallingPiece[\'x\'] -= 1\n                    movingLeft = True\n                    movingRight = False\n                    lastMoveSidewaysTime = time.time()\n\n                elif (event.key == K_RIGHT or event.key == K_d) and isValidPosition(board, fallingPiece, adjX=1):\n                    fallingPiece[\'x\'] += 1\n                    movingRight = True\n                    movingLeft = False\n                    lastMoveSidewaysTime = time.time()\n\n                # rotating the piece (if there is room to rotate)\n                elif (event.key == K_UP or event.key == K_w):\n                    fallingPiece[\'rotation\'] = (fallingPiece[\'rotation\'] + 1) % len(PIECES[fallingPiece[\'shape\']])\n                    if not isValidPosition(board, fallingPiece):\n                        fallingPiece[\'rotation\'] = (fallingPiece[\'rotation\'] - 1) % len(PIECES[fallingPiece[\'shape\']])\n                elif (event.key == K_q): # rotate the other direction\n                    fallingPiece[\'rotation\'] = (fallingPiece[\'rotation\'] - 1) % len(PIECES[fallingPiece[\'shape\']])\n                    if not isValidPosition(board, fallingPiece):\n                        fallingPiece[\'rotation\'] = (fallingPiece[\'rotation\'] + 1) % len(PIECES[fallingPiece[\'shape\']])\n\n                # making the piece fall faster with the down key\n                elif (event.key == K_DOWN or event.key == K_s):\n                    movingDown = True\n                    if isValidPosition(board, fallingPiece, adjY=1):\n                        fallingPiece[\'y\'] += 1\n                    lastMoveDownTime = time.time()\n\n                # move the current piece all the way down\n                elif event.key == K_SPACE:\n                    movingDown = False\n                    movingLeft = False\n                    movingRight = False\n                    for i in range(1, BOARDHEIGHT):\n                        if not isValidPosition(board, fallingPiece, adjY=i):\n                            break\n                    fallingPiece[\'y\'] += i - 1\n\n        # handle moving the piece because of user input\n        if (movingLeft or movingRight) and time.time() - lastMoveSidewaysTime \x3E MOVESIDEWAYSFREQ:\n            if movingLeft and isValidPosition(board, fallingPiece, adjX=-1):\n                fallingPiece[\'x\'] -= 1\n            elif movingRight and isValidPosition(board, fallingPiece, adjX=1):\n                fallingPiece[\'x\'] += 1\n            lastMoveSidewaysTime = time.time()\n\n        if movingDown and time.time() - lastMoveDownTime \x3E MOVEDOWNFREQ and isValidPosition(board, fallingPiece, adjY=1):\n            fallingPiece[\'y\'] += 1\n            lastMoveDownTime = time.time()\n\n        # let the piece fall if it is time to fall\n        if time.time() - lastFallTime \x3E fallFreq:\n            # see if the piece has landed\n            if not isValidPosition(board, fallingPiece, adjY=1):\n                # falling piece has landed, set it on the board\n                addToBoard(board, fallingPiece)\n                score += removeCompleteLines(board)\n                level, fallFreq = calculateLevelAndFallFreq(score)\n                fallingPiece = None\n            else:\n                # piece did not land, just move the piece down\n                fallingPiece[\'y\'] += 1\n                lastFallTime = time.time()\n\n        # drawing everything on the screen\n        DISPLAYSURF.fill(BGCOLOR)\n        drawBoard(board)\n        drawStatus(score, level)\n        drawNextPiece(nextPiece)\n        if fallingPiece != None:\n            drawPiece(fallingPiece)\n\n        pygame.display.update()\n        FPSCLOCK.tick(FPS)\n\n\ndef makeTextObjs(text, font, color):\n    surf = font.render(text, True, color)\n    return surf, surf.get_rect()\n\n\ndef terminate():\n    pygame.quit()\n    sys.exit()\n\n\ndef checkForKeyPress():\n    # Go through event queue looking for a KEYUP event.\n    # Grab KEYDOWN events to remove them from the event queue.\n    checkForQuit()\n\n    for event in pygame.event.get([KEYDOWN, KEYUP]):\n        if event.type == KEYDOWN:\n            continue\n        return event.key\n    return None\n\n\ndef showTextScreen(text):\n    # This function displays large text in the\n    # center of the screen until a key is pressed.\n    # Draw the text drop shadow\n    titleSurf, titleRect = makeTextObjs(text, BIGFONT, TEXTSHADOWCOLOR)\n    titleRect.center = (int(WINDOWWIDTH \x2F 2), int(WINDOWHEIGHT \x2F 2))\n    DISPLAYSURF.blit(titleSurf, titleRect)\n\n    # Draw the text\n    titleSurf, titleRect = makeTextObjs(text, BIGFONT, TEXTCOLOR)\n    titleRect.center = (int(WINDOWWIDTH \x2F 2) - 3, int(WINDOWHEIGHT \x2F 2) - 3)\n    DISPLAYSURF.blit(titleSurf, titleRect)\n\n    # Draw the additional \"Press a key to play.\" text.\n    pressKeySurf, pressKeyRect = makeTextObjs(\'Press a key to play.\', BASICFONT, TEXTCOLOR)\n    pressKeyRect.center = (int(WINDOWWIDTH \x2F 2), int(WINDOWHEIGHT \x2F 2) + 100)\n    DISPLAYSURF.blit(pressKeySurf, pressKeyRect)\n\n    while checkForKeyPress() == None:\n        pygame.display.update()\n        FPSCLOCK.tick()\n\n\ndef checkForQuit():\n    for event in pygame.event.get(QUIT): # get all the QUIT events\n        terminate() # terminate if any QUIT events are present\n    for event in pygame.event.get(KEYUP): # get all the KEYUP events\n        if event.key == K_ESCAPE:\n            terminate() # terminate if the KEYUP event was for the Esc key\n        pygame.event.post(event) # put the other KEYUP event objects back\n\n\ndef calculateLevelAndFallFreq(score):\n    # Based on the score, return the level the player is on and\n    # how many seconds pass until a falling piece falls one space.\n    level = int(score \x2F 10) + 1\n    fallFreq = 0.27 - (level * 0.02)\n    return level, fallFreq\n\ndef getNewPiece():\n    # return a random new piece in a random rotation and color\n    shape = random.choice(list(PIECES.keys()))\n    newPiece = {\'shape\': shape,\n                \'rotation\': random.randint(0, len(PIECES[shape]) - 1),\n                \'x\': int(BOARDWIDTH \x2F 2) - int(TEMPLATEWIDTH \x2F 2),\n                \'y\': -2, # start it above the board (i.e. less than 0)\n                \'color\': random.randint(0, len(COLORS)-1)}\n    return newPiece\n\n\ndef addToBoard(board, piece):\n    # fill in the board based on piece\'s location, shape, and rotation\n    for x in range(TEMPLATEWIDTH):\n        for y in range(TEMPLATEHEIGHT):\n            if PIECES[piece[\'shape\']][piece[\'rotation\']][y][x] != BLANK:\n                board[x + piece[\'x\']][y + piece[\'y\']] = piece[\'color\']\n\n\ndef getBlankBoard():\n    # create and return a new blank board data structure\n    board = []\n    for i in range(BOARDWIDTH):\n        board.append([BLANK] * BOARDHEIGHT)\n    return board\n\n\ndef isOnBoard(x, y):\n    return x \x3E= 0 and x \x3C BOARDWIDTH and y \x3C BOARDHEIGHT\n\n\ndef isValidPosition(board, piece, adjX=0, adjY=0):\n    # Return True if the piece is within the board and not colliding\n    for x in range(TEMPLATEWIDTH):\n        for y in range(TEMPLATEHEIGHT):\n            isAboveBoard = y + piece[\'y\'] + adjY \x3C 0\n            if isAboveBoard or PIECES[piece[\'shape\']][piece[\'rotation\']][y][x] == BLANK:\n                continue\n            if not isOnBoard(x + piece[\'x\'] + adjX, y + piece[\'y\'] + adjY):\n                return False\n            if board[x + piece[\'x\'] + adjX][y + piece[\'y\'] + adjY] != BLANK:\n                return False\n    return True\n\ndef isCompleteLine(board, y):\n    # Return True if the line filled with boxes with no gaps.\n    for x in range(BOARDWIDTH):\n        if board[x][y] == BLANK:\n            return False\n    return True\n\n\ndef removeCompleteLines(board):\n    # Remove any completed lines on the board, move everything above them down, and return the number of complete lines.\n    numLinesRemoved = 0\n    y = BOARDHEIGHT - 1 # start y at the bottom of the board\n    while y \x3E= 0:\n        if isCompleteLine(board, y):\n            # Remove the line and pull boxes down by one line.\n            for pullDownY in range(y, 0, -1):\n                for x in range(BOARDWIDTH):\n                    board[x][pullDownY] = board[x][pullDownY-1]\n            # Set very top line to blank.\n            for x in range(BOARDWIDTH):\n                board[x][0] = BLANK\n            numLinesRemoved += 1\n            # Note on the next iteration of the loop, y is the same.\n            # This is so that if the line that was pulled down is also\n            # complete, it will be removed.\n        else:\n            y -= 1 # move on to check next row up\n    return numLinesRemoved\n\n\ndef convertToPixelCoords(boxx, boxy):\n    # Convert the given xy coordinates of the board to xy\n    # coordinates of the location on the screen.\n    return (XMARGIN + (boxx * BOXSIZE)), (TOPMARGIN + (boxy * BOXSIZE))\n\n\ndef drawBox(boxx, boxy, color, pixelx=None, pixely=None):\n    # draw a single box (each tetromino piece has four boxes)\n    # at xy coordinates on the board. Or, if pixelx \& pixely\n    # are specified, draw to the pixel coordinates stored in\n    # pixelx \& pixely (this is used for the \"Next\" piece).\n    if color == BLANK:\n        return\n    if pixelx == None and pixely == None:\n        pixelx, pixely = convertToPixelCoords(boxx, boxy)\n    pygame.draw.rect(DISPLAYSURF, COLORS[color], (pixelx + 1, pixely + 1, BOXSIZE - 1, BOXSIZE - 1))\n    pygame.draw.rect(DISPLAYSURF, LIGHTCOLORS[color], (pixelx + 1, pixely + 1, BOXSIZE - 4, BOXSIZE - 4))\n\n\ndef drawBoard(board):\n    # draw the border around the board\n    pygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (XMARGIN - 3, TOPMARGIN - 7, (BOARDWIDTH * BOXSIZE) + 8, (BOARDHEIGHT * BOXSIZE) + 8), 5)\n\n    # fill the background of the board\n    pygame.draw.rect(DISPLAYSURF, BGCOLOR, (XMARGIN, TOPMARGIN, BOXSIZE * BOARDWIDTH, BOXSIZE * BOARDHEIGHT))\n    # draw the individual boxes on the board\n    for x in range(BOARDWIDTH):\n        for y in range(BOARDHEIGHT):\n            drawBox(x, y, board[x][y])\n\n\ndef drawStatus(score, level):\n    # draw the score text\n    scoreSurf = BASICFONT.render(\'Score: %s\' % score, True, TEXTCOLOR)\n    scoreRect = scoreSurf.get_rect()\n    scoreRect.topleft = (WINDOWWIDTH - 150, 20)\n    DISPLAYSURF.blit(scoreSurf, scoreRect)\n\n    # draw the level text\n    levelSurf = BASICFONT.render(\'Level: %s\' % level, True, TEXTCOLOR)\n    levelRect = levelSurf.get_rect()\n    levelRect.topleft = (WINDOWWIDTH - 150, 50)\n    DISPLAYSURF.blit(levelSurf, levelRect)\n\n\ndef drawPiece(piece, pixelx=None, pixely=None):\n    shapeToDraw = PIECES[piece[\'shape\']][piece[\'rotation\']]\n    if pixelx == None and pixely == None:\n        # if pixelx \& pixely hasn\'t been specified, use the location stored in the piece data structure\n        pixelx, pixely = convertToPixelCoords(piece[\'x\'], piece[\'y\'])\n\n    # draw each of the boxes that make up the piece\n    for x in range(TEMPLATEWIDTH):\n        for y in range(TEMPLATEHEIGHT):\n            if shapeToDraw[y][x] != BLANK:\n                drawBox(None, None, piece[\'color\'], pixelx + (x * BOXSIZE), pixely + (y * BOXSIZE))\n\n\ndef drawNextPiece(piece):\n    # draw the \"next\" text\n    nextSurf = BASICFONT.render(\'Next:\', True, TEXTCOLOR)\n    nextRect = nextSurf.get_rect()\n    nextRect.topleft = (WINDOWWIDTH - 120, 80)\n    DISPLAYSURF.blit(nextSurf, nextRect)\n    # draw the \"next\" piece\n    drawPiece(piece, pixelx=WINDOWWIDTH-120, pixely=100)\n\n\nif __name__ == \'__main__\':\n    main()",
    "wormy": "# Wormy (a Nibbles clone)\n# By Al Sweigart al@inventwithpython.com\n# http:\x2F\x2Finventwithpython.com\x2Fpygame\n# Released under a \"Simplified BSD\" license\n\nimport random, pygame, sys\nfrom pygame.locals import *\n\nFPS = 15\nWINDOWWIDTH = 640\nWINDOWHEIGHT = 480\nCELLSIZE = 20\nassert WINDOWWIDTH % CELLSIZE == 0, \"Window width must be a multiple of cell size.\"\nassert WINDOWHEIGHT % CELLSIZE == 0, \"Window height must be a multiple of cell size.\"\nCELLWIDTH = int(WINDOWWIDTH \x2F CELLSIZE)\nCELLHEIGHT = int(WINDOWHEIGHT \x2F CELLSIZE)\n\n#             R    G    B\nWHITE     = (255, 255, 255)\nBLACK     = (  0,   0,   0)\nRED       = (255,   0,   0)\nGREEN     = (  0, 255,   0)\nDARKGREEN = (  0, 155,   0)\nDARKGRAY  = ( 40,  40,  40)\nBGCOLOR = BLACK\n\nUP = \'up\'\nDOWN = \'down\'\nLEFT = \'left\'\nRIGHT = \'right\'\n\nHEAD = 0 # syntactic sugar: index of the worm\'s head\n\ndef main():\n    global FPSCLOCK, DISPLAYSURF, BASICFONT\n\n    pygame.init()\n    FPSCLOCK = pygame.time.Clock()\n    DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))\n    BASICFONT = pygame.font.Font(\'freesansbold.ttf\', 18)\n    pygame.display.set_caption(\'Wormy\')\n\n    showStartScreen()\n    while True:\n        runGame()\n        showGameOverScreen()\n\n\ndef runGame():\n    # Set a random start point.\n    startx = random.randint(5, CELLWIDTH - 6)\n    starty = random.randint(5, CELLHEIGHT - 6)\n    wormCoords = [{\'x\': startx,     \'y\': starty},\n                  {\'x\': startx - 1, \'y\': starty},\n                  {\'x\': startx - 2, \'y\': starty}]\n    direction = RIGHT\n\n    # Start the apple in a random place.\n    apple = getRandomLocation()\n\n    while True: # main game loop\n        for event in pygame.event.get(): # event handling loop\n            if event.type == QUIT:\n                terminate()\n            elif event.type == KEYDOWN:\n                if (event.key == K_LEFT or event.key == K_a) and direction != RIGHT:\n                    direction = LEFT\n                elif (event.key == K_RIGHT or event.key == K_d) and direction != LEFT:\n                    direction = RIGHT\n                elif (event.key == K_UP or event.key == K_w) and direction != DOWN:\n                    direction = UP\n                elif (event.key == K_DOWN or event.key == K_s) and direction != UP:\n                    direction = DOWN\n                elif event.key == K_ESCAPE:\n                    terminate()\n\n        # check if the worm has hit itself or the edge\n        if wormCoords[HEAD][\'x\'] == -1 or wormCoords[HEAD][\'x\'] == CELLWIDTH or wormCoords[HEAD][\'y\'] == -1 or wormCoords[HEAD][\'y\'] == CELLHEIGHT:\n            return # game over\n        for wormBody in wormCoords[1:]:\n            if wormBody[\'x\'] == wormCoords[HEAD][\'x\'] and wormBody[\'y\'] == wormCoords[HEAD][\'y\']:\n                return # game over\n\n        # check if worm has eaten an apply\n        if wormCoords[HEAD][\'x\'] == apple[\'x\'] and wormCoords[HEAD][\'y\'] == apple[\'y\']:\n            # don\'t remove worm\'s tail segment\n            apple = getRandomLocation() # set a new apple somewhere\n        else:\n            del wormCoords[-1] # remove worm\'s tail segment\n\n        # move the worm by adding a segment in the direction it is moving\n        if direction == UP:\n            newHead = {\'x\': wormCoords[HEAD][\'x\'], \'y\': wormCoords[HEAD][\'y\'] - 1}\n        elif direction == DOWN:\n            newHead = {\'x\': wormCoords[HEAD][\'x\'], \'y\': wormCoords[HEAD][\'y\'] + 1}\n        elif direction == LEFT:\n            newHead = {\'x\': wormCoords[HEAD][\'x\'] - 1, \'y\': wormCoords[HEAD][\'y\']}\n        elif direction == RIGHT:\n            newHead = {\'x\': wormCoords[HEAD][\'x\'] + 1, \'y\': wormCoords[HEAD][\'y\']}\n        wormCoords.insert(0, newHead)\n        DISPLAYSURF.fill(BGCOLOR)\n        drawGrid()\n        drawWorm(wormCoords)\n        drawApple(apple)\n        drawScore(len(wormCoords) - 3)\n        pygame.display.update()\n        FPSCLOCK.tick(FPS)\n\ndef drawPressKeyMsg():\n    pressKeySurf = BASICFONT.render(\'Press a key to play.\', True, DARKGRAY)\n    pressKeyRect = pressKeySurf.get_rect()\n    pressKeyRect.topleft = (WINDOWWIDTH - 200, WINDOWHEIGHT - 30)\n    DISPLAYSURF.blit(pressKeySurf, pressKeyRect)\n\n\ndef checkForKeyPress():\n    if len(pygame.event.get(QUIT)) \x3E 0:\n        terminate()\n\n    keyUpEvents = pygame.event.get(KEYUP)\n    if len(keyUpEvents) == 0:\n        return None\n    if keyUpEvents[0].key == K_ESCAPE:\n        terminate()\n    return keyUpEvents[0].key\n\n\ndef showStartScreen():\n    titleFont = pygame.font.Font(\'freesansbold.ttf\', 100)\n    titleSurf1 = titleFont.render(\'Wormy!\', True, WHITE, DARKGREEN)\n    titleSurf2 = titleFont.render(\'Wormy!\', True, GREEN)\n\n    degrees1 = 0\n    degrees2 = 0\n    while True:\n        DISPLAYSURF.fill(BGCOLOR)\n        rotatedSurf1 = pygame.transform.rotate(titleSurf1, degrees1)\n        rotatedRect1 = rotatedSurf1.get_rect()\n        rotatedRect1.center = (WINDOWWIDTH \x2F 2, WINDOWHEIGHT \x2F 2)\n        DISPLAYSURF.blit(rotatedSurf1, rotatedRect1)\n\n        rotatedSurf2 = pygame.transform.rotate(titleSurf2, degrees2)\n        rotatedRect2 = rotatedSurf2.get_rect()\n        rotatedRect2.center = (WINDOWWIDTH \x2F 2, WINDOWHEIGHT \x2F 2)\n        DISPLAYSURF.blit(rotatedSurf2, rotatedRect2)\n\n        drawPressKeyMsg()\n\n        if checkForKeyPress():\n            pygame.event.get() # clear event queue\n            return\n        pygame.display.update()\n        FPSCLOCK.tick(FPS)\n        degrees1 += 3 # rotate by 3 degrees each frame\n        degrees2 += 7 # rotate by 7 degrees each frame\n\n\ndef terminate():\n    pygame.quit()\n    sys.exit()\n\n\ndef getRandomLocation():\n    return {\'x\': random.randint(0, CELLWIDTH - 1), \'y\': random.randint(0, CELLHEIGHT - 1)}\n\n\ndef showGameOverScreen():\n    gameOverFont = pygame.font.Font(\'freesansbold.ttf\', 150)\n    gameSurf = gameOverFont.render(\'Game\', True, WHITE)\n    overSurf = gameOverFont.render(\'Over\', True, WHITE)\n    gameRect = gameSurf.get_rect()\n    overRect = overSurf.get_rect()\n    gameRect.midtop = (WINDOWWIDTH \x2F 2, 10)\n    overRect.midtop = (WINDOWWIDTH \x2F 2, gameRect.height + 10 + 25)\n\n    DISPLAYSURF.blit(gameSurf, gameRect)\n    DISPLAYSURF.blit(overSurf, overRect)\n    drawPressKeyMsg()\n    pygame.display.update()\n    pygame.time.wait(500)\n    checkForKeyPress() # clear out any key presses in the event queue\n\n    while True:\n        if checkForKeyPress():\n            pygame.event.get() # clear event queue\n            return\n\ndef drawScore(score):\n    scoreSurf = BASICFONT.render(\'Score: %s\' % (score), True, WHITE)\n    scoreRect = scoreSurf.get_rect()\n    scoreRect.topleft = (WINDOWWIDTH - 120, 10)\n    DISPLAYSURF.blit(scoreSurf, scoreRect)\n\n\ndef drawWorm(wormCoords):\n    for coord in wormCoords:\n        x = coord[\'x\'] * CELLSIZE\n        y = coord[\'y\'] * CELLSIZE\n        wormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE)\n        pygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect)\n        wormInnerSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, CELLSIZE - 8)\n        pygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect)\n\n\ndef drawApple(coord):\n    x = coord[\'x\'] * CELLSIZE\n    y = coord[\'y\'] * CELLSIZE\n    appleRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE)\n    pygame.draw.rect(DISPLAYSURF, RED, appleRect)\n\n\ndef drawGrid():\n    for x in range(0, WINDOWWIDTH, CELLSIZE): # draw vertical lines\n        pygame.draw.line(DISPLAYSURF, DARKGRAY, (x, 0), (x, WINDOWHEIGHT))\n    for y in range(0, WINDOWHEIGHT, CELLSIZE): # draw horizontal lines\n        pygame.draw.line(DISPLAYSURF, DARKGRAY, (0, y), (WINDOWWIDTH, y))\n\n\nif __name__ == \'__main__\':\n    main()",
    "blankpygame": "import pygame, sys\nfrom pygame.locals import *\n\npygame.init()\nDISPLAYSURF = pygame.display.set_mode((400, 300))\npygame.display.set_caption(\'Hello Pygame World!\')\nwhile True: # main game loop\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n            sys.exit()\n"
};